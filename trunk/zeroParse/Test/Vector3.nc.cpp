
namespace Ogre {
    
typedef unsigned int uint32;
typedef unsigned short uint16;
typedef unsigned char uint8;
}
#pragma warning (disable : 4786)
#pragma warning (disable : 4503)
#pragma warning (disable : 4244)
#pragma warning (disable : 4305)
#pragma warning (disable : 4251)
#pragma warning (disable : 4275)
#pragma warning( disable : 4290 )
#pragma warning( disable: 4661)
#pragma warning( disable: 4996)
#pragma warning (disable : 201)
#pragma once
 
    
#pragma once
                                                
                                                
#pragma once
typedef __w64 unsigned int   size_t;
namespace vc_attributes
{
enum YesNoMaybe
{
	No = 0x0fff0001,
Maybe = 0x0fff0010,
Yes = 0x0fff0100
};
typedef enum YesNoMaybe YesNoMaybe;
enum AccessType
{
NoAccess = 0,
Read = 1,
Write = 2,
ReadWrite = 3
};
typedef enum AccessType AccessType;
[repeatable]
[source_annotation_attribute( Parameter )]
struct PreAttribute
{
	PreAttribute();
	unsigned int Deref;
YesNoMaybe Valid;
YesNoMaybe Null;
YesNoMaybe Tainted;
AccessType Access;
size_t ValidElementsConst;
size_t ValidBytesConst;
const wchar_t* ValidElements;
const wchar_t* ValidBytes;
const wchar_t* ValidElementsLength;
const wchar_t* ValidBytesLength;
size_t WritableElementsConst;
size_t WritableBytesConst;
const wchar_t* WritableElements;
const wchar_t* WritableBytes;
const wchar_t* WritableElementsLength;
const wchar_t* WritableBytesLength;
size_t ElementSizeConst;
const wchar_t* ElementSize;
YesNoMaybe NullTerminated;
const wchar_t* Condition;
};
[repeatable]
[source_annotation_attribute( Parameter|ReturnValue )]
struct PostAttribute
{
	PostAttribute();
	unsigned int Deref;
YesNoMaybe Valid;
YesNoMaybe Null;
YesNoMaybe Tainted;
AccessType Access;
size_t ValidElementsConst;
size_t ValidBytesConst;
const wchar_t* ValidElements;
const wchar_t* ValidBytes;
const wchar_t* ValidElementsLength;
const wchar_t* ValidBytesLength;
size_t WritableElementsConst;
size_t WritableBytesConst;
const wchar_t* WritableElements;
const wchar_t* WritableBytes;
const wchar_t* WritableElementsLength;
const wchar_t* WritableBytesLength;
size_t ElementSizeConst;
const wchar_t* ElementSize;
YesNoMaybe NullTerminated;
YesNoMaybe MustCheck;
const wchar_t* Condition;
};
[source_annotation_attribute( Parameter )]
struct FormatStringAttribute
{
	FormatStringAttribute();
	const wchar_t* Style;
const wchar_t* UnformattedAlternative;
};
[repeatable]
[source_annotation_attribute( ReturnValue )]
struct InvalidCheckAttribute
{
	InvalidCheckAttribute();
	long Value;
};
[source_annotation_attribute( Method )]
struct SuccessAttribute
{
	SuccessAttribute();
	const wchar_t* Condition;
};
[repeatable]
[source_annotation_attribute( Parameter )]
struct PreBoundAttribute
{
	PreBoundAttribute();
	unsigned int Deref;
};
[repeatable]
[source_annotation_attribute( Parameter|ReturnValue )]
struct PostBoundAttribute
{
	PostBoundAttribute();
	unsigned int Deref;
};
[repeatable]
[source_annotation_attribute( Parameter )]
struct PreRangeAttribute
{
	PreRangeAttribute();
	unsigned int Deref;
const char* MinVal;
const char* MaxVal;
};
[repeatable]
[source_annotation_attribute( Parameter|ReturnValue )]
struct PostRangeAttribute
{
	PostRangeAttribute();
	unsigned int Deref;
const char* MinVal;
const char* MaxVal;
};
};  
typedef ::vc_attributes::YesNoMaybe SA_YesNoMaybe;
const ::vc_attributes::YesNoMaybe SA_Yes = ::vc_attributes::Yes;
const ::vc_attributes::YesNoMaybe SA_No = ::vc_attributes::No;
const ::vc_attributes::YesNoMaybe SA_Maybe = ::vc_attributes::Maybe;
typedef ::vc_attributes::AccessType SA_AccessType;
const ::vc_attributes::AccessType SA_NoAccess = ::vc_attributes::NoAccess;
const ::vc_attributes::AccessType SA_Read = ::vc_attributes::Read;
const ::vc_attributes::AccessType SA_Write = ::vc_attributes::Write;
const ::vc_attributes::AccessType SA_ReadWrite = ::vc_attributes::ReadWrite;
typedef ::vc_attributes::PreAttribute          SA_Pre;
typedef ::vc_attributes::PostAttribute         SA_Post;
typedef ::vc_attributes::FormatStringAttribute SA_FormatString;
typedef ::vc_attributes::InvalidCheckAttribute SA_InvalidCheck; 
typedef ::vc_attributes::SuccessAttribute      SA_Success;
typedef ::vc_attributes::PreBoundAttribute     SA_PreBound;
typedef ::vc_attributes::PostBoundAttribute    SA_PostBound;
typedef ::vc_attributes::PreRangeAttribute     SA_PreRange;
typedef ::vc_attributes::PostRangeAttribute    SA_PostRange;
extern "C" {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
#pragma once
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
"name='" "Microsoft.VC90" ".CRT' "              \
"version='" "9.0.21022.8" "' "                          \
"processorArchitecture='x86' "                                  \
"publicKeyToken='" "1fc8b3b9a1e18e3b" "'\"")
#pragma pack(push,8)
#pragma once
#pragma pack(push,8)
extern "C" {
typedef __w64 unsigned int   uintptr_t;
typedef char *  va_list;
}
#pragma pack(pop)
extern "C" {
 
  
 
 
 
  
 
   
 
typedef size_t rsize_t;
typedef __w64 int            intptr_t;
typedef __w64 int            ptrdiff_t;
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
__declspec(deprecated("This name was supported during some Whidbey pre-releases. Instead, use the standard name errno_t.")) typedef int errcode;
typedef int errno_t;
typedef __w64 long __time32_t;   
typedef __int64 __time64_t;     
typedef __time64_t time_t;      
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;
typedef struct localeinfo_struct
{
pthreadlocinfo locinfo;
pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;
typedef struct tagLC_ID {
unsigned short wLanguage;
unsigned short wCountry;
unsigned short wCodePage;
} LC_ID, *LPLC_ID;
typedef struct threadlocaleinfostruct {
int refcount;
unsigned int lc_codepage;
unsigned int lc_collate_cp;
unsigned long lc_handle[6]; 
LC_ID lc_id[6];
struct {
char *locale;
wchar_t *wlocale;
int *refcount;
int *wrefcount;
} lc_category[6];
int lc_clike;
int mb_cur_max;
int * lconv_intl_refcount;
int * lconv_num_refcount;
int * lconv_mon_refcount;
struct lconv * lconv;
int * ctype1_refcount;
unsigned short * ctype1;
const unsigned short * pctype;
const unsigned char * pclmap;
const unsigned char * pcumap;
struct __lc_time_data * lc_time_curr;
} threadlocinfo;
}
#pragma pack(pop)
#pragma pack(push,8)
		
		
		
 
 
 
 
 
 
 
 
 
	
		
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
#pragma once
#pragma comment(lib,"msvcprt")
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
"name='" "Microsoft.VC90" ".CRT' "              \
"version='" "9.0.21022.8" "' "                           \
"processorArchitecture='x86' "                                  \
"publicKeyToken='" "1fc8b3b9a1e18e3b" "'\"")
 
 
 
   
 
 
 
   
    
 
 
   
 
 
   
 
 
   
 
 
 
 
     
 
    
  
		
 
  
  
  
  
   
   
  
  
 
 
 
namespace std {
typedef bool _Bool;
}
		
		
typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;
		
 
 
		
 
namespace std {
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
{	
public:
    
    explicit __thiscall _Lockit();	
explicit __thiscall _Lockit(int);	
__thiscall ~_Lockit();	
    static  void __cdecl _Lockit_ctor(int);
static  void __cdecl _Lockit_dtor(int);
private:
static  void __cdecl _Lockit_ctor(_Lockit *);
static  void __cdecl _Lockit_ctor(_Lockit *, int);
static  void __cdecl _Lockit_dtor(_Lockit *);
	 _Lockit(const _Lockit&);				
_Lockit&  operator=(const _Lockit&);	
	int _Locktype;
  
	};
class __declspec(dllimport) _Mutex
{	
public:
  
    
    __thiscall _Mutex();
__thiscall ~_Mutex();
void __thiscall _Lock();
void __thiscall _Unlock();
private:
static  void __cdecl _Mutex_ctor(_Mutex *);
static  void __cdecl _Mutex_dtor(_Mutex *);
static  void __cdecl _Mutex_Lock(_Mutex *);
static  void __cdecl _Mutex_Unlock(_Mutex *);
	 _Mutex(const _Mutex&);				
_Mutex&  operator=(const _Mutex&);	
void *_Mtx;
  
	};
class __declspec(dllimport) _Init_locks
{	
public:
 
    
    __thiscall _Init_locks();
__thiscall ~_Init_locks();
private:
static  void __cdecl _Init_locks_ctor(_Init_locks *);
static  void __cdecl _Init_locks_dtor(_Init_locks *);
 
	};
#pragma warning(pop)
}
		
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));
typedef int _Mbstatet;
  
 #pragma pack(pop)
 
#pragma once
 
#pragma once
 
#pragma pack(push,8)
extern "C" {
struct _iobuf {
char *_ptr;
int   _cnt;
char *_base;
int   _flag;
int   _file;
int   _charbuf;
int   _bufsiz;
char *_tmpfname;
};
typedef struct _iobuf FILE;
__declspec(dllimport) FILE * __cdecl __iob_func(void);
typedef __int64 fpos_t;
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _filbuf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File );
__declspec(dllimport) int __cdecl _flsbuf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) FILE * __cdecl _fsopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ShFlag);
__declspec(dllimport) void __cdecl clearerr([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) errno_t __cdecl clearerr_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File );
 __declspec(dllimport) int __cdecl fclose([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _fcloseall(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) FILE * __cdecl _fdopen([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileHandle, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl feof([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl ferror([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] FILE * _File);
__declspec(dllimport) int __cdecl fflush([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl fgetc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _fgetchar(void);
__declspec(dllimport) int __cdecl fgetpos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File , [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] fpos_t * _Pos);
__declspec(dllimport) char * __cdecl fgets([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _MaxCount, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _fileno([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) char * __cdecl _tempnam([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _DirName, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _FilePrefix);
 __declspec(dllimport) int __cdecl _flushall(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl fopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode);
 __declspec(dllimport) errno_t __cdecl fopen_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Pre(Deref=2,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] FILE ** _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode);
 __declspec(dllimport) int __cdecl fprintf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl fprintf_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl fputc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _fputchar([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch);
__declspec(dllimport) int __cdecl fputs([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) size_t __cdecl fread([SA_Pre(Null=SA_No,WritableBytes="\n@""_ElementSize*_Count")] [SA_Pre(Deref=1,Valid=SA_No)] void * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _ElementSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) size_t __cdecl fread_s([SA_Pre(Null=SA_No,WritableBytes="\n@""_ElementSize*_Count")] [SA_Pre(Deref=1,Valid=SA_No)] void * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _ElementSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl freopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) errno_t __cdecl freopen_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Pre(Deref=2,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] FILE ** _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _OldFile);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fscanf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fscanf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)
 __declspec(dllimport) int __cdecl fscanf_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl _fscanf_s_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl fsetpos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const fpos_t * _Pos);
__declspec(dllimport) int __cdecl fseek([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Offset, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Origin);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long __cdecl ftell([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) int __cdecl _fseeki64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __int64 _Offset, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Origin);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64 __cdecl _ftelli64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) size_t __cdecl fwrite([SA_Pre(Null=SA_No,ValidElements="\n@""_Size*_Count")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl getc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl getchar(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _getmaxstdio(void);
__declspec(dllimport) char * __cdecl gets_s([SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _Size);
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) { return gets_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "gets_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl gets([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Null=SA_No,WritableElementsConst=((size_t)-1))] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buffer);
[returnvalue:SA_Post(MustCheck=SA_Yes)] int __cdecl _getw([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) void __cdecl perror([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _ErrMsg);
 __declspec(dllimport) int __cdecl _pclose([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) FILE * __cdecl _popen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Command, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Mode);
__declspec(dllimport) int __cdecl printf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl printf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl putc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl putchar([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch);
__declspec(dllimport) int __cdecl puts([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str);
__declspec(dllimport) int __cdecl _putw([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Word, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl remove([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl rename([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _OldFilename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _NewFilename);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _unlink([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_unlink" ". See online help for details.")) __declspec(dllimport) int __cdecl unlink([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename);
__declspec(dllimport) void __cdecl rewind([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _rmtmp(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl scanf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _scanf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl scanf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl _scanf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl setbuf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_Maybe,WritableElementsConst=512)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Post(ValidElementsConst=0)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buffer);
__declspec(dllimport) int __cdecl _setmaxstdio([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Max);
__declspec(dllimport) unsigned int __cdecl _set_output_format([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Format);
__declspec(dllimport) unsigned int __cdecl _get_output_format(void);
__declspec(dllimport) int __cdecl setvbuf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
__declspec(dllimport) int __cdecl _snprintf_s([SA_Pre(Null=SA_No,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); } __pragma(warning(pop)); }
 __declspec(dllimport) int __cdecl sprintf_s([SA_Pre(Null=SA_No,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _scprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sscanf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sscanf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl sscanf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, ...);
 __declspec(dllimport) int __cdecl _sscanf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf([SA_Pre(Null=SA_No,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf_l([SA_Pre(Null=SA_No,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _snscanf_s([SA_Pre(Null=SA_No,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, ...);
__declspec(dllimport) int __cdecl _snscanf_s_l([SA_Pre(Null=SA_No,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl tmpfile(void);
 __declspec(dllimport) errno_t __cdecl tmpfile_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No)] [SA_Post(Deref=2,Valid=SA_Yes)] FILE ** _File);
__declspec(dllimport) errno_t __cdecl tmpnam_s([SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s([SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Buf)[_Size]) { return tmpnam_s(_Buf, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl tmpnam([SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buffer);
__declspec(dllimport) int __cdecl ungetc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl vfprintf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vfprintf_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vprintf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsnprintf([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vsnprintf_s([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _Args) { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf([SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf([SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _Args);
#pragma warning(pop)
__declspec(dllimport) int __cdecl vsprintf_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _Args) { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sprintf([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsprintf([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _Args);
#pragma warning(pop)
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _vscprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _snprintf_c([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
__declspec(dllimport) int __cdecl _vsnprintf_c([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char *_DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _fprintf_p([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
__declspec(dllimport) int __cdecl _printf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
__declspec(dllimport) int __cdecl _sprintf_p([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
__declspec(dllimport) int __cdecl _vfprintf_p([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _vprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _vsprintf_p([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _scprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _vscprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output();
 __declspec(dllimport) int __cdecl _printf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _printf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _printf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vprintf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _fprintf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _fprintf_p_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _fprintf_s_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vfprintf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vfprintf_p_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vfprintf_s_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sprintf_l([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _sprintf_p_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _sprintf_s_l([SA_Pre(Null=SA_No,WritableBytes="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsprintf_l([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t, va_list _ArgList);
__declspec(dllimport) int __cdecl _vsprintf_p_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char* _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale,  va_list _ArgList);
__declspec(dllimport) int __cdecl _vsprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _scprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _scprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vscprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vscprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _snprintf_c_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _snprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vsnprintf_c_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, const char *, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vsnprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char* _Format,[SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) FILE * __cdecl _wfsopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ShFlag);
 __declspec(dllimport) wint_t __cdecl fgetwc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) wint_t __cdecl _fgetwchar(void);
__declspec(dllimport) wint_t __cdecl fputwc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) wint_t __cdecl _fputwchar([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl getwc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl getwchar(void);
__declspec(dllimport) wint_t __cdecl putwc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) wint_t __cdecl putwchar([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch);
__declspec(dllimport) wint_t __cdecl ungetwc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) wchar_t * __cdecl fgetws([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl fputws([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) wchar_t * __cdecl _getws_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(wchar_t (&_String)[_Size]) { return _getws_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_getws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _getws([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_String);
__declspec(dllimport) int __cdecl _putws([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str);
 __declspec(dllimport) int __cdecl fwprintf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl fwprintf_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl wprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl wprintf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _scwprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl vfwprintf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vfwprintf_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vwprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vwprintf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl swprintf_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
__declspec(dllimport) int __cdecl vswprintf_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _Args) { return vswprintf_s(_Dest, _Size, _Format, _Args); } }
 __declspec(dllimport) int __cdecl _swprintf_c([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _vswprintf_c([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _snwprintf_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...) { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
__declspec(dllimport) int __cdecl _vsnwprintf_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _Args) { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf([SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] wchar_t *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf([SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] wchar_t *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _Args);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl _fwprintf_p([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _wprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _vfwprintf_p([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _vwprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _swprintf_p([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _vswprintf_p([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _scwprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _vscwprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _wprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _wprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _wprintf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vwprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vwprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vwprintf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _fwprintf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _fwprintf_p_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _fwprintf_s_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vfwprintf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vfwprintf_p_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vfwprintf_s_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _swprintf_c_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _swprintf_p_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _swprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vswprintf_c_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vswprintf_p_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vswprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _scwprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _scwprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _vscwprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _snwprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vsnwprintf_s_l([SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _Args);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l( wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, _locale_t _Plocinfo, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l( wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)
#pragma once
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
va_list _Arglist;
int _Ret;
( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
( _Arglist = (va_list)0 );
return _Ret;
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
va_list _Arglist;
int _Ret;
( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
( _Arglist = (va_list)0 );
return _Ret;
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4996 )
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int swprintf([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _String, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...)
{
va_list _Arglist;
( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
int _Ret = _vswprintf(_String, _Format, _Arglist);
( _Arglist = (va_list)0 );
return _Ret;
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl vswprintf([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _String, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _Ap)
{
return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int _swprintf_l([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _String, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
va_list _Arglist;
( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
( _Arglist = (va_list)0 );
return _Ret;
}
#pragma warning( pop )
#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl _vswprintf_l([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _String, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )
#pragma warning( pop )
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wchar_t * __cdecl _wtempnam([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Directory, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _FilePrefix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _vscwprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, va_list _ArgList);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _vscwprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fwscanf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fwscanf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl fwscanf_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _fwscanf_s_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl swscanf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _swscanf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl swscanf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _swscanf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf([SA_Pre(Null=SA_No,ValidElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf_l([SA_Pre(Null=SA_No,ValidElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _snwscanf_s([SA_Pre(Null=SA_No,ValidElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _snwscanf_s_l([SA_Pre(Null=SA_No,ValidElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl wscanf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wscanf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl wscanf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _wscanf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf_s")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
#pragma warning(pop)
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) FILE * __cdecl _wfdopen([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileHandle , [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode);
__declspec(dllimport) errno_t __cdecl _wfopen_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Pre(Deref=2,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] FILE ** _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfreopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _OldFile);
__declspec(dllimport) errno_t __cdecl _wfreopen_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Pre(Deref=2,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] FILE ** _File, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _OldFile);
__declspec(dllimport) void __cdecl _wperror([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ErrMsg);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) FILE * __cdecl _wpopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Command, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Mode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wremove([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename);
__declspec(dllimport) errno_t __cdecl _wtmpnam_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s([SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size]) { return _wtmpnam_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wtmpnam([SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Buffer);
 __declspec(dllimport) wint_t __cdecl _fgetwc_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) wint_t __cdecl _fputwc_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) wint_t __cdecl _ungetwc_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
inline wint_t __cdecl getwchar()
{return (fgetwc((&__iob_func()[0]))); }   
inline wint_t __cdecl putwchar(wchar_t _C)
{return (fputwc(_C, (&__iob_func()[1]))); }       
__declspec(dllimport) void __cdecl _lock_file([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
 __declspec(dllimport) int __cdecl _fclose_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _fflush_nolock([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) size_t __cdecl _fread_nolock([SA_Pre(Null=SA_No,WritableBytes="\n@""_ElementSize*_Count")] [SA_Pre(Deref=1,Valid=SA_No)] void * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _ElementSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) size_t __cdecl _fread_nolock_s([SA_Pre(Null=SA_No,WritableBytes="\n@""_ElementSize*_Count")] [SA_Pre(Deref=1,Valid=SA_No)] void * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _ElementSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _fseek_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Offset, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Origin);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long __cdecl _ftell_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _fseeki64_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __int64 _Offset, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Origin);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64 __cdecl _ftelli64_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) size_t __cdecl _fwrite_nolock([SA_Pre(Null=SA_No,ValidBytes="\n@""_Size*_Count")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(dllimport) int __cdecl _ungetc_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_tempnam" ". See online help for details.")) __declspec(dllimport) char * __cdecl tempnam([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Directory, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _FilePrefix);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport) FILE * __cdecl fdopen([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileHandle, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Format);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport) int __cdecl fileno([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] FILE * _File);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport) int __cdecl getw([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport) int __cdecl putw([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] FILE * _File);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);
}
#pragma pack(pop)
 
 
 
 
 
 
typedef FILE _iobuf;
 
namespace std {
using ::_iobuf;
using ::size_t; using ::fpos_t; using ::FILE;
using ::clearerr; using ::fclose; using ::feof;
using ::ferror; using ::fflush; using ::fgetc;
using ::fgetpos; using ::fgets; using ::fopen;
using ::fprintf; using ::fputc; using ::fputs;
using ::fread; using ::freopen; using ::fscanf;
using ::fseek; using ::fsetpos; using ::ftell;
using ::fwrite; using ::getc; using ::getchar;
using ::gets; using ::perror;
using ::putc; using ::putchar;
using ::printf; using ::puts; using ::remove;
using ::rename; using ::rewind; using ::scanf;
using ::setbuf; using ::setvbuf; using ::sprintf;
using ::sscanf; using ::tmpfile; using ::tmpnam;
using ::ungetc; using ::vfprintf; using ::vprintf;
using ::vsprintf;
}
#pragma once
 
#pragma once
 
#pragma once
 
#pragma pack(push,8)
extern "C" {
typedef int (__cdecl * _onexit_t)(void);
typedef struct _div_t {
int quot;
int rem;
} div_t;
typedef struct _ldiv_t {
long quot;
long rem;
} ldiv_t;
#pragma pack(4)
typedef struct {
unsigned char ld[10];
} _LDOUBLE;
#pragma pack()
typedef struct {
double x;
} _CRT_DOUBLE;
typedef struct {
float f;
} _CRT_FLOAT;
typedef struct {
        long double x;
} _LONGDOUBLE;
#pragma pack(4)
typedef struct {
unsigned char ld12[12];
} _LDBL12;
#pragma pack()
__declspec(dllimport) extern int __mb_cur_max;
__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
typedef void (__cdecl *_purecall_handler)(void); 
__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler();
extern "C++"
{
}
typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t); 
__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
extern "C++"
{
}
__declspec(dllimport) extern int * __cdecl _errno(void);
errno_t __cdecl _set_errno([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value);
errno_t __cdecl _get_errno([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _Value);
__declspec(dllimport) unsigned long * __cdecl __doserrno(void);
errno_t __cdecl _set_doserrno([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Value);
errno_t __cdecl _get_doserrno([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] unsigned long * _Value);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char ** __cdecl __sys_errlist(void);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int * __cdecl __sys_nerr(void);
__declspec(dllimport) int *          __cdecl __p___argc(void);
__declspec(dllimport) char ***       __cdecl __p___argv(void);
__declspec(dllimport) wchar_t ***    __cdecl __p___wargv(void);
__declspec(dllimport) char ***       __cdecl __p__environ(void);
__declspec(dllimport) wchar_t ***    __cdecl __p__wenviron(void);
__declspec(dllimport) char **        __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t **     __cdecl __p__wpgmptr(void);
__declspec(dllimport) extern int __argc;          
__declspec(dllimport) extern char ** __argv;      
__declspec(dllimport) extern wchar_t ** __wargv;  
__declspec(dllimport) extern char ** _environ;    
__declspec(dllimport) extern wchar_t ** _wenviron;    
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern char * _pgmptr;      
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern wchar_t * _wpgmptr;  
errno_t __cdecl _get_pgmptr([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Pre(Deref=2,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _Value);
errno_t __cdecl _get_wpgmptr([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Pre(Deref=2,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _Value);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern int _fmode;          
__declspec(dllimport) errno_t __cdecl _set_fmode([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PMode);
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
}
__declspec(dllimport) __declspec(noreturn) void __cdecl exit([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Code);
__declspec(dllimport) void __cdecl abort(void);
__declspec(dllimport) unsigned int __cdecl _set_abort_behavior([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Flags, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Mask);
        int     __cdecl abs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _X);
long    __cdecl labs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _X);
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double  __cdecl atof([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_String);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double  __cdecl _atof_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_String, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport)  int    __cdecl atoi([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _atoi_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long   __cdecl atol([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long   __cdecl _atol_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) void * __cdecl bsearch_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const void * _Key, [SA_Pre(Null=SA_No,ValidBytes="\n@""_NumOfElements * _SizeOfElements")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Base, 
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _NumOfElements, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeOfElements,
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) void * __cdecl bsearch([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const void * _Key, [SA_Pre(Null=SA_No,ValidBytes="\n@""_NumOfElements * _SizeOfElements")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Base, 
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NumOfElements, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeOfElements,
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int (__cdecl * _PtFuncCompare)(const void *, const void *));
__declspec(dllimport) void __cdecl qsort_s([SA_Pre(Null=SA_No,WritableBytes="\n@""_NumOfElements* _SizeOfElements")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Base, 
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _NumOfElements, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeOfElements,
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
__declspec(dllimport) void __cdecl qsort([SA_Pre(Null=SA_No,WritableBytes="\n@""_NumOfElements * _SizeOfElements")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Base, 
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NumOfElements, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeOfElements, 
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int (__cdecl * _PtFuncCompare)(const void *, const void *));
        [returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned short __cdecl _byteswap_ushort([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned short _Short);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned long  __cdecl _byteswap_ulong ([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Long);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned __int64 __cdecl _byteswap_uint64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Int64);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) div_t  __cdecl div([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Numerator, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Denominator);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl getenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _VarName);
 __declspec(dllimport) errno_t __cdecl getenv_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _ReturnSize, [SA_Pre(Null=SA_No,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _DstSize, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _ReturnSize, char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _VarName) { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }
 __declspec(dllimport) errno_t __cdecl _dupenv_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe,NullTerminated=SA_Yes,WritableElements="*_PBufferSizeInBytes")] [SA_Post(Deref=2,Valid=SA_Yes)] char **_PBuffer, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PBufferSizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _VarName);
 __declspec(dllimport) errno_t __cdecl _itoa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value, [SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value, char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix) { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _itoa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) errno_t __cdecl _i64toa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __int64 _Val, [SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _i64toa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __int64 _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) errno_t __cdecl _ui64toa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Val, [SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ui64toa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64 __cdecl _atoi64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _String);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64 __cdecl _atoi64_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _String, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64 __cdecl _strtoi64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _String, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64 __cdecl _strtoi64_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _String, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned __int64 __cdecl _strtoui64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _String, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _String, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int  _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) ldiv_t __cdecl ldiv([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Numerator, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Denominator);
extern "C++"
{
inline ldiv_t  div([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _A1, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _A2)
{
return ldiv(_A1, _A2);
}
}
 __declspec(dllimport) errno_t __cdecl _ltoa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Val, [SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Value, char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix) { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ltoa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Value, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl mblen([SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _mblen_l([SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl _mbstrlen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl _mbstrlen_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl _mbstrnlen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl _mbstrnlen_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) int    __cdecl mbtowc([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstCh, [SA_Pre(Null=SA_Maybe,ValidBytes="_SrcSizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _SrcCh, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SrcSizeInBytes);
__declspec(dllimport) int    __cdecl _mbtowc_l([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstCh, [SA_Pre(Null=SA_Maybe,ValidBytes="_SrcSizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _SrcCh, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SrcSizeInBytes, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) errno_t __cdecl mbstowcs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="*_PtNumOfCharConverted")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,ValidElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _SrcBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount) { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs([SA_Pre(Null=SA_Maybe,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
 __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="*_PtNumOfCharConverted")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,ValidElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _SrcBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale) { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl rand(void);
 __declspec(dllimport) int    __cdecl _set_error_mode([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode);
__declspec(dllimport) void   __cdecl srand([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Seed);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl strtod([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _strtod_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long   __cdecl strtol([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix );
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long   __cdecl _strtol_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *_Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char **_EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned long __cdecl strtoul([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char **_EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) int __cdecl system([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Command);
 __declspec(dllimport) errno_t __cdecl _ultoa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Val, [SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Value, char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix) { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ultoa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Value, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl wctomb([SA_Pre(Null=SA_Maybe,WritableBytesConst=5)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _MbCh, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _WCh);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl _wctomb_l([SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _MbCh, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _WCh, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl wctomb_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _SizeConverted, [SA_Pre(Null=SA_Maybe,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="*_SizeConverted")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _MbCh, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _WCh);
 __declspec(dllimport) errno_t __cdecl _wctomb_s_l([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _SizeConverted, [SA_Pre(Null=SA_Maybe,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _MbCh, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _WCh, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) errno_t __cdecl wcstombs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Pre(Null=SA_Maybe,WritableBytes="_DstSizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="*_PtNumOfCharConverted")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount) { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs([SA_Pre(Null=SA_Maybe,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(dllimport) errno_t __cdecl _wcstombs_s_l([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Pre(Null=SA_Maybe,WritableBytes="_DstSizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="*_PtNumOfCharConverted")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCountInBytes, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _PtNumOfCharConverted, [SA_Pre(Null=SA_Maybe,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale) { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l([SA_Pre(Null=SA_No,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="\n@""_NumOfElements* _SizeOfElements")] __declspec(dllimport)  __declspec(noalias) __declspec(restrict)    void * __cdecl calloc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NumOfElements, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeOfElements);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl free([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Memory);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_Size")] __declspec(dllimport)  __declspec(noalias) __declspec(restrict)                              void * __cdecl malloc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_NewSize")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                           void * __cdecl realloc([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NewSize);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="\n@""_Count*_Size")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _recalloc([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl _aligned_free([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Memory);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_Size")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_malloc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_Size")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_malloc([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Offset);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_NewSize")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_realloc([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NewSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="\n@""_Count*_Size")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_recalloc([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_NewSize")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_realloc([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NewSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Offset);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="\n@""_Count*_Size")] __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_offset_recalloc([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Offset);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport)                                                  size_t __cdecl _aligned_msize([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Alignment, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Offset);
 __declspec(dllimport) errno_t __cdecl _itow_s ([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value, wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix) { return _itow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _itow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) errno_t __cdecl _ltow_s ([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Val, [SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Value, wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix) { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ltow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Value, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) errno_t __cdecl _ultow_s ([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Val, [SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Value, wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix) { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ultow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Value, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl wcstod([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _wcstod_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long   __cdecl wcstol([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long   __cdecl _wcstol_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t **_EndPtr, int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned long __cdecl wcstoul([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned long __cdecl _wcstoul_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t **_EndPtr, int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _wgetenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _VarName);
__declspec(dllimport) errno_t __cdecl _wgetenv_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _ReturnSize, [SA_Pre(Null=SA_No,WritableElements="_DstSizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _ReturnSize, wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _VarName) { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }
 __declspec(dllimport) errno_t __cdecl _wdupenv_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe,NullTerminated=SA_Yes,WritableElements="*_BufferSizeInWords")] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t **_Buffer, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t *_BufferSizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_VarName);
__declspec(dllimport) int __cdecl _wsystem([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Command);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _wtof([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _wtof_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wtoi([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wtoi_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long __cdecl _wtol([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) long __cdecl _wtol_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _i64tow_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __int64 _Val, [SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _i64tow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __int64 _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) errno_t __cdecl _ui64tow_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Val, [SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _ui64tow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64   __cdecl _wtoi64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64   __cdecl _wtoi64_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64   __cdecl _wcstoi64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __int64   __cdecl _wcstoi64_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str , [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _EndPtr, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) char * __cdecl _fullpath([SA_Pre(Null=SA_Maybe,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _FullPath, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Path, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes);
 __declspec(dllimport) errno_t __cdecl _ecvt_s([SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDights, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Value, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign) { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ecvt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign);
__declspec(dllimport) errno_t __cdecl _fcvt_s([SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Value, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign) { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _fcvt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s([SA_Pre(Null=SA_No,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Value, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits) { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _gcvt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _atodbl([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] _CRT_DOUBLE * _Result, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _atoldbl([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] _LDOUBLE * _Result, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _atoflt([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] _CRT_FLOAT * _Result, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _atodbl_l([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] _CRT_DOUBLE * _Result, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _atoldbl_l([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] _LDOUBLE * _Result, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _atoflt_l([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] _CRT_FLOAT * _Result, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned long __cdecl _lrotl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Shift);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned long __cdecl _lrotr([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Shift);
__declspec(dllimport) errno_t   __cdecl _makepath_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _PathResult, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Drive, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Dir, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename,
[SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size], [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Drive, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Dir, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Ext) { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _makepath([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Path, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Drive, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Dir, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Ext);
        _onexit_t __cdecl _onexit([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _onexit_t _Func);
        
#pragma warning (push)
#pragma warning (disable:6540) 
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _putenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _EnvString);
__declspec(dllimport) errno_t __cdecl _putenv_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Name, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Value);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned int __cdecl _rotl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Shift);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned __int64 __cdecl _rotl64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Shift);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned int __cdecl _rotr([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Shift);
[returnvalue:SA_Post(MustCheck=SA_Yes)] unsigned __int64 __cdecl _rotr64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned __int64 _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Shift);
#pragma warning (pop)
__declspec(dllimport) errno_t __cdecl _searchenv_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _EnvVar, [SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _ResultPath, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _EnvVar, char (&_ResultPath)[_Size]) { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _searchenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _EnvVar, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_ResultPath);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _splitpath([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _FullPath, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Drive, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dir, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Filename, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Ext);
__declspec(dllimport) errno_t  __cdecl _splitpath_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _FullPath, 
[SA_Pre(Null=SA_Maybe,WritableElements="_DriveSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Drive, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DriveSize, 
[SA_Pre(Null=SA_Maybe,WritableElements="_DirSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dir, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DirSize, 
[SA_Pre(Null=SA_Maybe,WritableElements="_FilenameSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _FilenameSize, 
[SA_Pre(Null=SA_Maybe,WritableElements="_ExtSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Ext, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const char *_Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
__declspec(dllimport) void   __cdecl _swab([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Post(ValidElements="_SizeInBytes")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf1, [SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Post(ValidElements="_SizeInBytes")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf2, int _SizeInBytes);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wchar_t * __cdecl _wfullpath([SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _FullPath, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Path, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
 __declspec(dllimport) errno_t __cdecl _wmakepath_s([SA_Pre(Null=SA_No,WritableElements="_SIZE")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _PathResult, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SIZE, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Drive, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Dir, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename,
[SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Ext);        
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size], [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Drive, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Dir, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Ext) { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_ResultPath, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Drive, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Dir, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Ext);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _wputenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _EnvString);
__declspec(dllimport) errno_t __cdecl _wputenv_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Name, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _EnvVar, [SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _ResultPath, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _EnvVar, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_ResultPath);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _wsplitpath([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _FullPath, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Drive, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dir, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Filename, [SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _FullPath, 
[SA_Pre(Null=SA_Maybe,WritableElements="_DriveSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Drive, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DriveSize, 
[SA_Pre(Null=SA_Maybe,WritableElements="_DirSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dir, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DirSize, 
[SA_Pre(Null=SA_Maybe,WritableElements="_FilenameSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _FilenameSize, 
[SA_Pre(Null=SA_Maybe,WritableElements="_ExtSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Ext, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const wchar_t *_Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned _Frequency, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Duration);
#pragma warning(push)
#pragma warning(disable: 4141)  
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl ecvt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl fcvt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtDec, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _PtSign);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl gcvt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _NumOfDigits, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl itoa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))		__declspec(dllimport) char * __cdecl ltoa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putenv" ". See online help for details.")) __declspec(dllimport) int    __cdecl putenv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _EnvString);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_swab" ". See online help for details."))										__declspec(dllimport) void   __cdecl swab([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf1,[SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _SizeInBytes);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))	__declspec(dllimport) char * __cdecl ultoa([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _Val, [SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dstbuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _onexit_t _Func);
}
#pragma pack(pop)
 
namespace std {
using ::size_t; using ::div_t; using ::ldiv_t;
using ::abort; using ::abs; using ::atexit;
using ::atof; using ::atoi; using ::atol;
using ::bsearch; using ::calloc; using ::div;
using ::exit; using ::free; using ::getenv;
using ::labs; using ::ldiv; using ::malloc;
using ::mblen; using ::mbstowcs; using ::mbtowc;
using ::qsort; using ::rand; using ::realloc;
using ::srand; using ::strtod; using ::strtol;
using ::strtoul; using ::system;
using ::wcstombs; using ::wctomb;
}
#pragma once
 
#pragma once
 
#pragma pack(push,8)
extern "C" {
typedef long clock_t;
struct tm {
int tm_sec;     
int tm_min;     
int tm_hour;    
int tm_mday;    
int tm_mon;     
int tm_year;    
int tm_wday;    
int tm_yday;    
int tm_isdst;   
};
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int* __cdecl __daylight(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) long* __cdecl __dstbias(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) long* __cdecl __timezone(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char ** __cdecl __tzname(void);
__declspec(dllimport) errno_t __cdecl _get_daylight([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _Daylight);
__declspec(dllimport) errno_t __cdecl _get_dstbias([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] long * _Daylight_savings_bias);
__declspec(dllimport) errno_t __cdecl _get_timezone([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] long * _Timezone);
__declspec(dllimport) errno_t __cdecl _get_tzname([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t *_ReturnValue, [SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buffer, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Index);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl asctime([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Tm);
 __declspec(dllimport) errno_t __cdecl asctime_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=26)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=26)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Time) { return asctime_s(_Buffer, _Size, _Time); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ctime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _ctime32_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=26)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=26)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time) { return _ctime32_s(_Buffer, _Size, _Time); } }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) clock_t __cdecl clock(void);
__declspec(dllimport) double __cdecl _difftime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __time32_t _Time1, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __time32_t _Time2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) struct tm * __cdecl _gmtime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _gmtime32_s([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] struct tm *_Tm, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) struct tm * __cdecl _localtime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time);
__declspec(dllimport) errno_t __cdecl _localtime32_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct tm *_Tm, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time);
__declspec(dllimport) size_t __cdecl strftime([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _strftime_l([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Max_size, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const char * _Format, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm *_Tm, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _strdate_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=9)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=9)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Buffer)[_Size]) { return _strdate_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strdate([SA_Pre(Null=SA_No,WritableElementsConst=9)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buffer);
 __declspec(dllimport) errno_t __cdecl _strtime_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=9)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf , [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=9)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Buffer)[_Size]) { return _strtime_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strtime([SA_Pre(Null=SA_No,WritableElementsConst=9)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buffer);
__declspec(dllimport) __time32_t __cdecl _time32([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] __time32_t * _Time);
__declspec(dllimport) __time32_t __cdecl _mktime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] struct tm * _Tm);
__declspec(dllimport) __time32_t __cdecl _mkgmtime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] struct tm * _Tm);
__declspec(dllimport) void __cdecl _tzset(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _difftime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __time64_t _Time1, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] __time64_t _Time2);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ctime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _ctime64_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time) { return _ctime64_s(_Buffer, _Size, _Time); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) struct tm * __cdecl _gmtime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _gmtime64_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct tm *_Tm, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t *_Time);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) struct tm * __cdecl _localtime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _localtime64_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct tm *_Tm, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t *_Time);
__declspec(dllimport) __time64_t __cdecl _mktime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] struct tm * _Tm);
__declspec(dllimport) __time64_t __cdecl _mkgmtime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] struct tm * _Tm);
__declspec(dllimport) __time64_t __cdecl _time64([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] __time64_t * _Time);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetLocalTime" " instead. See online help for details.")) unsigned __cdecl _getsystime([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct tm * _Tm);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetLocalTime" " instead. See online help for details.")) unsigned __cdecl _setsystime([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] struct tm * _Tm, unsigned _MilliSec);
 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wasctime([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=26)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=26)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Time) { return _wasctime_s(_Buffer, _Size, _Time); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=26)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t* _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=26)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time32_t * _Time) { return _wctime32_s(_Buffer, _Size, _Time); } }
__declspec(dllimport) size_t __cdecl wcsftime([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format,  [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t *_Format, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm *_Tm, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) errno_t __cdecl _wstrdate_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=9)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=9)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size]) { return _wstrdate_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrdate([SA_Pre(Null=SA_No,WritableElementsConst=9)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Buffer);
__declspec(dllimport) errno_t __cdecl _wstrtime_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=9)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=9)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size]) { return _wstrtime_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrtime([SA_Pre(Null=SA_No,WritableElementsConst=9)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Buffer);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElementsConst=26)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t* _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s([SA_Post(Deref=1,Null=SA_No,ValidElementsConst=26)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const __time64_t * _Time) { return _wctime64_s(_Buffer, _Size, _Time); } }
#pragma once
#pragma warning(push)
#pragma warning(disable:4996)
static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
return _wctime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#pragma warning(pop)
#pragma once
static __inline double __cdecl difftime(time_t _Time1, time_t _Time2)
{
return _difftime64(_Time1,_Time2);
}
__declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) static __inline char * __cdecl ctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
return _ctime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t * _Time)
{
return _ctime64_s(_Buffer, _SizeInBytes, _Time);
}
__declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) static __inline struct tm * __cdecl gmtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
return _gmtime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl gmtime_s(struct tm * _Tm, const time_t * _Time)
{
return _gmtime64_s(_Tm, _Time);
}
__declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) static __inline struct tm * __cdecl localtime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
return _localtime64(_Time);
#pragma warning( pop )
}
static __inline errno_t __cdecl localtime_s(struct tm * _Tm, const time_t * _Time)
{
return _localtime64_s(_Tm, _Time);
}
static __inline time_t __cdecl mktime(struct tm * _Tm)
{
return _mktime64(_Tm);
}
static __inline time_t __cdecl _mkgmtime(struct tm * _Tm)
{
return _mkgmtime64(_Tm);
}
static __inline time_t __cdecl time(time_t * _Time)
{
return _time64(_Time);
}
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern int daylight;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern long timezone;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern char * tzname[2];
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
}
#pragma pack(pop)
 
namespace std {
using ::clock_t; using ::size_t;
using ::time_t; using ::tm;
using ::asctime; using ::clock; using ::ctime;
using ::difftime; using ::gmtime; using ::localtime;
using ::mktime; using ::strftime; using ::time;
}
#pragma once
 
#pragma once
 
extern "C" {
__declspec(dllimport) void *  __cdecl _memccpy( [SA_Pre(Null=SA_Maybe,WritableBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] void * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const void *  __cdecl memchr( [SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf , [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _memicmp([SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf1, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _memicmp_l([SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf1, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] int     __cdecl memcmp([SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf1, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
void *  __cdecl memcpy([SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_Size")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
__declspec(dllimport) errno_t  __cdecl memcpy_s([SA_Pre(Null=SA_Maybe,WritableBytes="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_MaxCount")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _DstSize, [SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
        void *  __cdecl memset([SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_Size")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memccpy" ". See online help for details.")) __declspec(dllimport) void * __cdecl memccpy([SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] void * _Dst, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl memicmp([SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf1, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Buf2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
 __declspec(dllimport) errno_t __cdecl _strset_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_DstSize")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _DstSize, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value) { return _strset_s(_Dest, _Size, _Value); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl _strset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Value);
 __declspec(dllimport) errno_t __cdecl strcpy_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src);
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s([SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source) { return strcpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcpy([SA_Pre(Null=SA_No,WritableElementsLength="_Source")] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source);
 __declspec(dllimport) errno_t __cdecl strcat_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src);
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source) { return strcat_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcat([SA_Pre(Null=SA_No,WritableElementsLength="_Source")] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source);
[returnvalue:SA_Post(MustCheck=SA_Yes)] int     __cdecl strcmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] size_t  __cdecl strlen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t  __cdecl strnlen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] static __inline size_t  __cdecl strnlen_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount)
{
return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
 __declspec(dllimport) errno_t __cdecl memmove_s([SA_Pre(Null=SA_Maybe,WritableBytes="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_MaxCount")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _DstSize, [SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
__declspec(dllimport)  void *  __cdecl memmove([SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_Size")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) char *  __cdecl _strdup([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const char *  __cdecl strchr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _stricmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strcmpi([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _stricmp_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str2, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl strcoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const  char * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strcoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str2, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _stricoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _stricoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str2, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strncoll  ([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strncoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strnicoll ([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strnicoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t  __cdecl strcspn([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char * _Control);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl _strerror([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _ErrMsg);
__declspec(dllimport) errno_t __cdecl _strerror_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _ErrorMessage) { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl strerror([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int);
 __declspec(dllimport) errno_t __cdecl strerror_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ErrorMessage) { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
__declspec(dllimport) errno_t __cdecl _strlwr_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_String)[_Size]) { return _strlwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_String);
__declspec(dllimport) errno_t __cdecl _strlwr_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_String)[_Size], [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale) { return _strlwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_String, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl strncat_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count) { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncat([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count);
#pragma warning(pop)
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl strncmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strnicmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _strnicmp_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl strncpy_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count) { return strncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncpy([SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] char *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count);
__declspec(dllimport) errno_t __cdecl _strnset_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count) { return _strnset_s(_Dest, _Size, _Val, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strnset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const char *  __cdecl strpbrk([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Control);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const char *  __cdecl strrchr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch);
__declspec(dllimport) char *  __cdecl _strrev([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t  __cdecl strspn([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Control);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const char *  __cdecl strstr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _SubStr);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl strtok([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Delim);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) char *  __cdecl strtok_s([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Delim, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char ** _Context);
 __declspec(dllimport) errno_t __cdecl _strupr_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_String)[_Size]) { return _strupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_String);
__declspec(dllimport) errno_t __cdecl _strupr_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] char (&_String)[_Size], _locale_t _Locale) { return _strupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_String, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) size_t  __cdecl strxfrm ([SA_Pre(Null=SA_Maybe,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] char * _Dst, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(dllimport) size_t  __cdecl _strxfrm_l([SA_Pre(Null=SA_Maybe,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] char * _Dst, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" {
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline char * __cdecl strchr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch)
{ return (char*)strchr((const char*)_Str, _Ch); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline char * __cdecl strpbrk([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Control)
{ return (char*)strpbrk((const char*)_Str, _Control); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline char * __cdecl strrchr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Ch)
{ return (char*)strrchr((const char*)_Str, _Ch); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline char * __cdecl strstr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _SubStr)
{ return (char*)strstr((const char*)_Str, _SubStr); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline void * __cdecl memchr([SA_Pre(Null=SA_Maybe,ValidBytes="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Pv, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{ return (void*)memchr((const void*)_Pv, _C, _N); }
}
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strdup" ". See online help for details.")) __declspec(dllimport) char * __cdecl strdup([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strcmpi" ". See online help for details.")) __declspec(dllimport) int __cdecl strcmpi([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_stricmp" ". See online help for details.")) __declspec(dllimport) int __cdecl stricmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strlwr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strlwr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl strnicmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnset" ". See online help for details.")) __declspec(dllimport) char * __cdecl strnset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strrev" ". See online help for details.")) __declspec(dllimport) char * __cdecl strrev([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strset" ". See online help for details."))         char * __cdecl strset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strupr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strupr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wchar_t * __cdecl _wcsdup([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl wcscat_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source) { return wcscat_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscat([SA_Pre(Null=SA_No,WritableElementsLength="_Source")] [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const wchar_t * __cdecl wcschr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, wchar_t _Ch);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl wcscmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2);
 __declspec(dllimport) errno_t __cdecl wcscpy_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source) { return wcscpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscpy([SA_Pre(Null=SA_No,WritableElementsLength="_Source")] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl wcscspn([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Control);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl wcslen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl wcsnlen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] static __inline size_t __cdecl wcsnlen_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount)
{
return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}
 __declspec(dllimport) errno_t __cdecl wcsncat_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count) { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncat([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count);
#pragma warning(pop)
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl wcsncmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
 __declspec(dllimport) errno_t __cdecl wcsncpy_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count) { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncpy([SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] wchar_t *_Dest, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Source, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const wchar_t * __cdecl wcspbrk([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Control);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const wchar_t * __cdecl wcsrchr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t __cdecl wcsspn([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Control);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) const wchar_t * __cdecl wcsstr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _SubStr);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcstok([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Delim);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wchar_t * __cdecl wcstok_s([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Delim, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t ** _Context);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcserror([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ErrNum);
__declspec(dllimport) errno_t __cdecl _wcserror_s([SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Error) { return _wcserror_s(_Buffer, _Size, _Error); } }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl __wcserror([SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str);
__declspec(dllimport) errno_t __cdecl __wcserror_s([SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buffer, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ErrorMessage) { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsicmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsicmp_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsnicmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsnicmp_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) errno_t __cdecl _wcsnset_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Dst)[_Size], wchar_t _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount) { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsnset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Str, wchar_t _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str);
__declspec(dllimport) errno_t __cdecl _wcsset_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Str)[_Size], wchar_t _Val) { return _wcsset_s(_Str, _Size, _Val); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Str, wchar_t _Val);
 __declspec(dllimport) errno_t __cdecl _wcslwr_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_String)[_Size]) { return _wcslwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_String);
__declspec(dllimport) errno_t __cdecl _wcslwr_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_String)[_Size], [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale) { return _wcslwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_String, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) errno_t __cdecl _wcsupr_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_String)[_Size]) { return _wcsupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_String);
__declspec(dllimport) errno_t __cdecl _wcsupr_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l([SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_String)[_Size], [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale) { return _wcsupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_String, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(dllimport) size_t __cdecl wcsxfrm([SA_Pre(Null=SA_Maybe,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] wchar_t * _Dst, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(dllimport) size_t __cdecl _wcsxfrm_l([SA_Pre(Null=SA_Maybe,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Maybe)] wchar_t * _Dst, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl wcscoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcscoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsicoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsicoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Str2, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsncoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsncoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsnicoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wcsnicoll_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
extern "C++" {
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline wchar_t * __cdecl wcschr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_Str, wchar_t _Ch)
{return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline wchar_t * __cdecl wcspbrk([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_Control)
{return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline wchar_t * __cdecl wcsrchr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch)
{return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
[returnvalue:SA_Post(MustCheck=SA_Yes)] inline wchar_t * __cdecl wcsstr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_Str, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_SubStr)
{return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsdup" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsdup([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsnset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Val, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsrev" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsrev([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsset([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str, wchar_t _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcslwr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcslwr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsupr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsupr([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Str);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicoll" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str1, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Str2);
}
 
namespace std {
using ::size_t; using ::memchr; using ::memcmp;
using ::memcpy; using ::memmove; using ::memset;
using ::strcat; using ::strchr; using ::strcmp;
using ::strcoll; using ::strcpy; using ::strcspn;
using ::strerror; using ::strlen; using ::strncat;
using ::strncmp; using ::strncpy; using ::strpbrk;
using ::strrchr; using ::strspn; using ::strstr;
using ::strtok; using ::strxfrm;
}
 
#pragma once
 
#pragma once
 
namespace std {
using ::va_list;
}
#pragma once
 
 
#pragma pack(push,8)
extern "C" {
struct _exception {
int type;       
char *name;     
double arg1;    
double arg2;    
double retval;  
} ;
struct _complex {
double x,y; 
} ;
__declspec(dllimport) extern double _HUGE;
        double  __cdecl acos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl asin([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl atan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl atan2([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _copysign ([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Number, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Sign);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _chgsign ([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
        double  __cdecl cos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl cosh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl exp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl fabs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl fmod([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
double  __cdecl log([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl log10([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl pow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
double  __cdecl sin([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl sinh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl tan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl tanh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
double  __cdecl sqrt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(dllimport) double  __cdecl _cabs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] struct _complex _Complex_value);
__declspec(dllimport) double  __cdecl ceil([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(dllimport) double  __cdecl floor([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(dllimport) double  __cdecl frexp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _Y);
__declspec(dllimport) double  __cdecl _hypot([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
__declspec(dllimport) double  __cdecl _j0([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X );
__declspec(dllimport) double  __cdecl _j1([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X );
__declspec(dllimport) double  __cdecl _jn(int _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
__declspec(dllimport) double  __cdecl ldexp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y);
        int     __cdecl _matherr([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] struct _exception * _Except);
__declspec(dllimport) double  __cdecl modf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] double * _Y);
__declspec(dllimport) double  __cdecl _y0([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(dllimport) double  __cdecl _y1([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(dllimport) double  __cdecl _yn([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
__declspec(dllimport) int     __cdecl _set_SSE2_enable([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Flag);
__declspec(dllimport) float  __cdecl _hypotf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y);
inline long double acosl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (acos((double)_X)); }
inline long double asinl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (asin((double)_X)); }
inline long double atanl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (atan((double)_X)); }
inline long double atan2l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Y, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (atan2((double)_Y, (double)_X)); }
inline long double ceill([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (ceil((double)_X)); }
inline long double cosl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (cos((double)_X)); }
inline long double coshl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (cosh((double)_X)); }
inline long double expl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (exp((double)_X)); }
inline long double fabsl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (fabs((double)_X)); }
inline long double floorl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (floor((double)_X)); }
inline long double fmodl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Y)
{return (fmod((double)_X, (double)_Y)); }
inline long double frexpl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int *_Y)
{return (frexp((double)_X, _Y)); }
inline long double ldexpl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return (ldexp((double)_X, _Y)); }
inline long double logl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (log((double)_X)); }
inline long double log10l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (log10((double)_X)); }
inline long double modfl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] long double *_Y)
{double _Di, _Df = modf((double)_X, &_Di);
*_Y = (long double)_Di;
return (_Df); }
inline long double powl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Y)
{return (pow((double)_X, (double)_Y)); }
inline long double sinl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (sin((double)_X)); }
inline long double sinhl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (sinh((double)_X)); }
inline long double sqrtl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (sqrt((double)_X)); }
inline long double tanl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (tan((double)_X)); }
inline long double tanhl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (tanh((double)_X)); }
inline long double _chgsignl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Number)
{
return _chgsign(static_cast<double>(_Number)); 
}
inline long double _copysignl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Number, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Sign)
{
return _copysign(static_cast<double>(_Number), static_cast<double>(_Sign)); 
}
inline float frexpf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int *_Y)
{return ((float)frexp((double)_X, _Y)); }
inline float fabsf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)fabs((double)_X)); }
inline float ldexpf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return ((float)ldexp((double)_X, _Y)); }
inline float acosf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)acos((double)_X)); }
inline float asinf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)asin((double)_X)); }
inline float atanf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)atan((double)_X)); }
inline float atan2f([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)atan2((double)_Y, (double)_X)); }
inline float ceilf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)ceil((double)_X)); }
inline float cosf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)cos((double)_X)); }
inline float coshf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)cosh((double)_X)); }
inline float expf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)exp((double)_X)); }
inline float floorf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)floor((double)_X)); }
inline float fmodf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y)
{return ((float)fmod((double)_X, (double)_Y)); }
inline float logf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)log((double)_X)); }
inline float log10f([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)log10((double)_X)); }
inline float modff([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] float *_Y)
{ double _Di, _Df = modf((double)_X, &_Di);
*_Y = (float)_Di;
return ((float)_Df); }
inline float powf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y)
{return ((float)pow((double)_X, (double)_Y)); }
inline float sinf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)sin((double)_X)); }
inline float sinhf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)sinh((double)_X)); }
inline float sqrtf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)sqrt((double)_X)); }
inline float tanf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)tan((double)_X)); }
inline float tanhf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return ((float)tanh((double)_X)); }
__declspec(dllimport) extern double HUGE;
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_cabs" ". See online help for details.")) __declspec(dllimport) double  __cdecl cabs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] struct _complex _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_hypot" ". See online help for details.")) __declspec(dllimport) double  __cdecl hypot([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j0" ". See online help for details.")) __declspec(dllimport) double  __cdecl j0([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j1" ". See online help for details.")) __declspec(dllimport) double  __cdecl j1([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_jn" ". See online help for details.")) __declspec(dllimport) double  __cdecl jn([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y0" ". See online help for details.")) __declspec(dllimport) double  __cdecl y0([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y1" ". See online help for details.")) __declspec(dllimport) double  __cdecl y1([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_yn" ". See online help for details.")) __declspec(dllimport) double  __cdecl yn([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
}
extern "C++" {
template<class _Ty> inline
_Ty _Pow_int(_Ty _X, int _Y)
{unsigned int _N;
if (_Y >= 0)
_N = (unsigned int)_Y;
else
_N = (unsigned int)(-_Y);
for (_Ty _Z = _Ty(1); ; _X *= _X)
{if ((_N & 1) != 0)
_Z *= _X;
if ((_N >>= 1) == 0)
return (_Y < 0 ? _Ty(1) / _Z : _Z); }}
inline long __cdecl abs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _X)
{return (labs(_X)); }
inline double __cdecl abs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X)
{return (fabs(_X)); }
inline double __cdecl pow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return (_Pow_int(_X, _Y)); }
inline float __cdecl abs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (fabsf(_X)); }
inline float __cdecl acos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (acosf(_X)); }
inline float __cdecl asin([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (asinf(_X)); }
inline float __cdecl atan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (atanf(_X)); }
inline float __cdecl atan2([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (atan2f(_Y, _X)); }
inline float __cdecl ceil([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (ceilf(_X)); }
inline float __cdecl cos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (cosf(_X)); }
inline float __cdecl cosh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (coshf(_X)); }
inline float __cdecl exp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (expf(_X)); }
inline float __cdecl fabs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (fabsf(_X)); }
inline float __cdecl floor([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (floorf(_X)); }
inline float __cdecl fmod([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y)
{return (fmodf(_X, _Y)); }
inline float __cdecl frexp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _Y)
{return (frexpf(_X, _Y)); }
inline float __cdecl ldexp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return (ldexpf(_X, _Y)); }
inline float __cdecl log([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (logf(_X)); }
inline float __cdecl log10([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (log10f(_X)); }
inline float __cdecl modf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] float * _Y)
{return (modff(_X, _Y)); }
inline float __cdecl pow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _Y)
{return (powf(_X, _Y)); }
inline float __cdecl pow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return (_Pow_int(_X, _Y)); }
inline float __cdecl sin([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (sinf(_X)); }
inline float __cdecl sinh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (sinhf(_X)); }
inline float __cdecl sqrt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (sqrtf(_X)); }
inline float __cdecl tan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (tanf(_X)); }
inline float __cdecl tanh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] float _X)
{return (tanhf(_X)); }
inline long double __cdecl abs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (fabsl(_X)); }
inline long double __cdecl acos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (acosl(_X)); }
inline long double __cdecl asin([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (asinl(_X)); }
inline long double __cdecl atan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (atanl(_X)); }
inline long double __cdecl atan2([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Y, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (atan2l(_Y, _X)); }
inline long double __cdecl ceil([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (ceill(_X)); }
inline long double __cdecl cos([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (cosl(_X)); }
inline long double __cdecl cosh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (coshl(_X)); }
inline long double __cdecl exp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (expl(_X)); }
inline long double __cdecl fabs([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (fabsl(_X)); }
inline long double __cdecl floor([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (floorl(_X)); }
inline long double __cdecl fmod([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Y)
{return (fmodl(_X, _Y)); }
inline long double __cdecl frexp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _Y)
{return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return (ldexpl(_X, _Y)); }
inline long double __cdecl log([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (logl(_X)); }
inline long double __cdecl log10([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (log10l(_X)); }
inline long double __cdecl modf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] long double * _Y)
{return (modfl(_X, _Y)); }
inline long double __cdecl pow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _Y)
{return (powl(_X, _Y)); }
inline long double __cdecl pow([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Y)
{return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (sinl(_X)); }
inline long double __cdecl sinh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (sinhl(_X)); }
inline long double __cdecl sqrt([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (sqrtl(_X)); }
inline long double __cdecl tan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (tanl(_X)); }
inline long double __cdecl tanh([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long double _X)
{return (tanhl(_X)); }
}
#pragma pack(pop)
 
namespace std {
using ::acosf; using ::asinf;
using ::atanf; using ::atan2f; using ::ceilf;
using ::cosf; using ::coshf; using ::expf;
using ::fabsf; using ::floorf; using ::fmodf;
using ::frexpf; using ::ldexpf; using ::logf;
using ::log10f; using ::modff; using ::powf;
using ::sinf; using ::sinhf; using ::sqrtf;
using ::tanf; using ::tanhf;
using ::acosl; using ::asinl;
using ::atanl; using ::atan2l; using ::ceill;
using ::cosl; using ::coshl; using ::expl;
using ::fabsl; using ::floorl; using ::fmodl;
using ::frexpl; using ::ldexpl; using ::logl;
using ::log10l; using ::modfl; using ::powl;
using ::sinl; using ::sinhl; using ::sqrtl;
using ::tanl; using ::tanhl;
using ::abs;
using ::acos; using ::asin;
using ::atan; using ::atan2; using ::ceil;
using ::cos; using ::cosh; using ::exp;
using ::fabs; using ::floor; using ::fmod;
using ::frexp; using ::ldexp; using ::log;
using ::log10; using ::modf; using ::pow;
using ::sin; using ::sinh; using ::sqrt;
using ::tan; using ::tanh;
}
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
 #pragma warning(disable: 4514)
#pragma once
#pragma once
#pragma once
 
#pragma once
 
#pragma pack(push,8)
extern "C" {
typedef unsigned long _fsize_t; 
struct _wfinddata32_t {
unsigned    attrib;
__time32_t  time_create;    
__time32_t  time_access;    
__time32_t  time_write;
_fsize_t    size;
wchar_t     name[260];
};
struct _wfinddata32i64_t {
unsigned    attrib;
__time32_t  time_create;    
__time32_t  time_access;    
__time32_t  time_write;
__int64     size;
wchar_t     name[260];
};
struct _wfinddata64i32_t {
unsigned    attrib;
__time64_t  time_create;    
__time64_t  time_access;    
__time64_t  time_write;
_fsize_t    size;
wchar_t     name[260];
};
struct _wfinddata64_t {
unsigned    attrib;
__time64_t  time_create;    
__time64_t  time_access;    
__time64_t  time_write;
__int64     size;
wchar_t     name[260];
};
__declspec(dllimport) const unsigned short * __cdecl __pctype_func(void);
__declspec(dllimport) extern const unsigned short *_pctype;
__declspec(dllimport) extern const unsigned short _wctype[];
__declspec(dllimport) const wctype_t * __cdecl __pwctype_func(void);
__declspec(dllimport) extern const wctype_t *_pwctype;
                                
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswalpha([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswalpha_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswupper([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswupper_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswlower([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswlower_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswdigit([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswdigit_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswxdigit([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswxdigit_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswspace([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswspace_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswpunct([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswpunct_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswalnum([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswalnum_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswprint([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswprint_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswgraph([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswgraph_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswcntrl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswcntrl_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswascii([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl isleadbyte([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isleadbyte_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl towupper([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl _towupper_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl towlower([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl _towlower_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale); 
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iswctype([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wctype_t _Type);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswctype_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wctype_t _Type, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl __iswcsymf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswcsymf_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl __iswcsym([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iswcsym_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wctype_t _Type);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,NullTerminated=SA_Yes)] [returnvalue:SA_Post(Deref=1,Valid=SA_Yes)] __declspec(dllimport) wchar_t * __cdecl _wgetcwd([SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _SizeInWords);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,NullTerminated=SA_Yes)] [returnvalue:SA_Post(Deref=1,Valid=SA_Yes)] __declspec(dllimport) wchar_t * __cdecl _wgetdcwd([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Drive, [SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _SizeInWords);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,NullTerminated=SA_Yes)] [returnvalue:SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * __cdecl _wgetdcwd_nolock([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Drive, [SA_Pre(Null=SA_Maybe,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t * _DstBuf, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _SizeInWords);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wchdir([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Path);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wmkdir([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Path);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wrmdir([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Path);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _waccess([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _AccessMode);
__declspec(dllimport) errno_t __cdecl _waccess_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _AccessMode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wchmod([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wcreat([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _PermissionMode);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) intptr_t __cdecl _wfindfirst32([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata32_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wfindnext32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] intptr_t _FindHandle, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata32_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wunlink([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wrename([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _OldFilename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _NewFilename);
__declspec(dllimport) errno_t __cdecl _wmktemp_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _TemplateName, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) { return _wmktemp_s(_TemplateName, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wmktemp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_TemplateName);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata32i64_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata64i32_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) intptr_t __cdecl _wfindfirst64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata64_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wfindnext32i64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] intptr_t _FindHandle, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata32i64_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wfindnext64i32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] intptr_t _FindHandle, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata64i32_t * _FindData);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _wfindnext64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] intptr_t _FindHandle, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _wfinddata64_t * _FindData);
 __declspec(dllimport) errno_t __cdecl _wsopen_s([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] int * _FileHandle, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _OpenFlag, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ShareFlag, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _PermissionFlag);
extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _OpenFlag, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _PermissionMode = 0);
extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wsopen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _OpenFlag, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _ShareFlag, int _PermissionMode = 0);
 __declspec(dllimport) wchar_t * __cdecl _wsetlocale([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Category, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Locale);
__declspec(dllimport) intptr_t __cdecl _wexecl([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecle([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclpe([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecv([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecve([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList,
[SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wexecvp([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecvpe([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList, 
[SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnle([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlpe([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnv([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnve([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList,
[SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnvp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnvpe([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Mode, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Filename, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _ArgList,
[SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * const * _Env);
typedef unsigned short _ino_t;      
typedef unsigned short ino_t;
typedef unsigned int _dev_t;        
typedef unsigned int dev_t;
typedef long _off_t;                
typedef long off_t;
struct _stat32 {
_dev_t     st_dev;
_ino_t     st_ino;
unsigned short st_mode;
short      st_nlink;
short      st_uid;
short      st_gid;
_dev_t     st_rdev;
_off_t     st_size;
__time32_t st_atime;
__time32_t st_mtime;
__time32_t st_ctime;
};
struct stat {
_dev_t     st_dev;
_ino_t     st_ino;
unsigned short st_mode;
short      st_nlink;
short      st_uid;
short      st_gid;
_dev_t     st_rdev;
_off_t     st_size;
time_t st_atime;
time_t st_mtime;
time_t st_ctime;
};
struct _stat32i64 {
_dev_t     st_dev;
_ino_t     st_ino;
unsigned short st_mode;
short      st_nlink;
short      st_uid;
short      st_gid;
_dev_t     st_rdev;
__int64    st_size;
__time32_t st_atime;
__time32_t st_mtime;
__time32_t st_ctime;
};
struct _stat64i32 {
_dev_t     st_dev;
_ino_t     st_ino;
unsigned short st_mode;
short      st_nlink;
short      st_uid;
short      st_gid;
_dev_t     st_rdev;
_off_t     st_size;
__time64_t st_atime;
__time64_t st_mtime;
__time64_t st_ctime;
};
struct _stat64 {
_dev_t     st_dev;
_ino_t     st_ino;
unsigned short st_mode;
short      st_nlink;
short      st_uid;
short      st_gid;
_dev_t     st_rdev;
__int64    st_size;
__time64_t st_atime;
__time64_t st_mtime;
__time64_t st_ctime;
};
__declspec(dllimport) int __cdecl _wstat32([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat32 * _Stat);
__declspec(dllimport) int __cdecl _wstat32i64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _wstat64i32([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _wstat64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat64 * _Stat);
 __declspec(dllimport) errno_t __cdecl _cgetws_s([SA_Pre(Null=SA_No,WritableElements="_SizeInWords")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="*_SizeRead")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Buffer, size_t _SizeInWords, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _SizeRead);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s([SA_Post(Deref=1,Null=SA_No,ValidElements="*_Buffer")] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Buffer)[_Size], size_t * _Size) { return _cgetws_s(_Buffer, _Size, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cgetws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _cgetws([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Buffer);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl _getwch(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl _getwche(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl _putwch(wchar_t _WCh);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _WCh);
__declspec(dllimport) int __cdecl _cputws([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t * _String);
__declspec(dllimport) int __cdecl _cwprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _cwprintf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, ...);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _cwscanf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _cwscanf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="scanf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t *_Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _vcwprintf_s([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t *_Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _cwprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, ...);
__declspec(dllimport) int __cdecl _vcwprintf_p([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t*  _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _cwprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _cwprintf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t *_Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vcwprintf_s_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _cwprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_p_l([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_FormatString(Style="printf")] const wchar_t * _Format, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale, va_list _ArgList);
 wint_t __cdecl _putwch_nolock(wchar_t _WCh);
[returnvalue:SA_Post(MustCheck=SA_Yes)] wint_t __cdecl _getwch_nolock(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] wint_t __cdecl _getwche_nolock(void);
wint_t __cdecl _ungetwch_nolock(wint_t _WCh);
typedef int mbstate_t;
typedef wchar_t _Wint_t;
__declspec(dllimport) wint_t __cdecl btowc(int);
__declspec(dllimport) size_t __cdecl mbrlen([SA_Pre(Null=SA_Maybe,ValidBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _Ch, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes,
[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
__declspec(dllimport) size_t __cdecl mbrtowc([SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _DstCh, [SA_Pre(Null=SA_Maybe,ValidBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] const char * _SrcCh,
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t* _Retval, [SA_Pre(Null=SA_Maybe,WritableElements="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_Maybe)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] const char ** _PSrc, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _Retval, [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] wchar_t (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_Maybe)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] const char ** _PSource, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State) { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_Maybe)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] const char ** _PSrc, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl wcrtomb_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _Retval, [SA_Pre(Null=SA_Maybe,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst,
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Ch, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _Retval, [SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Source, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State) { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb([SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _Source, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl wcsrtombs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _Retval, [SA_Pre(Null=SA_Maybe,WritableBytes="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="*_Retval")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst,
[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] const wchar_t ** _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _Retval, [SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char (&_Dest)[_Size], [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] const wchar_t ** _PSrc, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State) { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs([SA_Pre(Null=SA_Maybe)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=2,Valid=SA_Yes)] [SA_Post(Deref=1,Null=SA_No,NullTerminated=SA_Yes)] [SA_Post(Deref=2,Valid=SA_Yes)] const wchar_t ** _PSource, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Count, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] mbstate_t * _State);
__declspec(dllimport) int __cdecl wctob([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wint_t _WCh);
__declspec(dllimport)  void *  __cdecl memmove([SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_Size")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
 void *  __cdecl memcpy([SA_Pre(Null=SA_Maybe,WritableBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_Size")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_Maybe,ValidBytes="_Size")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
__declspec(dllimport) errno_t __cdecl memcpy_s([SA_Pre(Null=SA_Maybe,WritableBytes="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_MaxCount")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _DstSize, [SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
__declspec(dllimport) errno_t __cdecl memmove_s([SA_Pre(Null=SA_Maybe,WritableBytes="_DstSize")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidBytes="_MaxCount")] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _DstSize, [SA_Pre(Null=SA_Maybe,ValidBytes="_MaxCount")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const void * _Src, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _MaxCount);
__inline int __cdecl fwide([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] FILE * _F, int _M)
{(void)_F; return (_M); }
__inline int __cdecl mbsinit([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const mbstate_t *_P)
{return (_P == 0 || *_P == 0); }
__inline const wchar_t * __cdecl wmemchr([SA_Pre(Null=SA_No,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{for (; 0 < _N; ++_S, --_N)
if (*_S == _C)
return (const wchar_t *)(_S);
return (0); }
__inline int __cdecl wmemcmp([SA_Pre(Null=SA_No,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S1, [SA_Pre(Null=SA_No,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{for (; 0 < _N; ++_S1, ++_S2, --_N)
if (*_S1 != *_S2)
return (*_S1 < *_S2 ? -1 : +1);
return (0); }
__inline  wchar_t * __cdecl wmemcpy([SA_Pre(Null=SA_Maybe,WritableElements="_N")] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t *_S1, [SA_Pre(Null=SA_Maybe,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
}
__inline errno_t __cdecl wmemcpy_s([SA_Pre(Null=SA_Maybe,WritableElements="_N1")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_N")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_S1, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _N1, [SA_Pre(Null=SA_Maybe,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S2, rsize_t _N)
{
#pragma warning( push )
#pragma warning( disable : 6386 )
return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
}
#pragma warning( pop )
__inline  wchar_t * __cdecl wmemmove([SA_Pre(Null=SA_Maybe,WritableElements="_N")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_N")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_S1, [SA_Pre(Null=SA_Maybe,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
}
__inline errno_t __cdecl wmemmove_s([SA_Pre(Null=SA_Maybe,WritableElements="_N1")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_N")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_S1, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _N1, [SA_Pre(Null=SA_Maybe,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const wchar_t *_S2, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] rsize_t _N)
{
#pragma warning( push )
#pragma warning( disable : 6386 )
return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
}
__inline wchar_t * __cdecl wmemset([SA_Pre(Null=SA_No,WritableElements="_N")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_N")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_S, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{
wchar_t *_Su = _S;
for (; 0 < _N; ++_Su, --_N)
{
*_Su = _C;
}
return (_S);
}
extern "C++" {
inline wchar_t * __cdecl wmemchr([SA_Pre(Null=SA_No,ValidElements="_N")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_S, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] wchar_t _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _N)
{ return (wchar_t *)wmemchr((const wchar_t *)_S, _C, _N); }
}
}       
#pragma pack(pop)
typedef mbstate_t _Mbstatet;
typedef mbstate_t _Mbstatet;
 
namespace std {
using ::_Mbstatet;
using ::mbstate_t; using ::size_t;
using ::tm; using ::wint_t;
using ::btowc; using ::fgetwc; using ::fgetws; using ::fputwc;
using ::fputws; using ::fwide; using ::fwprintf;
using ::fwscanf; using ::getwc; using ::getwchar;
using ::mbrlen; using ::mbrtowc; using ::mbsrtowcs;
using ::mbsinit; using ::putwc; using ::putwchar;
using ::swprintf; using ::swscanf; using ::ungetwc;
using ::vfwprintf; using ::vswprintf; using ::vwprintf;
using ::wcrtomb; using ::wprintf; using ::wscanf;
using ::wcsrtombs; using ::wcstol; using ::wcscat;
using ::wcschr; using ::wcscmp; using ::wcscoll;
using ::wcscpy; using ::wcscspn; using ::wcslen;
using ::wcsncat; using ::wcsncmp; using ::wcsncpy;
using ::wcspbrk; using ::wcsrchr; using ::wcsspn;
using ::wcstod; using ::wcstoul; using ::wcsstr;
using ::wcstok; using ::wcsxfrm; using ::wctob;
using ::wmemchr; using ::wmemcmp; using ::wmemcpy;
using ::wmemmove; using ::wmemset; using ::wcsftime;
}
#pragma once
#pragma once
 
#pragma once
 
extern "C" {
__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);
__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);
}
 
namespace std {
using ::ptrdiff_t; using ::size_t;
}
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
 
 
 
 
 
 
 
 
 
		
 
		
 
 
  
 
  
 
		
enum _Uninitialized
{	
_Noinit};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 
#pragma pack(push,8)
extern "C" {
 
typedef void *_HFILE; 
typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);
 
 
typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);
 
 
typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);
struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
struct _CrtMemBlockHeader * pBlockHeader;
size_t lCounts[5];
size_t lSizes[5];
size_t lHighWaterCount;
size_t lTotalCount;
} _CrtMemState;
 
 
}
extern "C++" {
 
 
#pragma warning(suppress: 4985)
[returnvalue:SA_Post(Null=SA_No,WritableBytes="_Size")] void * __cdecl operator new[](size_t _Size);
[returnvalue:SA_Post(Null=SA_No,WritableBytes="_Size")] void * __cdecl operator new(
size_t _Size,
int,
const char *,
int
);
#pragma warning(suppress: 4985)
[returnvalue:SA_Post(Null=SA_No,WritableBytes="_Size")] void * __cdecl operator new[](
size_t _Size,
int,
const char *,
int
);
void __cdecl operator delete[](void *);
inline void __cdecl operator delete(void * _P, int, const char *, int)
{ ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
{ ::operator delete[](_P); }
}
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
typedef long streamoff;
typedef int streamsize;
 
  
extern __declspec(dllimport)  fpos_t _Fpz;
extern __declspec(dllimport)  const streamoff _BADOFF;
		
template<class _Statetype>
class fpos
{	
typedef fpos<_Statetype> _Myt;
public:
fpos(streamoff _Off = 0)
: _Myoff(_Off), _Fpos(0), _Mystate(_Stz)
{	
}
	 fpos(_Statetype _State, fpos_t _Fileposition)
: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
{	
}
	_Statetype  state() const
{	
return (_Mystate);
}
	void  state(_Statetype _State)
{	
_Mystate = _State;
}
	fpos_t  seekpos() const
{	
return (_Fpos);
}
	 operator streamoff() const
{	
return ((streamoff)(_Myoff + ((long)(_Fpos))));
}
	streamoff  operator-(const _Myt& _Right) const
{	
return ((streamoff)*this - (streamoff)_Right);
}
	_Myt&  operator+=(streamoff _Off)
{	
_Myoff += _Off;
return (*this);
}
	_Myt&  operator-=(streamoff _Off)
{	
_Myoff -= _Off;
return (*this);
}
	_Myt  operator+(streamoff _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt  operator-(streamoff _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	bool  operator==(const _Myt& _Right) const
{	
return ((streamoff)*this == (streamoff)_Right);
}
	bool  operator!=(const _Myt& _Right) const
{	
return (!(*this == _Right));
}
private:
static const _Statetype _Stz;	
streamoff _Myoff;	
fpos_t _Fpos;	
_Statetype _Mystate;	
};
	
template<class _Statetype>
const _Statetype fpos<_Statetype>::_Stz = _Statetype();
 
 
typedef fpos<_Mbstatet> streampos;
typedef streampos wstreampos;
		
struct _Unsecure_char_traits_tag
{
};
struct _Secure_char_traits_tag
{
};
		
		
		
struct _Char_traits_base
{
typedef _Unsecure_char_traits_tag _Secure_char_traits;
};
		
		
template<class _Elem>
struct char_traits:
public _Char_traits_base
{	
typedef _Elem char_type;
typedef long int_type;
typedef streampos pos_type;
typedef streamoff off_type;
typedef _Mbstatet state_type;
	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
{	
_Left = _Right;
}
	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
{	
return (_Left == _Right);
}
	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
{	
return (_Left < _Right);
}
	static int __cdecl compare(const _Elem *_First1,
const _Elem *_First2, size_t _Count)
{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
if (!eq(*_First1, *_First2))
return (lt(*_First1, *_First2) ? -1 : +1);
return (0);
}
	static size_t __cdecl length(const _Elem *_First)
{	
		size_t _Count;
for (_Count = 0; !eq(*_First, _Elem()); ++_First)
++_Count;
return (_Count);
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
static _Elem *__cdecl copy(_Elem *_First1,
const _Elem *_First2, size_t _Count)
{	
		return _Copy_s(_First1, _Count, _First2, _Count);
}
	static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Dest_size,
const _Elem *_First2, size_t _Count)
{	
		{ if (!(_Dest_size >= _Count)) { ((void)0); ::_invalid_parameter_noinfo(); return (0); } };
_Elem *_Next = _First1;
for (; 0 < _Count; --_Count, ++_Next, ++_First2)
assign(*_Next, *_First2);
return (_First1);
}
	static const _Elem *__cdecl find(const _Elem *_First,
size_t _Count, const _Elem& _Ch)
{	
		for (; 0 < _Count; --_Count, ++_First)
if (eq(*_First, _Ch))
return (_First);
return (0);
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
static _Elem *__cdecl move(_Elem *_First1,
const _Elem *_First2, size_t _Count)
{	
		return _Move_s(_First1, _Count, _First2, _Count);
}
	static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Dest_size,
const _Elem *_First2, size_t _Count)
{	
		{ if (!(_Dest_size >= _Count)) { ((void)0); ::_invalid_parameter_noinfo(); return (0); } };
_Elem *_Next = _First1;
if (_First2 < _Next && _Next < _First2 + _Count)
for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
assign(*--_Next, *--_First2);
else
for (; 0 < _Count; --_Count, ++_Next, ++_First2)
assign(*_Next, *_First2);
return (_First1);
}
	static _Elem *__cdecl assign(_Elem *_First,
size_t _Count, _Elem _Ch)
{	
		_Elem *_Next = _First;
for (; 0 < _Count; --_Count, ++_Next)
assign(*_Next, _Ch);
return (_First);
}
	static _Elem __cdecl to_char_type(const int_type& _Meta)
{	
return ((_Elem)_Meta);
}
	static int_type __cdecl to_int_type(const _Elem& _Ch)
{	
return ((int_type)_Ch);
}
	static bool __cdecl eq_int_type(const int_type& _Left,
const int_type& _Right)
{	
return (_Left == _Right);
}
	static int_type __cdecl eof()
{	
return ((int_type)(-1));
}
	static int_type __cdecl not_eof(const int_type& _Meta)
{	
return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
}
};
		
template<> struct __declspec(dllimport) char_traits<wchar_t>:
public _Char_traits_base
{	
typedef wchar_t _Elem;
typedef _Elem char_type;	
typedef wint_t int_type;
typedef streampos pos_type;
typedef streamoff off_type;
typedef _Mbstatet state_type;
	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
{	
_Left = _Right;
}
	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
{	
return (_Left == _Right);
}
	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
{	
return (_Left < _Right);
}
	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
size_t _Count)
{	
		return (::wmemcmp(_First1, _First2, _Count));
}
	static size_t __cdecl length(const _Elem *_First)
{	
		return (::wcslen(_First));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
size_t _Count)
{	
		return _Copy_s(_First1, _Count, _First2, _Count);
}
	static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2,
size_t _Count)
{	
		::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
return _First1;
}
	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
const _Elem& _Ch)
{	
		return ((const _Elem *)::wmemchr(_First, _Ch, _Count));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
size_t _Count)
{	
		return _Move_s(_First1, _Count, _First2, _Count);
}
	static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Size_in_words, const _Elem *_First2,
size_t _Count)
{	
		::wmemmove_s((_First1), (_Size_in_words), (_First2), (_Count));
return (_Elem *)_First1;
}
	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
{	
		return ((_Elem *)::wmemset(_First, _Ch, _Count));
}
	static _Elem __cdecl to_char_type(const int_type& _Meta)
{	
return (_Meta);
}
	static int_type __cdecl to_int_type(const _Elem& _Ch)
{	
return (_Ch);
}
	static bool __cdecl eq_int_type(const int_type& _Left,
const int_type& _Right)
{	
return (_Left == _Right);
}
	static int_type __cdecl eof()
{	
return ((wint_t)(0xFFFF));
}
	static int_type __cdecl not_eof(const int_type& _Meta)
{	
return (_Meta != eof() ? _Meta : !eof());
}
};
		
template<> struct __declspec(dllimport) char_traits<char>:
public _Char_traits_base
{	
typedef char _Elem;
typedef _Elem char_type;
typedef int int_type;
typedef streampos pos_type;
typedef streamoff off_type;
typedef _Mbstatet state_type;
	static void __cdecl assign(_Elem& _Left, const _Elem& _Right)
{	
_Left = _Right;
}
	static bool __cdecl eq(const _Elem& _Left, const _Elem& _Right)
{	
return (_Left == _Right);
}
	static bool __cdecl lt(const _Elem& _Left, const _Elem& _Right)
{	
return (_Left < _Right);
}
	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
size_t _Count)
{	
		return (::memcmp(_First1, _First2, _Count));
}
	static size_t __cdecl length(const _Elem *_First)
{	
		return (::strlen(_First));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
size_t _Count)
{	
		return _Copy_s(_First1, _Count, _First2, _Count);
}
	static _Elem *__cdecl _Copy_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2,
size_t _Count)
{	
		::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
return _First1;
}
	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
const _Elem& _Ch)
{	
		return ((const _Elem *)::memchr(_First, _Ch, _Count));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
size_t _Count)
{	
		return _Move_s(_First1, _Count, _First2, _Count);
}
	static _Elem *__cdecl _Move_s(_Elem *_First1, size_t _Size_in_bytes, const _Elem *_First2,
size_t _Count)
{	
		::memmove_s((_First1), (_Size_in_bytes), (_First2), (_Count));
return _First1;
}
	static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem _Ch)
{	
		return ((_Elem *)::memset(_First, _Ch, _Count));
}
	static _Elem __cdecl to_char_type(const int_type& _Meta)
{	
return ((_Elem)_Meta);
}
	static int_type __cdecl to_int_type(const _Elem& _Ch)
{	
return ((unsigned char)_Ch);
}
	static bool __cdecl eq_int_type(const int_type& _Left,
const int_type& _Right)
{	
return (_Left == _Right);
}
	static int_type __cdecl eof()
{	
return ((-1));
}
	static int_type __cdecl not_eof(const int_type& _Meta)
{	
return (_Meta != eof() ? _Meta : !eof());
}
};
		
template <class _Traits>
class _Inherits_from_char_traits_base
{
typedef char _True;
class _False { char _Dummy[2]; };
static _True _Inherits(_Char_traits_base);
static _False _Inherits(...);
static _Traits _Make_traits();
	public:
enum { _Exists = sizeof(_Inherits(_Make_traits())) == sizeof(_True) };
};
	template <class _Traits, bool _Inherits_from_char_traits_base>
class _Char_traits_category_helper
{
public:
typedef _Unsecure_char_traits_tag _Secure_char_traits;
};
	
	template <class _Elem>
class _Char_traits_category_helper< char_traits<_Elem> , true>
{
public:
typedef _Secure_char_traits_tag _Secure_char_traits;
};
	template <class _Traits>
class _Char_traits_category_helper<_Traits, true>
{
public:
typedef typename _Traits::_Secure_char_traits _Secure_char_traits;
};
	template <class _Traits>
class _Char_traits_category
{
public:
typedef typename _Char_traits_category_helper<_Traits, _Inherits_from_char_traits_base<_Traits>::_Exists>::_Secure_char_traits _Secure_char_traits;
};
	
	template<class _Traits> 
inline
typename _Char_traits_category<_Traits>::_Secure_char_traits _Char_traits_cat()
{
typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
return (_Secure);
}
	namespace _Traits_helper
{
		
template<class _Traits>
inline
typename _Traits::char_type *copy_s(typename _Traits::char_type *_First1, size_t _Size,
const typename _Traits::char_type *_First2, size_t _Count)
{
return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
}
	template<class _Traits>
inline
typename _Traits::char_type *copy_s(typename _Traits::char_type *_First1, size_t _Size,
const typename _Traits::char_type *_First2, size_t _Count, _Secure_char_traits_tag)
{
return _Traits::_Copy_s(_First1, _Size, _First2, _Count);
}
	
template<class _Traits>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename _Traits::char_type *copy_s(typename _Traits::char_type *_First1, size_t _Size,
const typename _Traits::char_type *_First2, size_t _Count, _Unsecure_char_traits_tag)
{
return _Traits::copy(_First1, _First2, _Count);
}
		
template<class _Traits>
inline
typename _Traits::char_type *move_s(typename _Traits::char_type *_First1, size_t _Size,
const typename _Traits::char_type *_First2, size_t _Count)
{
return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());
}
	template<class _Traits>
inline
typename _Traits::char_type *move_s(typename _Traits::char_type *_First1, size_t _Size,
const typename _Traits::char_type *_First2, size_t _Count, _Secure_char_traits_tag)
{
return _Traits::_Move_s(_First1, _Size, _First2, _Count);
}
	
template<class _Traits>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename _Traits::char_type *move_s(typename _Traits::char_type *_First1, size_t _Size,
const typename _Traits::char_type *_First2, size_t _Count, _Unsecure_char_traits_tag)
{
return _Traits::move(_First1, _First2, _Count);
}
	} 
		
template<class _Ty>
class allocator;
class ios_base;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_ios;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class istreambuf_iterator;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class ostreambuf_iterator;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_streambuf;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_istream;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_ostream;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_iostream;
template<class _Elem,
class _Traits = char_traits<_Elem>,
class _Alloc = allocator<_Elem> >
class basic_stringbuf;
template<class _Elem,
class _Traits = char_traits<_Elem>,
class _Alloc = allocator<_Elem> >
class basic_istringstream;
template<class _Elem,
class _Traits = char_traits<_Elem>,
class _Alloc = allocator<_Elem> >
class basic_ostringstream;
template<class _Elem,
class _Traits = char_traits<_Elem>,
class _Alloc = allocator<_Elem> >
class basic_stringstream;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_filebuf;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_ifstream;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_ofstream;
template<class _Elem,
class _Traits = char_traits<_Elem> >
class basic_fstream;
 
template<class _Elem,
class _InIt >
class num_get;
template<class _Elem,
class _OutIt >
class num_put;
template<class _Elem>
class collate;
		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;
		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
template<class _Ty> inline
void swap(_Ty& _Left, _Ty& _Right)
{	
if (&_Left != &_Right)
{	
_Ty _Tmp = _Left;
		_Left = _Right;
_Right = _Tmp;
}
}
		
template<class _Ty1,
class _Ty2> struct pair
{	
typedef pair<_Ty1, _Ty2> _Myt;
typedef _Ty1 first_type;
typedef _Ty2 second_type;
	pair()
: first(_Ty1()), second(_Ty2())
{	
}
	pair(const _Ty1& _Val1, const _Ty2& _Val2)
: first(_Val1), second(_Val2)
{	
}
	template<class _Other1,
class _Other2>
pair(const pair<_Other1, _Other2>& _Right)
: first(_Right.first), second(_Right.second)
{	
}
	void swap(_Myt& _Right)
{	
if (this != &_Right)
{	
std::swap(first, _Right.first);
std::swap(second, _Right.second);
}
}
	_Ty1 first;	
_Ty2 second;	
};
		
template<class _Ty1,
class _Ty2> inline
bool operator==(const pair<_Ty1, _Ty2>& _Left,
const pair<_Ty1, _Ty2>& _Right)
{	
return (_Left.first == _Right.first && _Left.second == _Right.second);
}
template<class _Ty1,
class _Ty2> inline
bool operator!=(const pair<_Ty1, _Ty2>& _Left,
const pair<_Ty1, _Ty2>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty1,
class _Ty2> inline
bool operator<(const pair<_Ty1, _Ty2>& _Left,
const pair<_Ty1, _Ty2>& _Right)
{	
return (_Left.first < _Right.first ||
!(_Right.first < _Left.first) && _Left.second < _Right.second);
}
template<class _Ty1,
class _Ty2> inline
bool operator>(const pair<_Ty1, _Ty2>& _Left,
const pair<_Ty1, _Ty2>& _Right)
{	
return (_Right < _Left);
}
template<class _Ty1,
class _Ty2> inline
bool operator<=(const pair<_Ty1, _Ty2>& _Left,
const pair<_Ty1, _Ty2>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty1,
class _Ty2> inline
bool operator>=(const pair<_Ty1, _Ty2>& _Left,
const pair<_Ty1, _Ty2>& _Right)
{	
return (!(_Left < _Right));
}
template<class _Ty1,
class _Ty2> inline
pair<_Ty1, _Ty2> make_pair(_Ty1 _Val1, _Ty2 _Val2)
{	
return (pair<_Ty1, _Ty2>(_Val1, _Val2));
}
template<class _Ty1,
class _Ty2> inline
void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
{	
_Left.swap(_Right);
}
		
namespace rel_ops
{	
template<class _Ty> inline
bool  operator!=(const _Ty& _Left, const _Ty& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty> inline
bool operator>(const _Ty& _Left, const _Ty& _Right)
{	
return (_Right < _Left);
}
template<class _Ty> inline
bool operator<=(const _Ty& _Left, const _Ty& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty> inline
bool operator>=(const _Ty& _Left, const _Ty& _Right)
{	
return (!(_Left < _Right));
}
}
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
struct _Unchecked_iterator_tag
{
};
struct _Range_checked_iterator_tag
{
};
		
struct _Unchanged_checked_iterator_base_type_tag
{
};
struct _Different_checked_iterator_base_type_tag
{
};
		
struct _Undefined_inner_type_tag
{
};
		
struct _Undefined_move_tag
{
};
struct _Swap_move_tag
{
};
class _Iterator_base_universal
{	
public:
typedef _Unchecked_iterator_tag _Checked_iterator_category;
typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
typedef _Undefined_inner_type_tag _Inner_type;
};
		
		
 
class _Container_base_aux;
class _Aux_cont
{
public:
explicit _Aux_cont(const _Container_base_aux * const _Pcont)
: _Mycontainer(_Pcont) { }
	const _Container_base_aux * _Getcont() const
{
return _Mycontainer;
}
	private:
const _Container_base_aux * _Mycontainer;
};
class _Container_base_aux
{	
public:
_Container_base_aux()
{
		}
	_Container_base_aux(const _Container_base_aux&)
{
		}
	_Container_base_aux& operator=(const _Container_base_aux&)
{
		return *this;
}
	void _Swap_aux(_Container_base_aux& _Right)
{
std::swap(_Myownedaux, _Right._Myownedaux);
std::swap(*_Myownedaux, *_Right._Myownedaux);
}
	~_Container_base_aux()
{
		}
	protected:
friend class _Iterator_base_aux;
	_Aux_cont * _Myownedaux;
};
template<class _Alloc>
class _Container_base_aux_alloc_real
: public _Container_base_aux
{ 
protected:
explicit _Container_base_aux_alloc_real(_Alloc _Al)
: _Alaux(_Al)
{
_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);
}
	_Container_base_aux_alloc_real(const _Container_base_aux_alloc_real& _Right)
: _Alaux(_Right._Alaux)
{
_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);
}
	_Container_base_aux_alloc_real& operator=(const _Container_base_aux_alloc_real&)
{
		return *this;
}
	~_Container_base_aux_alloc_real()
{
_Myownedaux->~_Aux_cont();
		_Alaux.deallocate(_Myownedaux, 1);
}
	typename _Alloc::template rebind<_Aux_cont>::other _Alaux; 
};
class _Iterator_base_aux : public _Iterator_base_universal
{	
public:
_Iterator_base_aux()
: _Myaux(0) { }
	void _Set_container(const _Container_base_aux * const _Pcont)
{
_Myaux = _Pcont->_Myownedaux;
}
	const _Container_base_aux * _Getmycont() const
{	
return _Myaux ? _Myaux->_Getcont() : 0;
}
	bool _Same_container(const _Iterator_base_aux& _Other) const
{	
return _Myaux == _Other._Myaux;
}
	bool _Has_container() const
{	
return _Myaux != 0;
}
	private:
const _Aux_cont * _Myaux;
};
		
 
  
class __declspec(dllimport) _Container_base_secure
{	
};
class _Iterator_base_secure : public _Iterator_base_universal
{	
public:
	 _Iterator_base_secure()
: _Mycont(0)
{
}
	const _Container_base_secure *  _Getmycont() const
{	
return _Mycont;
}
	bool  _Same_container(const _Iterator_base_secure& _Other) const
{	
return _Mycont == _Other._Mycont;
}
	bool  _Has_container() const
{	
return _Mycont != 0;
}
	const _Container_base_secure *_Mycont;
};
   
typedef _Container_base_aux _Container_base;
typedef _Iterator_base_aux _Iterator_base;
   
  
template<class _Alloc>
class _Container_base_aux_alloc_empty
: public _Container_base
{ 
protected:
explicit _Container_base_aux_alloc_empty(_Alloc) { }
	_Container_base_aux_alloc_empty(const _Container_base_aux_alloc_empty&) { }
	_Container_base_aux_alloc_empty& operator=(const _Container_base_aux_alloc_empty&)
{
return *this;
}
	~_Container_base_aux_alloc_empty() { }
};
	
		
struct input_iterator_tag
{	
};
struct output_iterator_tag
{	
};
struct forward_iterator_tag
: public input_iterator_tag
{	
};
struct bidirectional_iterator_tag
: public forward_iterator_tag
{	
};
struct random_access_iterator_tag
: public bidirectional_iterator_tag
{	
};
struct _Int_iterator_tag
{	
};
struct _Float_iterator_tag
{	
};
		
struct _Nonscalar_ptr_iterator_tag
{	
};
struct _Scalar_ptr_iterator_tag
{	
};
		
template<class _Category,
class _Ty,
class _Diff = ptrdiff_t,
class _Pointer = _Ty *,
class _Reference = _Ty&>
struct iterator
: public _Iterator_base_universal
	{	
typedef _Category iterator_category;
typedef _Ty value_type;
typedef _Diff difference_type;
typedef _Diff distance_type;	
typedef _Pointer pointer;
typedef _Reference reference;
};
template<class _Category,
class _Ty,
class _Diff = ptrdiff_t,
class _Pointer = _Ty *,
class _Reference = _Ty&,
class _Base_class = _Iterator_base>
struct _Iterator_with_base
: public _Base_class
	{	
typedef _Category iterator_category;
typedef _Ty value_type;
typedef _Diff difference_type;
typedef _Diff distance_type;	
typedef _Pointer pointer;
typedef _Reference reference;
};
template<class _Ty,
class _Diff,
class _Pointer,
class _Reference>
struct _Bidit
: public _Iterator_with_base<bidirectional_iterator_tag,
_Ty, _Diff, _Pointer, _Reference>
{	
};
template<class _Ty,
class _Diff,
class _Pointer,
class _Reference>
struct _Ranit
: public _Iterator_with_base<random_access_iterator_tag,
_Ty, _Diff, _Pointer, _Reference>
{	
};
template<class _Ty,
class _Diff,
class _Pointer,
class _Reference,
class _Base_class>
struct _Ranit_base
: public _Base_class
	{	
typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef _Diff difference_type;
typedef _Diff distance_type;	
typedef _Pointer pointer;
typedef _Reference reference;
};
struct _Outit
: public iterator<output_iterator_tag, void, void,
void, void>
{	
};
		
template<class _Iter>
struct iterator_traits
{	
typedef typename _Iter::iterator_category iterator_category;
typedef typename _Iter::value_type value_type;
typedef typename _Iter::difference_type difference_type;
typedef difference_type distance_type;	
typedef typename _Iter::pointer pointer;
typedef typename _Iter::reference reference;
};
template<class _Ty>
struct iterator_traits<_Ty *>
{	
typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef ptrdiff_t difference_type;
typedef ptrdiff_t distance_type;	
typedef _Ty *pointer;
typedef _Ty& reference;
};
template<class _Ty>
struct iterator_traits<const _Ty *>
{	
typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef ptrdiff_t difference_type;
typedef ptrdiff_t distance_type;	
typedef const _Ty *pointer;
typedef const _Ty& reference;
};
template<> struct iterator_traits<_Bool>
{	
typedef _Int_iterator_tag iterator_category;
typedef _Bool value_type;
typedef _Bool difference_type;
typedef _Bool distance_type;
typedef _Bool * pointer;
typedef _Bool& reference;
};
template<> struct iterator_traits<char>
{	
typedef _Int_iterator_tag iterator_category;
typedef char value_type;
typedef char difference_type;
typedef char distance_type;
typedef char * pointer;
typedef char& reference;
};
template<> struct iterator_traits<signed char>
{	
typedef _Int_iterator_tag iterator_category;
typedef signed char value_type;
typedef signed char difference_type;
typedef signed char distance_type;
typedef signed char * pointer;
typedef signed char& reference;
};
template<> struct iterator_traits<unsigned char>
{	
typedef _Int_iterator_tag iterator_category;
typedef unsigned char value_type;
typedef unsigned char difference_type;
typedef unsigned char distance_type;
typedef unsigned char * pointer;
typedef unsigned char& reference;
};
 
template<> struct iterator_traits<wchar_t>
{	
typedef _Int_iterator_tag iterator_category;
typedef wchar_t value_type;
typedef wchar_t difference_type;
typedef wchar_t distance_type;
typedef wchar_t * pointer;
typedef wchar_t& reference;
};
template<> struct iterator_traits<short>
{	
typedef _Int_iterator_tag iterator_category;
typedef short value_type;
typedef short difference_type;
typedef short distance_type;
typedef short * pointer;
typedef short& reference;
};
template<> struct iterator_traits<unsigned short>
{	
typedef _Int_iterator_tag iterator_category;
typedef unsigned short value_type;
typedef unsigned short difference_type;
typedef unsigned short distance_type;
typedef unsigned short * pointer;
typedef unsigned short& reference;
};
template<> struct iterator_traits<int>
{	
typedef _Int_iterator_tag iterator_category;
typedef int value_type;
typedef int difference_type;
typedef int distance_type;	
typedef int * pointer;
typedef int& reference;
};
template<> struct iterator_traits<unsigned int>
{	
typedef _Int_iterator_tag iterator_category;
typedef unsigned int value_type;
typedef unsigned int difference_type;
typedef unsigned int distance_type;	
typedef unsigned int * pointer;
typedef unsigned int& reference;
};
template<> struct iterator_traits<long>
{	
typedef _Int_iterator_tag iterator_category;
typedef long value_type;
typedef long difference_type;
typedef long distance_type;	
typedef long * pointer;
typedef long& reference;
};
template<> struct iterator_traits<unsigned long>
{	
typedef _Int_iterator_tag iterator_category;
typedef unsigned long value_type;
typedef unsigned long difference_type;
typedef unsigned long distance_type;	
typedef unsigned long * pointer;
typedef unsigned long& reference;
};
template<> struct iterator_traits<double>
{
typedef _Float_iterator_tag iterator_category;
typedef double value_type;
typedef double difference_type;
typedef double distance_type;	
typedef double * pointer;
typedef double& reference;
};
template<> struct iterator_traits<float>
{
typedef _Float_iterator_tag iterator_category;
typedef float value_type;
typedef float difference_type;
typedef float distance_type;	
typedef float * pointer;
typedef float& reference;
};
 
template<> struct iterator_traits<__int64>
{	
typedef _Int_iterator_tag iterator_category;
typedef __int64 value_type;
typedef __int64 difference_type;
typedef __int64 distance_type;	
typedef __int64 * pointer;
typedef __int64& reference;
};
template<> struct iterator_traits<unsigned __int64>
{	
typedef _Int_iterator_tag iterator_category;
typedef unsigned __int64 value_type;
typedef unsigned __int64 difference_type;
typedef unsigned __int64 distance_type;	
typedef unsigned __int64 * pointer;
typedef unsigned __int64& reference;
};
		
template<class _Iter> inline
typename iterator_traits<_Iter>::iterator_category
__cdecl _Iter_cat(const _Iter&)
{	
typename iterator_traits<_Iter>::iterator_category _Cat;
return (_Cat);
}
		
		
template<class _Cat1, class _Cat2>
class _Iter_random_helper
{
public:
typedef forward_iterator_tag _Iter_random_cat;
};
template<>
class _Iter_random_helper<random_access_iterator_tag, random_access_iterator_tag>
{
public:
typedef random_access_iterator_tag _Iter_random_cat;
};
template<class _Cat1, class _Cat2, class _Cat3>
class _Iter_random_helper3
{
public:
typedef forward_iterator_tag _Iter_random_cat;
};
template<>
class _Iter_random_helper3<random_access_iterator_tag, random_access_iterator_tag, random_access_iterator_tag>
{
public:
typedef random_access_iterator_tag _Iter_random_cat;
};
template<class _Iter1, class _Iter2> inline
typename _Iter_random_helper<
typename iterator_traits<_Iter1>::iterator_category,
typename iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat
__cdecl _Iter_random(const _Iter1&, const _Iter2&)
{	
typename _Iter_random_helper<
iterator_traits<_Iter1>::iterator_category, 
iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
return (_Cat);
}
template<class _Iter1, class _Iter2, class _Iter3> inline
typename _Iter_random_helper3<
typename iterator_traits<_Iter1>::iterator_category,
typename iterator_traits<_Iter2>::iterator_category,
typename iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat
__cdecl _Iter_random(const _Iter1&, const _Iter2&, const _Iter3&)
{	
typename _Iter_random_helper3<
iterator_traits<_Iter1>::iterator_category, 
iterator_traits<_Iter2>::iterator_category,
iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
return (_Cat);
}
		
	template <bool _Cond, class _Ty1, class _Ty2>
class _If
{
public:
typedef _Ty2 _Result;
};
	template <class _Ty1, class _Ty2>
class _If<true, _Ty1, _Ty2>
{
public:
typedef _Ty1 _Result;
};
		
template <bool _Secure_validation>
class _Secure_validation_helper
{
public:
typedef _Unchecked_iterator_tag _Checked_iterator_category;
};
	template <>
class _Secure_validation_helper<true>
{
public:
typedef _Range_checked_iterator_tag _Checked_iterator_category;
};
		
template <class _Iter, bool _Inherits_from_iterator_base>
class _Checked_iterator_category_helper
{
public:
typedef _Unchecked_iterator_tag _Checked_cat;
};
	template <class _Iter>
class _Checked_iterator_category_helper<_Iter, true>
{
public:
typedef typename _Iter::_Checked_iterator_category _Checked_cat;
};
	template <class _Iter>
class _Checked_iterator_category
{
public:
typedef typename _Checked_iterator_category_helper<_Iter, __is_base_of(_Iterator_base_universal, _Iter)>::_Checked_cat _Checked_cat;
};
	template<class _Iter> 
inline
typename _Checked_iterator_category<_Iter>::_Checked_cat _Checked_cat(const _Iter&)
{
typename _Checked_iterator_category<_Iter>::_Checked_cat _Cat;
return (_Cat);
}
		
template <class _Iter, bool _Inherits_from_iterator_base>
class _Checked_iterator_base_helper2
{
public:
typedef _Unchanged_checked_iterator_base_type_tag _Checked_iterator_base_type;
};
	template <class _Iter>
class _Checked_iterator_base_helper2<_Iter, true>
{
public:
typedef typename _Iter::_Checked_iterator_base_type _Checked_iterator_base_type;
};
	template <class _Iter, class _Base_type>
class _Checked_iterator_base_helper1
{
public:
typedef _Different_checked_iterator_base_type_tag _Base_type_tag;
typedef _Base_type _Checked_iterator_base_type;
};
	template <class _Iter>
class _Checked_iterator_base_helper1<_Iter, _Unchanged_checked_iterator_base_type_tag>
{
public:
typedef _Unchanged_checked_iterator_base_type_tag _Base_type_tag;
typedef _Iter _Checked_iterator_base_type;
};
	template <class _Iter>
class _Checked_iterator_base_helper
{
public:
typedef _Checked_iterator_base_helper2<_Iter, __is_base_of(_Iterator_base_universal, _Iter)> _Base_helper2;
typedef _Checked_iterator_base_helper1<_Iter, typename  _Base_helper2::_Checked_iterator_base_type > _Base_helper1;
		typedef typename _Base_helper1::_Base_type_tag _Checked_iterator_base_type_tag;
typedef typename _Base_helper1::_Checked_iterator_base_type _Checked_iterator_base_type;
};
	template<class _Iter, class _Base_tag>
inline
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
__cdecl _Checked_base(const _Iter &_It, _Base_tag)
{
return _It._Checked_iterator_base();
}
	template<class _Iter>
inline
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
__cdecl _Checked_base(const _Iter &_It, _Unchanged_checked_iterator_base_type_tag)
{
return _It;
}
	template<class _Iter, class _Base_tag>
inline
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
__cdecl _Checked_base(_Iter &_It, _Base_tag)
{
return _It._Checked_iterator_base();
}
	template<class _Iter>
inline
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
__cdecl _Checked_base(_Iter &_It, _Unchanged_checked_iterator_base_type_tag)
{
return _It;
}
	template<class _Iter>
inline
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
__cdecl _Checked_base(const _Iter &_It)
{
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
return _Checked_base(_It, _Base_tag);
}
	template<class _Iter>
inline
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type
__cdecl _Checked_base(_Iter &_It)
{
typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
return _Checked_base(_It, _Base_tag);
}
		
	template<class _DstIter, class _BaseIter>
inline
void __cdecl _Checked_assign_from_base(_DstIter &_Dest, const _BaseIter &_Src)
{
_Dest._Checked_iterator_assign_from_base(_Src);
}
	template<class _Iter>
inline
void __cdecl _Checked_assign_from_base(_Iter &_Dest, const _Iter &_Src)
{
_Dest = _Src;
}
		
 
	
template <class _Value>
class _Move_operation_category
{
public:
typedef _Undefined_move_tag _Move_cat;
};
	template<class _Iter>
inline
typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Move_cat(const _Iter&)
{
typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
return (_Cat);
}
		
template<class _T1, class _T2, class _Checked_Cat1, class _Checked_Cat2>
struct _Ptr_cat_with_checked_cat_helper
{
typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
};
template<class _T1,	class _T2>
struct _Ptr_cat_helper
{
typedef typename _Ptr_cat_with_checked_cat_helper<_T1, _T2, 
typename _Checked_iterator_category<_T1>::_Checked_cat,
typename _Checked_iterator_category<_T2>::_Checked_cat>::_Ptr_cat _Ptr_cat;
};
template<class _T1,	class _T2, class _Checked_Cat1>
struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Checked_Cat1, _Range_checked_iterator_tag>
{
typedef typename _Ptr_cat_helper<_T1, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
};
template<class _T1,	class _T2, class _Checked_Cat2>
struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Checked_Cat2>
{
typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, _T2>::_Ptr_cat _Ptr_cat;
};
template<class _T1,	class _T2>
struct _Ptr_cat_with_checked_cat_helper<_T1, _T2, _Range_checked_iterator_tag, _Range_checked_iterator_tag>
{
typedef typename _Ptr_cat_helper<typename _T1::_Inner_type, typename _T2::_Inner_type>::_Ptr_cat _Ptr_cat;
};
template<class _T1>
struct _Ptr_cat_helper<_T1, _Undefined_inner_type_tag>
{
typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
};
template<class _T2>
struct _Ptr_cat_helper<_Undefined_inner_type_tag, _T2>
{
typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<_Undefined_inner_type_tag, _Undefined_inner_type_tag>
{
typedef _Nonscalar_ptr_iterator_tag _Ptr_cat;
};
		
template<>
struct _Ptr_cat_helper<_Bool *, _Bool *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const _Bool *, _Bool *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<char *, char *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const char *, char *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<signed char *, signed char *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const signed char *, signed char *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<unsigned char *, unsigned char *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const unsigned char *, unsigned char *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
 
template<>
struct _Ptr_cat_helper<wchar_t *, wchar_t *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const wchar_t *, wchar_t *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
 
template<>
struct _Ptr_cat_helper<short *, short *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const short *, short *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<unsigned short *, unsigned short *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const unsigned short *, unsigned short *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<int *, int *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const int *, int *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<unsigned int *, unsigned int *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const unsigned int *, unsigned int *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<long *, long *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const long *, long *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<unsigned long *, unsigned long *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const unsigned long *, unsigned long *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<float *, float *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const float *, float *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<double *, double *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const double *, double *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<long double *, long double *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const long double *, long double *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
 
template<>
struct _Ptr_cat_helper<__int64 *, __int64 *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const __int64 *, __int64 *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<unsigned __int64 *, unsigned __int64 *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<>
struct _Ptr_cat_helper<const unsigned __int64 *, unsigned __int64 *>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
 
template<class _Ty>
struct _Ptr_cat_helper<_Ty **, _Ty **>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<class _Ty>
struct _Ptr_cat_helper<_Ty **, const _Ty **>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<class _Ty>
struct _Ptr_cat_helper<_Ty *const *, _Ty **>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<class _Ty>
struct _Ptr_cat_helper<_Ty *const *, const _Ty **>
{	
typedef _Scalar_ptr_iterator_tag _Ptr_cat;
};
template<class _T1, class _T2> inline 
typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat __cdecl _Ptr_cat(_T1&, _T2&)
{
typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
return (_Cat);
}
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
 
		
template<class _Iter> inline
typename iterator_traits<_Iter>::value_type *__cdecl _Val_type(_Iter)
{	
return (0);
}
		
template<class _InIt,
class _Diff> inline
void __cdecl advance(_InIt& _Where, _Diff _Off)
{	
_Advance(_Where, _Off, _Iter_cat(_Where));
}
template<class _InIt,
class _Diff> inline
void __cdecl _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
{	
 
	for (; 0 < _Off; --_Off)
++_Where;
}
template<class _FI,
class _Diff> inline
void __cdecl _Advance(_FI& _Where, _Diff _Off, forward_iterator_tag)
{	
 
	for (; 0 < _Off; --_Off)
++_Where;
}
#pragma warning(push)
#pragma warning(disable: 6295)
template<class _BI,
class _Diff> inline
void __cdecl _Advance(_BI& _Where, _Diff _Off, bidirectional_iterator_tag)
{	
for (; 0 < _Off; --_Off)
++_Where;
for (; _Off < 0; ++_Off)
--_Where;
}
#pragma warning(pop)
template<class _RI,
class _Diff> inline
void __cdecl _Advance(_RI& _Where, _Diff _Off, random_access_iterator_tag)
{	
_Where += _Off;
}
		
template<class _Iter> inline
typename iterator_traits<_Iter>::difference_type
* __cdecl _Dist_type(_Iter)
{	
return (0);
}
		
template<class _InIt,
class _Diff> inline
void __cdecl _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
input_iterator_tag)
{	
for (; _First != _Last; ++_First)
++_Off;
}
template<class _FwdIt,
class _Diff> inline
void __cdecl _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
forward_iterator_tag)
{	
for (; _First != _Last; ++_First)
++_Off;
}
template<class _BidIt,
class _Diff> inline
void __cdecl _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
bidirectional_iterator_tag)
{	
for (; _First != _Last; ++_First)
++_Off;
}
template<class _RanIt,
class _Diff> inline
void __cdecl _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
random_access_iterator_tag)
{	
 
	_Off += _Last - _First;
}
template<class _InIt> inline
typename iterator_traits<_InIt>::difference_type
__cdecl distance(_InIt _First, _InIt _Last)
{	
typename iterator_traits<_InIt>::difference_type _Off = 0;
_Distance2(_First, _Last, _Off, _Iter_cat(_First));
return (_Off);
}
template<class _InIt,
class _Diff> inline
void __cdecl _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
{	
_Distance2(_First, _Last, _Off, _Iter_cat(_First));
}
		
template<class _RanIt,
class _Base>
class _Revranit
: public _Base
{	
public:
typedef _Revranit<_RanIt, _Base> _Myt;
typedef typename iterator_traits<_RanIt>::iterator_category iterator_category;
typedef typename iterator_traits<_RanIt>::value_type value_type;
typedef typename iterator_traits<_RanIt>::difference_type difference_type;
typedef typename iterator_traits<_RanIt>::difference_type distance_type;	
typedef typename iterator_traits<_RanIt>::pointer pointer;
typedef typename iterator_traits<_RanIt>::reference reference;
typedef _RanIt iterator_type;
	 _Revranit()
{	
}
	explicit  _Revranit(_RanIt _Right)
: current(_Right)
{	
}
	template<class _RanIt2,
class _Base2>
_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
: current(_Right.base())
{	
}
	_RanIt  base() const
{	
return (current);
}
	reference  operator*() const
{	
_RanIt _Tmp = current;
return (*--_Tmp);
}
	pointer  operator->() const
{	
return (&**this);
}
	_Myt&  operator++()
{	
--current;
return (*this);
}
	_Myt  operator++(int)
{	
_Myt _Tmp = *this;
--current;
return (_Tmp);
}
	_Myt&  operator--()
{	
++current;
return (*this);
}
	_Myt  operator--(int)
{	
_Myt _Tmp = *this;
++current;
return (_Tmp);
}
	template<class _RanIt2,
class _Base2>
bool  _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
{	
return (current == _Right.base());
}
	_Myt&  operator+=(difference_type _Off)
{	
current -= _Off;
return (*this);
}
	_Myt  operator+(difference_type _Off) const
{	
return (_Myt(current - _Off));
}
	_Myt&  operator-=(difference_type _Off)
{	
current += _Off;
return (*this);
}
	_Myt  operator-(difference_type _Off) const
{	
return (_Myt(current + _Off));
}
	reference  operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
	template<class _RanIt2,
class _Base2>
bool  _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
{	
return (_Right.base() < current);
}
	template<class _RanIt2,
class _Base2>
difference_type  _Minus(const _Revranit<_RanIt2, _Base2>& _Right) const
{	
return (_Right.base() - current);
}
protected:
_RanIt current;	
};
		
template<class _RanIt,
class _Base,
class _Diff> inline
_Revranit<_RanIt, _Base>
operator+(_Diff _Off,
const _Revranit<_RanIt, _Base>& _Right)
{	
return (_Right + _Off);
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
typename _Base1::difference_type operator-(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (_Left._Minus(_Right));
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
bool operator==(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (_Left._Equal(_Right));
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
bool operator!=(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (!(_Left == _Right));
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
bool operator<(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (_Left._Less(_Right));
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
bool operator>(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (_Right < _Left);
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
bool operator<=(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (!(_Right < _Left));
}
template<class _RanIt1,
class _Base1,
class _RanIt2,
class _Base2> inline
bool operator>=(
const _Revranit<_RanIt1, _Base1>& _Left,
const _Revranit<_RanIt2, _Base2>& _Right)
{	
return (!(_Left < _Right));
}
		
template<class _RanIt>
class reverse_iterator
: public _Revranit<_RanIt, iterator<
typename iterator_traits<_RanIt>::iterator_category,
typename iterator_traits<_RanIt>::value_type,
typename iterator_traits<_RanIt>::difference_type,
typename iterator_traits<_RanIt>::pointer,
typename iterator_traits<_RanIt>::reference> >
{	
typedef reverse_iterator<_RanIt> _Myt;
typedef _Revranit<_RanIt, iterator<
typename iterator_traits<_RanIt>::iterator_category,
typename iterator_traits<_RanIt>::value_type,
typename iterator_traits<_RanIt>::difference_type,
typename iterator_traits<_RanIt>::pointer,
typename iterator_traits<_RanIt>::reference> > _Mybase;
public:
typedef typename iterator_traits<_RanIt>::iterator_category iterator_category;
typedef typename iterator_traits<_RanIt>::value_type value_type;
typedef typename iterator_traits<_RanIt>::difference_type difference_type;
typedef typename iterator_traits<_RanIt>::difference_type distance_type;	
typedef typename iterator_traits<_RanIt>::pointer pointer;
typedef typename iterator_traits<_RanIt>::reference reference;
typedef _RanIt iterator_type;
	 reverse_iterator()
{	
}
	explicit  reverse_iterator(_RanIt _Right)
: _Mybase(_Right)
{	
}
	template<class _Other>
reverse_iterator(const reverse_iterator<_Other>& _Right)
: _Mybase(_Right.base())
{	
}
	 reverse_iterator(_Mybase _Right)
: _Mybase(_Right)
{	
}
	typedef typename ::std:: _Checked_iterator_category<_RanIt>::_Checked_cat _Checked_iterator_category;
typedef reverse_iterator<typename _Checked_iterator_base_helper<_RanIt>::_Checked_iterator_base_type> _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
typename _Checked_iterator_base_type _Base(::std:: _Checked_base(this->current));
return _Base;
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
::std:: _Checked_assign_from_base(this->current, _Base.base());
}
	_Myt& operator++()
{	
++*((_Mybase *)this);
return (*this);
}
	_Myt operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt& operator--()
{	
--*((_Mybase *)this);
return (*this);
}
	_Myt operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt& operator+=(difference_type _Off)
{	
*((_Mybase *)this) += _Off;
return (*this);
}
	_Myt operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{	
*((_Mybase *)this) -= _Off;
return (*this);
}
	_Myt operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
};
		
template<class _RanIt,
class _Diff> inline
reverse_iterator<_RanIt> __cdecl operator+(_Diff _Off,
const reverse_iterator<_RanIt>& _Right)
{	
return (_Right + _Off);
}
template<class _RanIt1,
class _RanIt2> inline
typename reverse_iterator<_RanIt1>::difference_type
__cdecl operator-(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (_Left._Minus(_Right));
}
template<class _RanIt1,
class _RanIt2> inline
bool __cdecl operator==(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (_Left._Equal(_Right));
}
template<class _RanIt1,
class _RanIt2> inline
bool __cdecl operator!=(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (!(_Left == _Right));
}
template<class _RanIt1,
class _RanIt2> inline
bool __cdecl operator<(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (_Left._Less(_Right));
}
template<class _RanIt1,
class _RanIt2> inline
bool __cdecl operator>(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (_Right < _Left);
}
template<class _RanIt1,
class _RanIt2> inline
bool __cdecl operator<=(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (!(_Right < _Left));
}
template<class _RanIt1,
class _RanIt2> inline
bool __cdecl operator>=(const reverse_iterator<_RanIt1>& _Left,
const reverse_iterator<_RanIt2>& _Right)
{	
return (!(_Left < _Right));
}
		
template<class _BidIt,
class _Ty,
class _Reference = _Ty&,
class _Pointer = _Ty *,
class _Diff = ptrdiff_t>
class reverse_bidirectional_iterator
: public iterator<bidirectional_iterator_tag, _Ty, _Diff,
_Pointer, _Reference>
{	
public:
typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference,
_Pointer, _Diff> _Myt;
typedef _BidIt iterator_type;
	 reverse_bidirectional_iterator()
{	
}
	explicit  reverse_bidirectional_iterator(_BidIt _Right)
: current(_Right)
{	
}
	_BidIt  base() const
{	
return (current);
}
	_Reference  operator*() const
{	
_BidIt _Tmp = current;
return (*--_Tmp);
}
	_Pointer  operator->() const
{	
_Reference _Tmp = **this;
return (&_Tmp);
}
	_Myt&  operator++()
{	
--current;
return (*this);
}
	_Myt  operator++(int)
{	
_Myt _Tmp = *this;
--current;
return (_Tmp);
}
	_Myt&  operator--()
{	
++current;
return (*this);
}
	_Myt  operator--(int)
{	
_Myt _Tmp = *this;
++current;
return (_Tmp);
}
	bool  operator==(const _Myt& _Right) const
{	
return (current == _Right.current);
}
	bool  operator!=(const _Myt& _Right) const
{	
return (!(*this == _Right));
}
protected:
_BidIt current;	
};
		
template<class _BidIt,
class _BidIt2 = _BidIt>
class _Revbidit
: public iterator<
typename iterator_traits<_BidIt>::iterator_category,
typename iterator_traits<_BidIt>::value_type,
typename iterator_traits<_BidIt>::difference_type,
typename iterator_traits<_BidIt>::pointer,
typename iterator_traits<_BidIt>::reference>
{	
public:
typedef _Revbidit<_BidIt, _BidIt2> _Myt;
typedef typename iterator_traits<_BidIt>::difference_type _Diff;
typedef typename iterator_traits<_BidIt>::pointer _Pointer;
typedef typename iterator_traits<_BidIt>::reference _Reference;
typedef _BidIt iterator_type;
	 _Revbidit()
{	
}
	explicit  _Revbidit(_BidIt _Right)
: current(_Right)
{	
}
	 _Revbidit(const _Revbidit<_BidIt2>& _Other)
: current (_Other.base())
{	
}
	_BidIt  base() const
{	
return (current);
}
	_Reference  operator*() const
{	
_BidIt _Tmp = current;
return (*--_Tmp);
}
	_Pointer  operator->() const
{	
_Reference _Tmp = **this;
return (&_Tmp);
}
	_Myt&  operator++()
{	
--current;
return (*this);
}
	_Myt  operator++(int)
{	
_Myt _Tmp = *this;
--current;
return (_Tmp);
}
	_Myt&  operator--()
{	
++current;
return (*this);
}
	_Myt  operator--(int)
{	
_Myt _Tmp = *this;
++current;
return (_Tmp);
}
	bool  operator==(const _Myt& _Right) const
{	
return (current == _Right.current);
}
	bool  operator!=(const _Myt& _Right) const
{	
return (!(*this == _Right));
}
protected:
_BidIt current;
};
		
template<class _InIt, class _OutIt, class _InOutItCat>
inline
_OutIt __cdecl _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
_InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
;
for (; _First != _Last; ++_Dest, ++_First)
*_Dest = *_First;
return (_Dest);
}
template<class _InIt, class _OutIt>
inline
_OutIt __cdecl _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last - _First);
_Copy_opt(_First, _Last, ::std:: _Checked_base(_Dest), 
forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt, class _OutIt, class _InOutItCat>
inline
_OutIt __cdecl _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
_InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
 
	ptrdiff_t _Off = _Last - _First;	
	_OutIt _Result = _Dest + _Off;
if (_Off > 0)
::memmove_s((&*_Dest), (_Off * sizeof (*_First)), (&*_First), (_Off * sizeof (*_First)));
return _Result;
}
template <bool _Cond, class _Result_type>
struct _Enable_if;
template <class _Result_type>
struct _Enable_if<true, _Result_type>
{
typedef _Result_type _Result;
};
template <class _Checked_iter_cat>
struct _Is_checked_iterator_helper
{
enum { _Result = false };
};
template <>
struct _Is_checked_iterator_helper<_Range_checked_iterator_tag>
{
enum { _Result = true };
};
template <class _Iter>
struct _Is_checked_iterator
{
enum { _Result = 
_Is_checked_iterator_helper<typename _Checked_iterator_category<_Iter>::_Checked_cat>::_Result };
};
template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
{	
return copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), ::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
}
template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));
}
		
template<class _InIt, class _OutIt, class _InOutItCat, class _MoveCatTy>
inline
_OutIt __cdecl _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
_InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
{	
return _Copy_opt(_First, _Last, _Dest,
_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
}
template<class _InIt, class _OutIt, class _InOutItCat>
inline
_OutIt __cdecl _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
_InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
{	
;
for (; _First != _Last; ++_Dest, ++_First)
::std:: swap(*_Dest, *_First);
return (_Dest);
}
template<class _InIt, class _OutIt, class _InOutItCat>
inline
_OutIt __cdecl _Move_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last - _First);
_Move_opt(_First, _Last, ::std:: _Checked_base(_Dest),
forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Move(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl _Move(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
{	
return _Move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
}
template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Move(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _BidIt1, class _BidIt2, class _InOutItCat>
inline
_BidIt2 __cdecl _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
_InOutItCat, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
;
while (_First != _Last)
*--_Dest = *--_Last;
return (_Dest);
}
template<class _InIt, class _OutIt>
inline
_OutIt __cdecl _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
random_access_iterator_tag, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest - (_Last - _First);
_Copy_backward_opt(_First, _Last, ::std:: _Checked_base(_Dest),
forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt, class _OutIt, class _InOutItCat>
inline
_OutIt __cdecl _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
_InOutItCat, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
 
	ptrdiff_t _Off = _Last - _First;	
	_OutIt _Result = _Dest - _Off;
if (_Off > 0)
::memmove_s((&*_Result), (_Off * sizeof (*_First)), (&*_First), (_Off * sizeof (*_First)));
return _Result;
}
template<class _BidIt1,
class _BidIt2> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1,
class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _BidIt1, class _BidIt2, class _InOutItCat, class _MoveCatTy>
inline
_BidIt2 __cdecl _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
_InOutItCat _First_dest_cat, _MoveCatTy, _Range_checked_iterator_tag)
{	
return _Copy_backward_opt(_First, _Last, _Dest,
_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _InOutItCat>
inline
_BidIt2 __cdecl _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
_InOutItCat, _Swap_move_tag, _Range_checked_iterator_tag)
{	
;
while (_First != _Last)
::std:: swap(*--_Dest, *--_Last);
return (_Dest);
}
template<class _BidIt1, class _BidIt2>
inline
_BidIt2 __cdecl _Move_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
random_access_iterator_tag, _Swap_move_tag _Move_cat, _Range_checked_iterator_tag)
{	
	_BidIt2 _Result = _Dest - (_Last - _First);
_Move_backward_opt(_First, _Last, ::std:: _Checked_base(_Dest),
forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());
return _Result;
}
template<class _BidIt1, class _BidIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Iter_random(_First, _Dest), _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1, class _InIt2, class _InItCats>
inline
pair<_InIt1, _InIt2>
__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_InItCats, _Range_checked_iterator_tag)
{	
 
	for (; _First1 != _Last1 && *_First1 == *_First2; )
++_First1, ++_First2;
return (pair<_InIt1, _InIt2>(_First1, _First2));
}
template<class _InIt1, class _InIt2>
inline
pair<_InIt1, _InIt2>
__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
pair<_InIt1, typename ::std:: _Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type> _Result =
_Mismatch(_First1, _Last1, ::std:: _Checked_base(_First2),
forward_iterator_tag(), _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First2, _Result.second);
return (pair<_InIt1, _InIt2>(_Result.first, _First2));
}
template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (pair<_InIt1, _InIt2>(_First1, _Result.second));
}
template<class _InIt1, class _InElem2, size_t _Size>
inline
pair<_InIt1, _InElem2*>
__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
{	
pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size));
return (pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
}
template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (pair<_InIt1, _InIt2>(_First1, _Result.second));
}
		
template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
inline
pair<_InIt1, _InIt2>
__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
_InItCats, _Range_checked_iterator_tag)
{	
 
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
++_First1, ++_First2;
return (pair<_InIt1, _InIt2>(_First1, _First2));
}
template<class _InIt1, class _InIt2, class _Pr>
inline
pair<_InIt1, _InIt2>
__cdecl _Mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
pair<_InIt1, typename ::std:: _Checked_iterator_base_helper<_InIt2>::_Checked_iterator_base_type> _Result =
_Mismatch(_First1, _Last1, ::std:: _Checked_base(_First2), _Pred,
forward_iterator_tag(), _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First2, _Result.second);
return (pair<_InIt1, _InIt2>(_Result.first, _First2));
}
template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (pair<_InIt1, _InIt2>(_First1, _Result.second));
}
template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
pair<_InIt1, _InElem2*>
__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
{	
pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
return (pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
}
template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
_Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (pair<_InIt1, _InIt2>(_First1, _Result.second));
}
		
template<class _InIt1, class _InIt2, class _InItCats>
inline
bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_InItCats, _Range_checked_iterator_tag)
{	
for (; _First1 != _Last1; ++_First1, ++_First2)
if (!(*_First1 == *_First2))
return (false);
return (true);
}
inline bool __cdecl _Equal(const char *_First1,
const char *_Last1, const char *_First2,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
}
inline bool __cdecl _Equal(const signed char *_First1,
const signed char *_Last1, const signed char *_First2,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
}
inline bool __cdecl _Equal(const unsigned char *_First1,
const unsigned char *_Last1, const unsigned char *_First2,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	return (::memcmp(_First1, _First2, _Last1 - _First1) == 0);
}
template<class _InIt1, class _InIt2>
inline
bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
random_access_iterator_tag, _Range_checked_iterator_tag)
{
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
return _Equal(_First1, _Last1, ::std:: _Checked_base(_First2),
forward_iterator_tag(), _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InElem2, size_t _Size>
inline
bool __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
{	
return equal(_First1, _Last1,
::stdext:: make_checked_array_iterator(_First2, _Size));
}
template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1, class _InIt2, class _Pr, class _InItCats>
inline
bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
_InItCats, _Range_checked_iterator_tag)
{	
for (; _First1 != _Last1; ++_First1, ++_First2)
if (!_Pred(*_First1, *_First2))
return (false);
return (true);
}
template<class _InIt1, class _InIt2, class _Pr>
inline
bool __cdecl _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
random_access_iterator_tag, _Range_checked_iterator_tag)
{
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
return _Equal(_First1, _Last1, ::std:: _Checked_base(_First2), _Pred,
forward_iterator_tag(), _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
bool __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
{	
return equal(_First1, _Last1,
::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
}
template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
return _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt, class _Ty> inline
void __cdecl _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{	
;
for (; _First != _Last; ++_First)
*_First = _Val;
}
inline void __cdecl _Fill([SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_First, 
[SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char *_Last, int _Val)
{	
;
::memset(_First, _Val, _Last - _First);
}
inline void __cdecl _Fill([SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] signed char *_First, 
[SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] signed char *_Last, int _Val)
{	
;
::memset(_First, _Val, _Last - _First);
}
inline void __cdecl _Fill(
[SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] unsigned char *_First,
[SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] unsigned char *_Last, int _Val)
{	
;
::memset(_First, _Val, _Last - _First);
}
template<class _FwdIt, class _Ty> inline
void __cdecl fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{	
_Fill(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val);
}
		
template<class _OutIt,
class _Diff,
class _Ty> inline
void __cdecl _Fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val,
_Range_checked_iterator_tag)
{	
for (; 0 < _Count; --_Count, ++_First)
*_First = _Val;
}
inline void __cdecl _Fill_n([SA_Pre(Null=SA_Maybe,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_Count")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_First, 
size_t _Count, int _Val, _Range_checked_iterator_tag)
{	
 
	::memset(_First, _Val, _Count);
}
inline void __cdecl _Fill_n([SA_Pre(Null=SA_Maybe,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_Count")] [SA_Post(Deref=1,Valid=SA_Yes)] signed char *_First, 
size_t _Count, int _Val, _Range_checked_iterator_tag)
{	
 
	::memset(_First, _Val, _Count);
}
inline void __cdecl _Fill_n([SA_Pre(Null=SA_Maybe,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="_Count")] [SA_Post(Deref=1,Valid=SA_Yes)] unsigned char *_First, 
size_t _Count, int _Val, _Range_checked_iterator_tag)
{	
 
	::memset(_First, _Val, _Count);
}
template<class _OutIt, class _Diff, class _Ty, class _OutCat>
inline
void __cdecl _Fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val,
_OutCat, _Range_checked_iterator_tag)
{
_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());
}
template<class _OutIt, class _Diff, class _Ty>
inline
void __cdecl _Fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val,
random_access_iterator_tag, _Range_checked_iterator_tag)
{
		_OutIt _Last = _First + _Count; (_Last);
_Fill_n(::std:: _Checked_base(_First), _Count, _Val,
_Range_checked_iterator_tag());
}
template<class _OutIt,
class _Diff,
class _Ty>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
{	
_Fill_n(_First, _Count, _Val, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
}
template<class _OutElem,
class _Diff,
class _Ty, size_t _Size>
inline
void __cdecl fill_n(_OutElem (&_First)[_Size], _Diff _Count, const _Ty& _Val)
{	
fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val);
}
template<class _OutIt,
class _Diff,
class _Ty>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
{	
_Fill_n(_First, _Count, _Val, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1, class _InIt2> inline
bool __cdecl _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2)
{	
;
;
for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
if (((*_First1) < (*_First2)))
return (true);
else if (*_First2 < *_First1)
return (false);
return (_First1 == _Last1 && _First2 != _Last2);
}
template<class _InIt1, class _InIt2> inline
bool __cdecl lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2)
{	
return _Lexicographical_compare(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2));
}
inline bool __cdecl lexicographical_compare(
const unsigned char *_First1, const unsigned char *_Last1,
const unsigned char *_First2, const unsigned char *_Last2)
{	
;
;
ptrdiff_t _Num1 = _Last1 - _First1;
ptrdiff_t _Num2 = _Last2 - _First2;
int _Ans = ::memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
}
 
		
template<class _InIt1,
class _InIt2,
class _Pr> inline
bool __cdecl _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
if (_Pred(*_First1, *_First2))
return (true);
else if (_Pred(*_First2, *_First1))
return (false);
return (_First1 == _Last1 && _First2 != _Last2);
}
template<class _InIt1, class _InIt2, class _Pr> inline
bool __cdecl lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
{	
return _Lexicographical_compare(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred);
}
 
  
		
template<class _Ty> inline
const _Ty& (__cdecl max)(const _Ty& _Left, const _Ty& _Right)
{	
return (((_Left) < (_Right)) ? _Right : _Left);
}
		
template<class _Ty,
class _Pr> inline
const _Ty& (__cdecl max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
{	
return (_Pred(_Left, _Right) ? _Right : _Left);
}
		
template<class _Ty> inline
const _Ty& (__cdecl min)(const _Ty& _Left, const _Ty& _Right)
{	
return (((_Right) < (_Left)) ? _Right : _Left);
}
		
template<class _Ty,
class _Pr> inline
const _Ty& (__cdecl min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
{	
return (_Pred(_Right, _Left) ? _Right : _Left);
}
}
namespace stdext {
template <class _Iterator>
class checked_array_iterator
: public ::std:: iterator<
typename ::std:: iterator_traits<_Iterator>::iterator_category, 
typename ::std:: iterator_traits<_Iterator>::value_type, 
typename ::std:: iterator_traits<_Iterator>::difference_type, 
typename ::std:: iterator_traits<_Iterator>::pointer, 
typename ::std:: iterator_traits<_Iterator>::reference>
{
public:
typedef checked_array_iterator<_Iterator> _Myt;
typedef typename ::std:: iterator_traits<_Iterator>::difference_type difference_type;
typedef typename ::std:: iterator_traits<_Iterator>::pointer pointer;
typedef typename ::std:: iterator_traits<_Iterator>::reference reference;
	typedef ::std:: _Range_checked_iterator_tag _Checked_iterator_category;
typedef _Iterator _Inner_type;
	typedef _Iterator _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
return _Mycont + _Current;
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
_Current = _Base - _Mycont;
}
	
	checked_array_iterator():
_Size(0), _Current(0)
{
}
	checked_array_iterator(_Iterator _Cont, size_t _S, size_t _Index = 0)
{
{ if (!(_Index <= _S)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
_Mycont = _Cont;
_Size = _S;
_Current =_Index;
}
	_Iterator base() const
{
return _Mycont + _Current;
}
	size_t __Size() const
{
return _Size;
}
	bool operator==(const _Myt& _Right) const
{
{ if (!(_Mycont == _Right._Mycont)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current == _Right._Current;
}
	bool operator!=(const _Myt& _Right) const
{
return !(*this == _Right);
}
	bool operator<(const _Myt& _Right) const
{
{ if (!(_Mycont == _Right._Mycont)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current < _Right._Current;
}
	bool operator>(const _Myt& _Right) const
{
return _Right < *this;
}
	bool operator<=(const _Myt& _Right) const
{
return !(_Right < *this);
}
	bool operator>=(const _Myt& _Right) const
{
return !(*this < _Right);
}
	reference operator*() const
{
{ if (!(_Current < _Size)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return *(_Mycont + _Current);
}
	pointer operator->() const
{
return (&**this);
}
	checked_array_iterator& operator++()
{
{ if (!(_Current < _Size)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
++_Current;
return *this;
}
	_Myt operator++(int)
{
checked_array_iterator _Tmp = *this;
++*this;
return _Tmp;
}
	_Myt& operator--()
{
{ if (!(_Current > 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
--_Current;
return *this;
}
	_Myt operator--(int)
{
checked_array_iterator _Tmp = *this;
--*this;
return _Tmp;
}
	
	_Myt& operator+=(difference_type _Off)
{
{ if (!(_Current + _Off <= _Size && _Current + _Off >= 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
_Current += _Off;
return *this;
}
	_Myt operator+(difference_type _Off) const
{
checked_array_iterator _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{
return (*this += -_Off);
}
	_Myt operator-(difference_type _Off) const
{
checked_array_iterator _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const checked_array_iterator& _Right) const
{
{ if (!(_Mycont == _Right._Mycont)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current - _Right._Current;
}
	reference operator[](difference_type _Off) const
{
{ if (!(_Current + _Off < _Size && _Current + _Off >= 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return *(_Mycont + _Current + _Off);
}
protected:
void _Xran() const
{	
throw ::std:: out_of_range("invalid checked_array_iterator<T> subscript");
}
	void _Xinvarg() const
{	
throw ::std:: invalid_argument("invalid checked_array_iterator<T> argument");
}
	_Iterator _Mycont; 
size_t _Current; 
size_t _Size; 
};
template <class _Iter>
checked_array_iterator<_Iter> make_checked_array_iterator(_Iter _Ptr, size_t _Size)
{
return checked_array_iterator<_Iter>(_Ptr, _Size);
}
template<class _InIt,
class _OutIt> inline
_OutIt __cdecl unchecked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (::std:: _Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl checked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (::std:: _Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl checked_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
{	
return checked_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), ::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
}
template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl checked_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (::std:: _Copy_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, 
::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _BidIt1,
class _BidIt2> inline
_BidIt2 __cdecl unchecked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return (::std:: _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _BidIt1,
class _BidIt2> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl checked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return ::std:: _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1,
class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl checked_copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return ::std:: _Copy_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt> inline
_OutIt __cdecl _Unchecked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (::std:: _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Checked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return ::std:: _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* __cdecl _Checked_move(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
{	
return _Checked_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
::stdext:: make_checked_array_iterator(_Dest, _Size)).base();
}
template<class _InIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result __cdecl _Checked_move(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return ::std:: _Move_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1,
class _BidIt2> inline
_BidIt2 __cdecl _Unchecked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return (::std:: _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _BidIt1, class _BidIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Checked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return ::std:: _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt2 >::_Result, _BidIt2 >::_Result __cdecl _Checked_move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
{	
return ::std:: _Move_backward_opt(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _OutIt,
class _Diff,
class _Ty> inline
void __cdecl unchecked_fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
{	
::std:: _Fill_n(_First, _Count, _Val, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
}
template<class _OutIt,
class _Diff,
class _Ty>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl checked_fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
{	
_Fill_n(_First, _Count, _Val, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
}
template<class _OutElem,
class _Diff,
class _Ty, size_t _Size>
inline
void __cdecl checked_fill_n(_OutElem (&_First)[_Size], _Diff _Count, const _Ty& _Val)
{	
checked_fill_n(::stdext:: make_checked_array_iterator( _First, _Size), _Count, _Val);
}
template<class _OutIt,
class _Diff,
class _Ty>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result __cdecl checked_fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
{	
_Fill_n(_First, _Count, _Val, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2>
inline
::std:: pair<_InIt1, _InIt2>
__cdecl unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
}
template<class _InIt1, class _InElem2, size_t _Size>
inline
::std:: pair<_InIt1, _InElem2*>
__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
{	
::std:: pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
checked_mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size));
return (::std:: pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
}
template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
}
template<class _InIt1, class _InIt2, class _Pr>
inline
::std:: pair<_InIt1, _InIt2>
__cdecl unchecked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
	::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
	}
template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
}
template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
::std:: pair<_InIt1, _InElem2*>
__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
{	
::std:: pair<_InIt1, ::stdext:: checked_array_iterator<_InElem2*> > _Result =
checked_mismatch(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
return (::std:: pair<_InIt1, _InElem2*>(_Result.first, _Result.second.base()));
}
template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, ::std:: pair< _InIt1, _InIt2 > >::_Result
__cdecl checked_mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
::std:: pair<typename ::std:: _Checked_iterator_base_helper<_InIt1>::_Checked_iterator_base_type, _InIt2> _Result =
::std:: _Mismatch(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
::std:: _Checked_assign_from_base(_First1, _Result.first);
return (::std:: pair<_InIt1, _InIt2>(_First1, _Result.second));
}
template<class _InIt1, class _InIt2>
inline
bool __cdecl unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InElem2, size_t _Size>
inline
bool __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size])
{	
return checked_equal(_First1, _Last1,
::stdext:: make_checked_array_iterator(_First2, _Size));
}
template<class _InIt1, class _InIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
{	
return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _Pr>
inline
bool __cdecl unchecked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InElem2, class _Pr, size_t _Size>
inline
bool __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_Size], _Pr _Pred)
{	
return checked_equal(_First1, _Last1,
::stdext:: make_checked_array_iterator(_First2, _Size), _Pred);
}
template<class _InIt1, class _InIt2, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, bool >::_Result __cdecl checked_equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
{	
return ::std:: _Equal(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Pred,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
}
 
 
 
 
 
 
extern "C"
__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Container>
class back_insert_iterator
: public _Outit
{	
public:
typedef _Container container_type;
typedef typename _Container::reference reference;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	explicit back_insert_iterator(_Container& _Cont)
: container(&_Cont)
{	
}
	back_insert_iterator<_Container>& operator=(
typename _Container::const_reference _Val)
{	
container->push_back(_Val);
return (*this);
}
	back_insert_iterator<_Container>& operator*()
{	
return (*this);
}
	back_insert_iterator<_Container>& operator++()
{	
return (*this);
}
	back_insert_iterator<_Container> operator++(int)
{	
return (*this);
}
protected:
_Container *container;	
};
		
template<class _Container> inline
back_insert_iterator<_Container> back_inserter(_Container& _Cont)
{	
return (std::back_insert_iterator<_Container>(_Cont));
}
		
template<class _Container>
class front_insert_iterator
: public _Outit
{	
public:
typedef _Container container_type;
typedef typename _Container::reference reference;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	explicit front_insert_iterator(_Container& _Cont)
: container(&_Cont)
{	
}
	front_insert_iterator<_Container>& operator=(
typename _Container::const_reference _Val)
{	
container->push_front(_Val);
return (*this);
}
	front_insert_iterator<_Container>& operator*()
{	
return (*this);
}
	front_insert_iterator<_Container>& operator++()
{	
return (*this);
}
	front_insert_iterator<_Container> operator++(int)
{	
return (*this);
}
protected:
_Container *container;	
};
		
template<class _Container> inline
front_insert_iterator<_Container> front_inserter(_Container& _Cont)
{	
return (std::front_insert_iterator<_Container>(_Cont));
}
		
template<class _Container>
class insert_iterator
: public _Outit
{	
public:
typedef _Container container_type;
typedef typename _Container::reference reference;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
: container(&_Cont), iter(_Where)
{	
}
	insert_iterator<_Container>& operator=(
typename _Container::const_reference _Val)
{	
iter = container->insert(iter, _Val);
++iter;
return (*this);
}
	insert_iterator<_Container>& operator*()
{	
return (*this);
}
	insert_iterator<_Container>& operator++()
{	
return (*this);
}
	insert_iterator<_Container>& operator++(int)
{	
return (*this);
}
protected:
_Container *container;	
typename _Container::iterator iter;	
};
		
template<class _Container,
class _Iter> inline
insert_iterator<_Container> inserter(_Container& _Cont, _Iter _Where)
{	
return (std::insert_iterator<_Container>(_Cont, _Where));
}
		
template<class _Ty,
class _Elem = char,
class _Traits = char_traits<_Elem>,
class _Diff = ptrdiff_t>
class istream_iterator
: public iterator<input_iterator_tag, _Ty, _Diff,
const _Ty *, const _Ty&>
{	
typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
typedef _Elem char_type;
typedef _Traits traits_type;
typedef basic_istream<_Elem, _Traits> istream_type;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	istream_iterator()
: _Myistr(0)
{	
}
	istream_iterator(istream_type& _Istr)
: _Myistr(&_Istr)
{	
_Getval();
}
	const _Ty& operator*() const
{	
 
		{ if (!(_Myistr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (_Myval);
}
	const _Ty *operator->() const
{	
return (&**this);
}
	_Myt& operator++()
{	
 
		{ if (!(_Myistr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		_Getval();
return (*this);
}
	_Myt operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	bool _Equal(const _Myt& _Right) const
{	
return (_Myistr == _Right._Myistr);
}
protected:
void _Getval()
{	
if (_Myistr != 0 && !(*_Myistr >> _Myval))
_Myistr = 0;
}
	static void _Xran()
{	
throw out_of_range("invalid istream_iterator");
}
	istream_type *_Myistr;	
_Ty _Myval;	
};
		
template<class _Ty,
class _Elem,
class _Traits,
class _Diff> inline
bool operator==(
const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
{	
return (_Left._Equal(_Right));
}
template<class _Ty,
class _Elem,
class _Traits,
class _Diff> inline
bool operator!=(
const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
{	
return (!(_Left == _Right));
}
		
template<class _Ty,
class _Elem = char,
class _Traits = char_traits<_Elem> >
class ostream_iterator
: public _Outit
{	
public:
typedef _Elem char_type;
typedef _Traits traits_type;
typedef basic_ostream<_Elem, _Traits> ostream_type;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	ostream_iterator(ostream_type& _Ostr,
const _Elem *_Delim = 0)
: _Myostr(&_Ostr), _Mydelim(_Delim)
{	
}
	ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
{	
*_Myostr << _Val;
if (_Mydelim != 0)
*_Myostr << _Mydelim;
 
		{ if (!(*_Myostr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (*this);
}
	ostream_iterator<_Ty, _Elem, _Traits>& operator*()
{	
return (*this);
}
	ostream_iterator<_Ty, _Elem, _Traits>& operator++()
{	
return (*this);
}
	ostream_iterator<_Ty, _Elem, _Traits> operator++(int)
{	
return (*this);
}
protected:
static void _Xran()
{	
throw out_of_range("invalid ostream_iterator");
}
	const _Elem *_Mydelim;	
ostream_type *_Myostr;	
};
}
namespace stdext {
template <class _Cont, class _Iter = typename _Cont::iterator>
class checked_iterator
: public ::std:: iterator<
typename ::std:: iterator_traits<_Iter>::iterator_category, 
typename ::std:: iterator_traits<_Iter>::value_type, 
typename ::std:: iterator_traits<_Iter>::difference_type, 
typename ::std:: iterator_traits<_Iter>::pointer, 
typename ::std:: iterator_traits<_Iter>::reference>
{
friend class checked_iterator;
public:
typedef checked_iterator<_Cont, _Iter> _Myt;
typedef typename ::std:: iterator_traits<_Iter>::difference_type difference_type;
typedef typename ::std:: iterator_traits<_Iter>::pointer pointer;
typedef typename ::std:: iterator_traits<_Iter>::reference reference;
	typedef ::std:: _Range_checked_iterator_tag _Checked_iterator_category;
typedef _Iter _Inner_type;
	typedef _Iter _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
return _Current;
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
_Current = _Base;
}
	
	checked_iterator()
: _Mycont(0)
{
}
	checked_iterator(_Cont& _C, _Iter _Ptr)
: _Mycont(&_C), _Current(_Ptr)
{
}
	checked_iterator(const _Myt &_Right)
: _Mycont(_Right._Mycont), _Current(_Right._Current)
{
}
	template <class Iter2>
checked_iterator(const checked_iterator<_Cont, Iter2> &_Right)
: _Mycont(_Right._Mycont), _Current(_Right._Current)
{
}
	_Iter base() const
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current;
}
	template <class Iter2>
bool operator==(const checked_iterator<_Cont, Iter2>& _Right) const
{
{ if (!(_Mycont == _Right._Mycont)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current == _Right._Current;
}
	template <class Iter2>
bool operator!=(const checked_iterator<_Cont, Iter2>& _Right) const
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return !(*this == _Right);
}
	template <class Iter2>
bool operator<(const checked_iterator<_Cont, Iter2>& _Right) const
{
{ if (!(_Mycont != 0 && _Mycont == _Right._Mycont)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current < _Right._Current;
}
	template <class Iter2>
bool operator>(const checked_iterator<_Cont, Iter2>& _Right) const
{
return _Right < *this;
}
	template <class Iter2>
bool operator<=(const checked_iterator<_Cont, Iter2>& _Right) const
{
return !(_Right < *this);
}
	template <class Iter2>
bool operator>=(const checked_iterator<_Cont, Iter2>& _Right) const
{
return !(*this < _Right);
}
	reference operator*() const
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Current != _Mycont->end())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return *_Current;
}
	pointer operator->() const
{
return (&**this);
}
	_Myt& operator++()
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Current != _Mycont->end())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
++_Current;
return *this;
}
	_Myt operator++(int)
{
_Myt _Tmp = *this;
++*this;
return _Tmp;
}
	_Myt& operator--()
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Current != _Mycont->begin())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
--_Current;
return *this;
}
	_Myt operator--(int)
{
_Myt _Tmp = *this;
--*this;
return _Tmp;
}
	
	_Myt& operator+=(difference_type _Off)
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!((_Mycont->end() - _Current) >= _Off && (_Mycont->begin() - _Current) <= _Off)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
_Current += _Off;
return *this;
}
	_Myt operator+(difference_type _Off) const
{
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{
return (*this += -_Off);
}
	_Myt operator-(difference_type _Off) const
{
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const _Myt& _Right) const
{
{ if (!(_Mycont != 0 && _Mycont == _Right._Mycont)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current - _Right._Current;
}
	reference operator[](difference_type _Off) const
{
{ if (!(_Mycont != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!((_Mycont->end() - _Current) > _Off && (_Mycont->begin() - _Current) <= _Off)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
return _Current[_Off];
}
protected:
void _Xran() const
{	
throw ::std:: out_of_range("invalid checked_iterator<T> subscript");
}
	void _Xinvarg() const
{	
throw ::std:: invalid_argument("invalid checked_iterator<T> argument");
}
	_Cont *_Mycont; 
_Iter _Current; 
};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
  
  
  
}
 
 
#pragma once
 
#pragma pack(push,8)
typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();
struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) void __cdecl unexpected(void);
__declspec(dllimport) int __cdecl _is_exception_typeof([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const type_info &_Type, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] struct _EXCEPTION_POINTERS * _ExceptionPtr);
__declspec(dllimport) terminate_function __cdecl set_terminate([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] terminate_function _NewPtFunc);
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(void);
__declspec(dllimport) unexpected_function __cdecl set_unexpected([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] unexpected_function _NewPtFunc);
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(void);
__declspec(dllimport) _se_translator_function __cdecl _set_se_translator([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _se_translator_function _NewPtFunc);
__declspec(dllimport) bool __cdecl __uncaught_exception();
#pragma pack(pop)
 
#pragma once
 
#pragma pack(push,8)
extern "C" {
typedef struct _heapinfo {
int * _pentry;
size_t _size;
int _useflag;
} _HEAPINFO;
extern __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_amblksiz" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) unsigned int _amblksiz;
__declspec(dllimport) int     __cdecl _resetstkoflw (void);
__declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned long _NewValue);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_NewSize")] __declspec(dllimport) void *  __cdecl _expand([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NewSize);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t  __cdecl _msize([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] void * _Memory);
[returnvalue:SA_Post(MustCheck=SA_Yes)] [returnvalue:SA_Post(Null=SA_No,WritableBytes="_Size")] void *          __cdecl _alloca([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) size_t  __cdecl _get_sbh_threshold(void);
__declspec(dllimport) int     __cdecl _set_sbh_threshold([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _NewValue);
__declspec(dllimport) errno_t __cdecl _set_amblksiz([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Value);
__declspec(dllimport) errno_t __cdecl _get_amblksiz([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] size_t * _Value);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _heapadd([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] void * _Memory, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Size);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _heapchk(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int     __cdecl _heapmin(void);
__declspec(dllimport) int     __cdecl _heapset([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Fill);
__declspec(dllimport)  int     __cdecl _heapwalk([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] _HEAPINFO * _EntryInfo);
__declspec(dllimport) size_t  __cdecl _heapused(size_t * _Used, size_t * _Commit);
__declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);
typedef char __static_assert_t[ (sizeof(unsigned int) <= 8) ];
#pragma warning(push)
#pragma warning(disable:6540)
__inline void *_MarkAllocaS([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)]  void *_Ptr, unsigned int _Marker)
{
if (_Ptr)
{
*((unsigned int*)_Ptr) = _Marker;
_Ptr = (char*)_Ptr + 8;
}
return _Ptr;
}
#pragma warning(pop)
__declspec(noalias) __inline void __cdecl _freea([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] void * _Memory)
{
unsigned int _Marker;
if (_Memory)
{
_Memory = (char*)_Memory - 8;
_Marker = *(unsigned int *)_Memory;
if (_Marker == 0xDDDD)
{
free(_Memory);
}
        else if (_Marker != 0xCCCC)
{
((void)0);
}
    }
}
}
#pragma pack(pop)
 
 
typedef const char *__exString;
extern "C" [returnvalue:SA_Post(MustCheck=SA_Yes)] size_t __cdecl strlen([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char *);
extern "C" __declspec(dllimport) errno_t __cdecl strcpy_s([SA_Pre(Null=SA_No,WritableElements="_SizeInBytes")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char * _Dst, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _SizeInBytes, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Src);
 namespace std {
class __declspec(dllimport) exception
{	
public:
     exception();
exception(const char *const&);
exception(const char *const&, int);
exception(const exception&);
exception&  operator=(const exception&);
virtual  ~exception();
virtual const char *  what() const;
private:
const char *_m_what;
int _m_doFree;
};
using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;
typedef void (__cdecl *_Prhand)(const exception&);
__declspec(dllimport) bool __cdecl uncaught_exception();
}
 
namespace std {
		
class bad_exception : public exception
{	
public:
bad_exception(const char *_Message = "bad exception")
throw ()
: exception(_Message)
{	
}
	virtual  ~bad_exception() throw ()
{	
}
 
	};
static const char * _bad_alloc_Message = "bad allocation";
		
class bad_alloc : public exception
{	
public:
bad_alloc(const char *_Message) throw ()
: exception(_Message)
{	
}
	 bad_alloc() throw ()
: exception(_bad_alloc_Message, 1)
{	
}
	virtual  ~bad_alloc() throw ()
{	
}
 
	};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
  
namespace std {
		
typedef void (__cdecl * new_handler) ();
 
 
struct nothrow_t
{	
};
extern const nothrow_t nothrow;	
		
__declspec(dllimport) new_handler __cdecl set_new_handler([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] new_handler)
throw ();	
}
		
void __cdecl operator delete(void *) throw ();
#pragma warning (suppress: 4985)
[returnvalue:SA_Post(Null=SA_No,WritableBytes="_Size")] void *__cdecl operator new(size_t _Size) throw (...);
 
inline void *__cdecl operator new(size_t, void *_Where) throw ()
{	
return (_Where);
}
inline void __cdecl operator delete(void *, void *) throw ()
{	
}
 
inline void *__cdecl operator new[](size_t, void *_Where) throw ()
{	
return (_Where);
}
inline void __cdecl operator delete[](void *, void *) throw ()
{	
}
void __cdecl operator delete[](void *) throw ();	
[returnvalue:SA_Post(Null=SA_No,WritableBytes="_Size")] void *__cdecl operator new[](size_t _Size)
throw (...);	
 
[returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_Size")] void *__cdecl operator new(size_t _Size, const std::nothrow_t&)
throw ();
[returnvalue:SA_Post(Null=SA_Maybe,WritableBytes="_Size")] void *__cdecl operator new[](size_t _Size, const std::nothrow_t&)
throw ();	
void __cdecl operator delete(void *, const std::nothrow_t&)
throw ();	
void __cdecl operator delete[](void *, const std::nothrow_t&)
throw ();	
 
using std::new_handler;
 
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4100)
 
 
 
 
 
 
namespace std {
template<class _Ty> inline
_Ty  *_Allocate(size_t _Count, _Ty  *)
{	
if (_Count <= 0)
_Count = 0;
else if (((size_t)(-1) / _Count) < sizeof (_Ty))
throw std::bad_alloc(0);
		
return ((_Ty  *)::operator new(_Count * sizeof (_Ty)));
}
		
template<class _T1,
class _T2> inline
void _Construct(_T1  *_Ptr, const _T2& _Val)
{	
void  *_Vptr = _Ptr;
::new (_Vptr) _T1(_Val);
}
		
template<class _Ty> inline
void _Destroy(_Ty  *_Ptr)
{	
(_Ptr)->~_Ty();
}
template<> inline
void _Destroy(char  *)
{	
}
template<> inline
void _Destroy(wchar_t  *)
{	
}
		
template<class _Ty>
struct _Allocator_base
{	
typedef _Ty value_type;
};
		
template<class _Ty>
struct _Allocator_base<const _Ty>
{	
typedef _Ty value_type;
};
		
template<class _Ty>
class allocator
: public _Allocator_base<_Ty>
{	
public:
typedef _Allocator_base<_Ty> _Mybase;
typedef typename _Mybase::value_type value_type;
typedef value_type  *pointer;
typedef value_type & reference;
typedef const value_type  *const_pointer;
typedef const value_type & const_reference;
	typedef size_t size_type;
typedef ptrdiff_t difference_type;
	template<class _Other>
struct rebind
{	
typedef allocator<_Other> other;
};
	pointer address(reference _Val) const
{	
return (&_Val);
}
	const_pointer address(const_reference _Val) const
{	
return (&_Val);
}
	allocator() throw ()
{	
}
	allocator(const allocator<_Ty>&) throw ()
{	
}
	template<class _Other>
allocator(const allocator<_Other>&) throw ()
{	
}
	template<class _Other>
allocator<_Ty>& operator=(const allocator<_Other>&)
{	
return (*this);
}
	void deallocate(pointer _Ptr, size_type)
{	
::operator delete(_Ptr);
}
	pointer allocate(size_type _Count)
{	
return (_Allocate(_Count, (pointer)0));
}
	pointer allocate(size_type _Count, const void  *)
{	
return (allocate(_Count));
}
	void construct(pointer _Ptr, const _Ty& _Val)
{	
_Construct(_Ptr, _Val);
}
	void destroy(pointer _Ptr)
{	
_Destroy(_Ptr);
}
	size_t max_size() const throw ()
{	
size_t _Count = (size_t)(-1) / sizeof (_Ty);
return (0 < _Count ? _Count : 1);
}
};
		
template<class _Ty,
class _Other> inline
bool operator==(const allocator<_Ty>&, const allocator<_Other>&) throw ()
{	
return (true);
}
template<class _Ty,
class _Other> inline
bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) throw ()
{	
return (false);
}
		
template<> class __declspec(dllimport) allocator<void>
{	
public:
typedef void _Ty;
typedef _Ty  *pointer;
typedef const _Ty  *const_pointer;
typedef _Ty value_type;
	template<class _Other>
struct rebind
{	
typedef allocator<_Other> other;
};
	allocator() throw ()
{	
}
	allocator(const allocator<_Ty>&) throw ()
{	
}
	template<class _Other>
allocator(const allocator<_Other>&) throw ()
{	
}
	template<class _Other>
allocator<_Ty>& operator=(const allocator<_Other>&)
{	
return (*this);
}
};
		
template<class _Alloc> inline
void _Destroy_range(typename _Alloc::pointer _First,
typename _Alloc::pointer _Last, _Alloc& _Al)
{	
_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
}
template<class _Alloc> inline
void _Destroy_range(typename _Alloc::pointer _First,
typename _Alloc::pointer _Last, _Alloc& _Al,
_Nonscalar_ptr_iterator_tag)
{	
for (; _First != _Last; ++_First)
_Al.destroy(_First);
}
template<class _Alloc> inline
void _Destroy_range(typename _Alloc::pointer _First,
typename _Alloc::pointer _Last, _Alloc& _Al,
_Scalar_ptr_iterator_tag)
{	
}
}
 #pragma warning(default: 4100)
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Ty> inline
pair<_Ty  *, ptrdiff_t>
get_temporary_buffer(ptrdiff_t _Count)
{	
_Ty  *_Pbuf;
	if (_Count <= 0)
_Count = 0;
else if (((size_t)(-1) / _Count) < sizeof (_Ty))
throw std::bad_alloc(0);
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
if ((_Pbuf = (_Ty  *)operator new(
(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
break;
	return (pair<_Ty  *, ptrdiff_t>(_Pbuf, _Count));
}
		
template<class _Ty> inline
void return_temporary_buffer(_Ty *_Pbuf)
{	
operator delete(_Pbuf);
}
		
template<class _InIt,
class _FwdIt> inline
_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
_FwdIt _Next = _Dest;
	try {
for (; _First != _Last; ++_Dest, ++_First)
_Construct(&*_Dest, *_First);
} catch (...) {
for (; _Next != _Dest; ++_Next)
_Destroy(&*_Next);
throw;
}
return (_Dest);
}
template<class _Ty1,
class _Ty2> inline
_Ty2 _Uninit_copy(_Ty1 _First, _Ty1 _Last, _Ty2 _Dest,
_Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
size_t _Count = (size_t)(_Last - _First);
_Ty2 _Result = _Dest + _Count;
if (_Count > 0)
::memmove_s((&*_Dest), (_Count * sizeof (*_First)), (&*_First), (_Count * sizeof (*_First)));	
return _Result;
}
template<class _InIt,
class _FwdIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
{	
return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdElem, size_t _Size>
inline
_FwdElem* uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size])
{	
return (uninitialized_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt,
class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
{	
return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
		
template<class _InIt,
class _FwdIt,
class _Alloc> inline
_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
_FwdIt _Next = _Dest;
	try {
for (; _First != _Last; ++_Dest, ++_First)
_Al.construct(_Dest, *_First);
} catch (...) {
for (; _Next != _Dest; ++_Next)
_Al.destroy(_Next);
throw;
}
return (_Dest);
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
size_t _Count = (size_t)(_Last - _First);
_FwdIt _Result = _Dest + _Count;
if (_Count > 0)
::memmove_s((&*_Dest), (_Count * sizeof (*_First)), (&*_First), (_Count * sizeof (*_First)));	
return _Result;
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
_Alloc& _Al)
{	
return (_Uninitialized_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (_Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
_Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
		
template<class _InIt, class _FwdIt, class _Alloc, class _MoveCatTy>
inline
_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al, _MoveCatTy, _Range_checked_iterator_tag)
{	
return ::stdext:: unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);
}
template<class _InIt, class _FwdIt, class _Alloc>
inline
_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al, _Swap_move_tag, _Range_checked_iterator_tag)
{	
;
;
_FwdIt _Next = _Dest;
	typename _Alloc::value_type _Val;
	try {
for (; _First != _Last; ++_Dest, ++_First)
{
_Al.construct(_Dest, _Val);
::std:: swap(*_Dest, *_First);
}
} catch (...) {
for (; _Next != _Dest; ++_Next)
_Al.destroy(_Next);
throw;
}
return (_Dest);
}
template<class _InIt, class _FwdIt, class _Alloc>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (_Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
_Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* _Uninitialized_move(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
_Alloc& _Al)
{	
return (_Uninitialized_move(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
}
template<class _InIt, class _FwdIt, class _Alloc>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (_Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
_Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
    
template<class _FwdIt,
class _Tval> inline
void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
_Nonscalar_ptr_iterator_tag)
{	
;
_FwdIt _Next = _First;
	try {
for (; _First != _Last; ++_First)
_Construct(&*_First, _Val);
} catch (...) {
for (; _Next != _First; ++_Next)
_Destroy(&*_Next);
throw;
}
}
template<class _Ty,
class _Tval> inline
void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
_Scalar_ptr_iterator_tag)
{	
std::fill(_First, _Last, _Val);
}
template<class _FwdIt,
class _Tval> inline
void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
{	
_Uninit_fill(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Ptr_cat(_First, _First));
}
		
template<class _FwdIt,
class _Diff,
class _Tval> inline
void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
_Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
 
	_FwdIt _Next = _First;
	try {
for (; 0 < _Count; --_Count, ++_First)
_Construct(&*_First, _Val);
} catch (...) {
for (; _Next != _First; ++_Next)
_Destroy(&*_Next);
throw;
}
}
template<class _FwdIt,
class _Diff,
class _Tval> inline
void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
_Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
::stdext:: unchecked_fill_n(&*_First, _Count, _Val);
}
template<class _FwdIt,
class _Diff,
class _Tval> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
{	
_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdElem, class _Diff, class _Tval, size_t _Size>
inline
void uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count, const _Tval& _Val)
{	
uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val);
}
template<class _FwdIt,
class _Diff,
class _Tval> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
{	
_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc& _Al, _Nonscalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
 
	_FwdIt _Next = _First;
	try {
for (; 0 < _Count; --_Count, ++_First)
_Al.construct(_First, _Val);
} catch (...) {
for (; _Next != _First; ++_Next)
_Al.destroy(_Next);
throw;
}
}
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc&, _Scalar_ptr_iterator_tag, _Range_checked_iterator_tag)
{	
::stdext:: unchecked_fill_n(_First, _Count, _Val);
}
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
_Uninit_fill_n(_First, _Count, _Val, _Al,
_Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdElem, class _Diff, class _Tval, class _Alloc, size_t _Size>
inline
void _Uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
_Uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val, _Al);
}
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
_Uninit_fill_n(_First, _Count, _Val, _Al,
_Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt,
class _Ty>
class raw_storage_iterator
: public _Outit
{	
public:
typedef _FwdIt iterator_type;	
typedef _FwdIt iter_type;	
typedef _Ty element_type;	
	explicit raw_storage_iterator(_FwdIt _First)
: _Next(_First)
{	
}
	raw_storage_iterator<_FwdIt, _Ty>& operator*()
{	
return (*this);
}
	raw_storage_iterator<_FwdIt, _Ty>& operator=(const _Ty& _Val)
{	
_Construct(&*_Next, _Val);
return (*this);
}
	raw_storage_iterator<_FwdIt, _Ty>& operator++()
{	
++_Next;
return (*this);
}
	raw_storage_iterator<_FwdIt, _Ty> operator++(int)
{	
raw_storage_iterator<_FwdIt, _Ty> _Ans = *this;
++_Next;
return (_Ans);
}
private:
_FwdIt _Next;	
};
		
template<class _Ty>
class _Temp_iterator
: public _Outit
{	
public:
typedef _Ty  *_Pty;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	_Temp_iterator(ptrdiff_t _Count = 0)
{	
_Buf._Begin = 0;
_Buf._Current = 0;
_Buf._Hiwater = 0;
_Buf._Size = _Count;	
_Pbuf = &_Buf;
}
	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
{	
_Buf._Begin = 0;	
_Buf._Current = 0;
_Buf._Hiwater = 0;
_Buf._Size = 0;
*this = _Right;
}
	~_Temp_iterator()
{	
if (_Buf._Begin != 0)
{	
for (_Pty _Next = _Buf._Begin;
_Next != _Buf._Hiwater; ++_Next)
_Destroy(&*_Next);
std::return_temporary_buffer(_Buf._Begin);
}
}
	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
{	
_Pbuf = _Right._Pbuf;
return (*this);
}
	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
{	
if (_Pbuf->_Current < _Pbuf->_Hiwater)
*_Pbuf->_Current++ = _Val;	
else
{	
{ if (!((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
_Pty _Ptr = &*_Pbuf->_Current;
_Construct(_Ptr, _Val);
_Pbuf->_Hiwater = ++_Pbuf->_Current;
}
return (*this);
}
	_Temp_iterator<_Ty>& operator*()
{	
return (*this);
}
	_Temp_iterator<_Ty>& operator++()
{	
return (*this);
}
	_Temp_iterator<_Ty>& operator++(int)
{	
return (*this);
}
	_Temp_iterator<_Ty>& _Init()
{	
_Pbuf->_Current = _Pbuf->_Begin;
return (*this);
}
	_Pty _First() const
{	
return (_Pbuf->_Begin);
}
	_Pty _Last() const
{	
return (_Pbuf->_Current);
}
	ptrdiff_t _Maxlen()
{	
if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
{	
pair<_Pty, ptrdiff_t> _Pair =
std::get_temporary_buffer<_Ty>(_Pbuf->_Size);
			_Pbuf->_Begin = _Pair.first;
_Pbuf->_Current = _Pair.first;
_Pbuf->_Hiwater = _Pair.first;
_Pbuf->_Size = _Pair.second;
}
return (_Pbuf->_Size);
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid _Temp_iterator<T> argument");
}
private:
struct _Bufpar
{	
_Pty _Begin;	
_Pty _Current;	
_Pty _Hiwater;	
ptrdiff_t _Size;	
};
_Bufpar _Buf;	
_Bufpar *_Pbuf;	
};
		
template<class _Ty>
class auto_ptr;
template<class _Ty>
struct auto_ptr_ref
{	
explicit auto_ptr_ref(_Ty *_Right)
: _Ref(_Right)
{	
}
	_Ty *_Ref;	
};
template<class _Ty>
class auto_ptr
{	
public:
typedef _Ty element_type;
	explicit auto_ptr(_Ty *_Ptr = 0) throw ()
: _Myptr(_Ptr)
{	
}
	auto_ptr(auto_ptr<_Ty>& _Right) throw ()
: _Myptr(_Right.release())
{	
}
	auto_ptr(auto_ptr_ref<_Ty> _Right) throw ()
{	
_Ty *_Ptr = _Right._Ref;
_Right._Ref = 0;	
_Myptr = _Ptr;	
}
	template<class _Other>
operator auto_ptr<_Other>() throw ()
{	
return (auto_ptr<_Other>(*this));
}
	template<class _Other>
operator auto_ptr_ref<_Other>() throw ()
{	
_Other *_Cvtptr = _Myptr;	
auto_ptr_ref<_Other> _Ans(_Cvtptr);
_Myptr = 0;	
return (_Ans);
}
	template<class _Other>
auto_ptr<_Ty>& operator=(auto_ptr<_Other>& _Right) throw ()
{	
reset(_Right.release());
return (*this);
}
	template<class _Other>
auto_ptr(auto_ptr<_Other>& _Right) throw ()
: _Myptr(_Right.release())
{	
}
	auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Right) throw ()
{	
reset(_Right.release());
return (*this);
}
	auto_ptr<_Ty>& operator=(auto_ptr_ref<_Ty> _Right) throw ()
{	
_Ty *_Ptr = _Right._Ref;
_Right._Ref = 0;	
reset(_Ptr);	
return (*this);
}
	~auto_ptr()
{	
if (_Myptr != 0)
delete _Myptr;
}
	_Ty& operator*() const throw ()
{	
 
		;
		return (*get());
}
	_Ty *operator->() const throw ()
{	
 
		return (get());
}
	_Ty *get() const throw ()
{	
return (_Myptr);
}
	_Ty *release() throw ()
{	
_Ty *_Tmp = _Myptr;
_Myptr = 0;
return (_Tmp);
}
	void reset(_Ty* _Ptr = 0)
{	
if (_Ptr != _Myptr && _Myptr != 0)
delete _Myptr;
_Myptr = _Ptr;
}
private:
_Ty *_Myptr;	
};
}
namespace stdext {
template<class _InIt,
class _FwdIt> inline
_FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
{	
return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _FwdIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
{	
return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdElem, size_t _Size>
inline
_FwdElem* checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size])
{	
return (checked_uninitialized_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt,
class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
{	
return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
_FwdIt unchecked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
_Alloc& _Al)
{	
return (checked_uninitialized_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result checked_uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (::std:: _Uninit_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
::std:: _Ptr_cat(_First, _Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _FwdIt,
class _Alloc> inline
_FwdIt _Unchecked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (::std:: _Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdIt, class _Alloc>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (::std:: _Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _FwdElem, class _Alloc, size_t _Size>
inline
_FwdElem* _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdElem (&_Dest)[_Size],
_Alloc& _Al)
{	
return (_Checked_uninitialized_move(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Al).base());
}
template<class _InIt, class _FwdIt, class _Alloc>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, _FwdIt >::_Result _Checked_uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
_Alloc& _Al)
{	
return (::std:: _Uninit_move(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Al,
::std:: _Move_cat(_Dest), ::std:: _Range_checked_iterator_tag()));
}
template<class _FwdIt,
class _Diff,
class _Tval> inline
void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
{	
::std:: _Uninit_fill_n(_First, _Count, _Val, ::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt,
class _Diff,
class _Tval> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
{	
::std:: _Uninit_fill_n(_First, _Count, _Val, ::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdElem, class _Diff, class _Tval, size_t _Size>
inline
void checked_uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count, const _Tval& _Val)
{	
checked_uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val);
}
template<class _FwdIt,
class _Diff,
class _Tval> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
{	
::std:: _Uninit_fill_n(_First, _Count, _Val, ::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
void unchecked_uninitialized_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
::std:: _Uninit_fill_n(_First, _Count, _Val, _Al,
::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
::std:: _Uninit_fill_n(_First, _Count, _Val, _Al,
::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdElem, class _Diff, class _Tval, class _Alloc, size_t _Size>
inline
void checked_uninitialized_fill_n(_FwdElem (&_First)[_Size], _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
checked_uninitialized_fill_n(::stdext:: make_checked_array_iterator(_First, _Size), _Count, _Val, _Al);
}
template<class _FwdIt,
class _Diff,
class _Tval,
class _Alloc> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt >::_Result, void >::_Result checked_uninitialized_fill_n(_FwdIt _First, _Diff _Count,
const _Tval& _Val, _Alloc& _Al)
{	
::std:: _Uninit_fill_n(_First, _Count, _Val, _Al,
::std:: _Ptr_cat(_First, _First), ::std:: _Range_checked_iterator_tag());
}
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
 
namespace std {
  #pragma warning(disable:4251)
template<class _Elem,
class _Traits = char_traits<_Elem>,
class _Ax = allocator<_Elem> >
class basic_string;
		
template<class _Elem,
class _Traits,
class _Alloc>
class _String_const_iterator
: public _Ranit_base<_Elem, typename _Alloc::difference_type,
typename _Alloc::const_pointer, typename _Alloc::const_reference, _Iterator_base_secure>
{	
public:
typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Myt;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystring;
	typedef random_access_iterator_tag iterator_category;
typedef _Elem value_type;
typedef typename _Alloc::difference_type difference_type;
typedef typename _Alloc::const_pointer pointer;
typedef typename _Alloc::const_reference reference;
typedef _Elem* _Inner_type;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	typedef pointer _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
return _Myptr;
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
this->_Myptr = _Base;
}
	 _String_const_iterator()
{	
_Myptr = 0;
}
 
 
_String_const_iterator(pointer _Ptr, const _Container_base_secure *_Pstring)
{	
{ if (!(_Pstring != 0 && _Ptr != 0 && ((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Mycont = _Pstring;
_Myptr = _Ptr;
}
 
	reference  operator*() const
{	
 
		if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)(this->_Mycont))->_Mysize))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
		return (*_Myptr);
}
	pointer  operator->() const
{	
return (&**this);
}
	_Myt&  operator++()
{	
if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr < (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
++_Myptr;
return (*this);
}
	_Myt  operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt&  operator--()
{	
if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr > ((_Mystring *)this->_Mycont)->_Myptr())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
--_Myptr;
return (*this);
}
	_Myt  operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt&  operator+=(difference_type _Off)
{	
if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr + _Off <= (((_Mystring *)this->_Mycont)->_Myptr() + ((_Mystring *)this->_Mycont)->_Mysize) && _Myptr + _Off >= ((_Mystring *)this->_Mycont)->_Myptr())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
_Myptr += _Off;
return (*this);
}
	_Myt  operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt&  operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Myt  operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type  operator-(const _Myt& _Right) const
{	
 
		if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
		return (_Myptr - _Right._Myptr);
}
	reference  operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
	bool  operator==(const _Myt& _Right) const
{	
 
		if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
		return (_Myptr == _Right._Myptr);
}
	bool  operator!=(const _Myt& _Right) const
{	
return (!(*this == _Right));
}
	bool  operator<(const _Myt& _Right) const
{	
 
		if (this->_Mycont != ((const _Container_base_secure *)-4))
{
{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
		return (_Myptr < _Right._Myptr);
}
	bool  operator>(const _Myt& _Right) const
{	
return (_Right < *this);
}
	bool  operator<=(const _Myt& _Right) const
{	
return (!(_Right < *this));
}
	bool  operator>=(const _Myt& _Right) const
{	
return (!(*this < _Right));
}
 
	static void __cdecl _Xlen()
{
_Mystring::_Xlen();
}
	static void __cdecl _Xran()
{
_Mystring::_Xran();
}
	static void __cdecl _Xinvarg()
{
_Mystring::_Xinvarg();
}
	pointer _Myptr;	
};
template<class _Elem,
class _Traits,
class _Alloc> inline
_String_const_iterator<_Elem, _Traits, _Alloc> __cdecl operator+(
typename _String_const_iterator<_Elem, _Traits, _Alloc>
::difference_type _Off,
_String_const_iterator<_Elem, _Traits, _Alloc> _Next)
{	
return (_Next += _Off);
}
		
template<class _Elem,
class _Traits,
class _Alloc>
class _String_iterator
: public _String_const_iterator<_Elem, _Traits, _Alloc>
{	
public:
typedef _String_iterator<_Elem, _Traits, _Alloc> _Myt;
typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Mybase;
	typedef random_access_iterator_tag iterator_category;
typedef _Elem value_type;
typedef typename _Alloc::difference_type difference_type;
typedef typename _Alloc::pointer pointer;
typedef typename _Alloc::reference reference;
	 _String_iterator()
{	
}
 
 
_String_iterator(pointer _Ptr, const _Container_base_secure *_Pstring)
: _Mybase(_Ptr, _Pstring)
{	
}
 
	typedef pointer _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
return const_cast<pointer>(this->_Myptr);
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
this->_Myptr = _Base;
}
	reference  operator*() const
{	
return ((reference)**(_Mybase *)this);
}
	pointer  operator->() const
{	
return (&**this);
}
	_Myt&  operator++()
{	
++(*(_Mybase *)this);
return (*this);
}
	_Myt  operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt&  operator--()
{	
--(*(_Mybase *)this);
return (*this);
}
	_Myt  operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt&  operator+=(difference_type _Off)
{	
(*(_Mybase *)this) += _Off;
return (*this);
}
	_Myt  operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt&  operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Myt  operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type  operator-(const _Mybase& _Right) const
{	
return ((_Mybase)*this - _Right);
}
	reference  operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
};
template<class _Elem,
class _Traits,
class _Alloc> inline
_String_iterator<_Elem, _Traits, _Alloc>  operator+(
typename _String_iterator<_Elem, _Traits, _Alloc>
::difference_type _Off,
_String_iterator<_Elem, _Traits, _Alloc> _Next)
{	
return (_Next += _Off);
}
		
class __declspec(dllimport) _String_base
: public _Container_base_secure
{	
public:
static void __cdecl _Xlen();	
	 static void __cdecl _Xran();	
	 static void __cdecl _Xinvarg();
};
		
template<class _Ty,
class _Alloc>
class _String_val
: public _String_base
{	
protected:
typedef typename _Alloc::template
rebind<_Ty>::other _Alty;
	 _String_val(_Alty _Al = _Alty())
: _Alval(_Al)
{	
}
public:
_String_val(const _String_val &_Right)
: _Alval(_Right._Alval)
{	
		}
protected:
_Alty _Alval;	
};
		
template<class _Elem,
class _Traits,
class _Ax>
class basic_string
: public _String_val<_Elem, _Ax>
{	
public:
typedef basic_string<_Elem, _Traits, _Ax> _Myt;
typedef _String_val<_Elem, _Ax> _Mybase;
typedef typename _Mybase::_Alty _Alloc;
typedef typename _Alloc::size_type size_type;
typedef typename _Alloc::difference_type _Dift;
typedef _Dift difference_type;
typedef typename _Alloc::pointer _Tptr;
typedef typename _Alloc::const_pointer _Ctptr;
typedef _Tptr pointer;
typedef _Ctptr const_pointer;
typedef typename _Alloc::reference _Reft;
typedef _Reft reference;
typedef typename _Alloc::const_reference const_reference;
typedef typename _Alloc::value_type value_type;
	typedef _String_iterator<_Elem, _Traits, _Alloc> iterator;
typedef _String_const_iterator<_Elem, _Traits, _Alloc> const_iterator;
	friend class _String_const_iterator<_Elem, _Traits, _Alloc>;
	typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    
    
    
    
    
  
 
 
	 basic_string()
: _Mybase()
{	
_Tidy();
}
 
 
	explicit  basic_string(const _Alloc& _Al)
: _Mybase(_Al)
{	
_Tidy();
}
	 basic_string(const _Myt& _Right, size_type _Roff,
size_type _Count = npos)
: _Mybase()
{	
		_Tidy();
assign(_Right, _Roff, _Count);
}
	 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
const _Alloc& _Al)
: _Mybase(_Al)
{	
		_Tidy();
assign(_Right, _Roff, _Count);
}
	 basic_string(const _Elem *_Ptr, size_type _Count)
: _Mybase()
{	
_Tidy();
assign(_Ptr, _Count);
}
	 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
: _Mybase(_Al)
{	
_Tidy();
assign(_Ptr, _Count);
}
	 basic_string(const _Elem *_Ptr)
: _Mybase()
{	
_Tidy();
assign(_Ptr);
}
	 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
: _Mybase(_Al)
{	
_Tidy();
assign(_Ptr);
}
	 basic_string(size_type _Count, _Elem _Ch)
: _Mybase()
{	
_Tidy();
assign(_Count, _Ch);
}
	 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
: _Mybase(_Al)
{	
_Tidy();
assign(_Count, _Ch);
}
	template<class _It>
basic_string(_It _First, _It _Last)
: _Mybase()
{	
_Tidy();
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _It>
basic_string(_It _First, _It _Last, const _Alloc& _Al)
: _Mybase(_Al)
{	
_Tidy();
_Construct(_First, _Last, _Iter_cat(_First));
}
	 basic_string(const_pointer _First, const_pointer _Last)
: _Mybase()
{	
		_Tidy();
if (_First != _Last)
assign(&*_First, _Last - _First);
}
	 basic_string(const_iterator _First, const_iterator _Last)
: _Mybase()
{	
		_Tidy();
if (_First != _Last)
assign(&*_First, _Last - _First);
}
 
	
	 basic_string(const _Myt& _Right)
: _Mybase(_Right)
{	
_Tidy();
assign(_Right, 0, npos);
}
 
	template<class _It>
void  _Construct(_It _Count,
_It _Ch, _Int_iterator_tag)
{	
assign((size_type)_Count, (_Elem)_Ch);
}
	template<class _It>
void  _Construct(_It _First,
_It _Last, input_iterator_tag)
{	
try {
for (; _First != _Last; ++_First)
append((size_type)1, (_Elem)*_First);
} catch (...) {
_Tidy(true);
throw;
}
}
	template<class _It>
void  _Construct(_It _First,
_It _Last, forward_iterator_tag)
{	
		size_type _Count = 0;
_Distance(_First, _Last, _Count);
reserve(_Count);
		try {
for (; _First != _Last; ++_First)
append((size_type)1, (_Elem)*_First);
} catch (...) {
_Tidy(true);
throw;
}
}
	 ~basic_string()
{	
_Tidy(true);
}
	typedef _Traits traits_type;
typedef _Alloc allocator_type;
	 static const size_type npos;	
	_Myt&  operator=(const _Myt& _Right)
{	
return (assign(_Right));
}
	_Myt&  operator=(const _Elem *_Ptr)
{	
return (assign(_Ptr));
}
	_Myt&  operator=(_Elem _Ch)
{	
return (assign(1, _Ch));
}
	_Myt&  operator+=(const _Myt& _Right)
{	
return (append(_Right));
}
	_Myt&  operator+=(const _Elem *_Ptr)
{	
return (append(_Ptr));
}
	_Myt&  operator+=(_Elem _Ch)
{	
return (append((size_type)1, _Ch));
}
	_Myt&  append(const _Myt& _Right)
{	
return (append(_Right, 0, npos));
}
	_Myt&  append(const _Myt& _Right,
size_type _Roff, size_type _Count)
{	
if (_Right.size() < _Roff)
_String_base::_Xran();	
size_type _Num = _Right.size() - _Roff;
if (_Num < _Count)
_Count = _Num;	
if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)
_String_base::_Xlen();	
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
{	
_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
_Right._Myptr() + _Roff, _Count);
_Eos(_Num);
}
return (*this);
}
	_Myt&  append(const _Elem *_Ptr, size_type _Count)
{	
 
		if (_Inside(_Ptr))
return (append(*this, _Ptr - _Myptr(), _Count));	
if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)
_String_base::_Xlen();	
		size_type _Num;
if (0 < _Count && _Grow(_Num = _Mysize + _Count))
{	
_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);
_Eos(_Num);
}
return (*this);
}
	_Myt&  append(const _Elem *_Ptr)
{	
;
return (append(_Ptr, _Traits::length(_Ptr)));
}
	_Myt&  append(size_type _Count, _Elem _Ch)
{	
if (npos - _Mysize <= _Count)
_String_base::_Xlen();	
		size_type _Num;
if (0 < _Count && _Grow(_Num = _Mysize + _Count))
{	
_Chassign(_Mysize, _Count, _Ch);
_Eos(_Num);
}
return (*this);
}
	template<class _It>
_Myt&  append(_It _First, _It _Last)
{	
return (_Append(_First, _Last, _Iter_cat(_First)));
}
	template<class _It>
_Myt&  _Append(_It _Count, _It _Ch, _Int_iterator_tag)
{	
return (append((size_type)_Count, (_Elem)_Ch));
}
	template<class _It>
_Myt&  _Append(_It _First, _It _Last, input_iterator_tag)
{	
return (replace(end(), end(), _First, _Last));
}
	_Myt&  append(const_pointer _First, const_pointer _Last)
{	
return (replace(end(), end(), _First, _Last));
}
	_Myt&  append(const_iterator _First, const_iterator _Last)
{	
return (replace(end(), end(), _First, _Last));
}
	_Myt&  assign(const _Myt& _Right)
{	
return (assign(_Right, 0, npos));
}
	_Myt&  assign(const _Myt& _Right,
size_type _Roff, size_type _Count)
{	
if (_Right.size() < _Roff)
_String_base::_Xran();	
size_type _Num = _Right.size() - _Roff;
if (_Count < _Num)
_Num = _Count;	
		if (this == &_Right)
erase((size_type)(_Roff + _Num)), erase(0, _Roff);	
else if (_Grow(_Num))
{	
_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);
_Eos(_Num);
}
return (*this);
}
	_Myt&  assign(const _Elem *_Ptr, size_type _Count)
{	
 
		if (_Inside(_Ptr))
return (assign(*this, _Ptr - _Myptr(), _Count));	
		if (_Grow(_Count))
{	
_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Count);
_Eos(_Count);
}
return (*this);
}
	_Myt&  assign(const _Elem *_Ptr)
{	
;
return (assign(_Ptr, _Traits::length(_Ptr)));
}
	_Myt&  assign(size_type _Count, _Elem _Ch)
{	
if (_Count == npos)
_String_base::_Xlen();	
		if (_Grow(_Count))
{	
_Chassign(0, _Count, _Ch);
_Eos(_Count);
}
return (*this);
}
	template<class _It>
_Myt&  assign(_It _First, _It _Last)
{	
return (_Assign(_First, _Last, _Iter_cat(_First)));
}
	template<class _It>
_Myt&  _Assign(_It _Count, _It _Ch, _Int_iterator_tag)
{	
return (assign((size_type)_Count, (_Elem)_Ch));
}
	template<class _It>
_Myt&  _Assign(_It _First, _It _Last, input_iterator_tag)
{	
return (replace(begin(), end(), _First, _Last));
}
	_Myt&  assign(const_pointer _First, const_pointer _Last)
{	
return (replace(begin(), end(), _First, _Last));
}
	_Myt&  assign(const_iterator _First, const_iterator _Last)
{	
return (replace(begin(), end(), _First, _Last));
}
	_Myt&  insert(size_type _Off, const _Myt& _Right)
{	
return (insert(_Off, _Right, 0, npos));
}
	_Myt&  insert(size_type _Off,
const _Myt& _Right, size_type _Roff, size_type _Count)
{	
if (_Mysize < _Off || _Right.size() < _Roff)
_String_base::_Xran();	
size_type _Num = _Right.size() - _Roff;
if (_Num < _Count)
_Count = _Num;	
if (npos - _Mysize <= _Count)
_String_base::_Xlen();	
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off, _Mysize - _Off);	
if (this == &_Right)
_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
_Count);	
else
_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Right._Myptr() + _Roff, _Count);	
_Eos(_Num);
}
return (*this);
}
	_Myt&  insert(size_type _Off,
const _Elem *_Ptr, size_type _Count)
{	
 
		if (_Inside(_Ptr))
return (insert(_Off, *this,
_Ptr - _Myptr(), _Count));	
if (_Mysize < _Off)
_String_base::_Xran();	
if (npos - _Mysize <= _Count)
_String_base::_Xlen();	
size_type _Num;
if (0 < _Count && _Grow(_Num = _Mysize + _Count))
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off, _Mysize - _Off);	
_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Ptr, _Count);	
_Eos(_Num);
}
return (*this);
}
	_Myt&  insert(size_type _Off, const _Elem *_Ptr)
{	
;
return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
}
	_Myt&  insert(size_type _Off,
size_type _Count, _Elem _Ch)
{	
if (_Mysize < _Off)
_String_base::_Xran();	
if (npos - _Mysize <= _Count)
_String_base::_Xlen();	
size_type _Num;
if (0 < _Count && _Grow(_Num = _Mysize + _Count))
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off, _Mysize - _Off);	
_Chassign(_Off, _Count, _Ch);	
_Eos(_Num);
}
return (*this);
}
	iterator  insert(const_iterator _Where)
{	
return (insert(_Where, _Elem()));
}
	iterator  insert(const_iterator _Where, _Elem _Ch)
{	
size_type _Off = _Pdif(_Where, begin());
insert(_Off, 1, _Ch);
return (begin() + _Off);
}
	void  insert(const_iterator _Where, size_type _Count, _Elem _Ch)
{	
size_type _Off = _Pdif(_Where, begin());
insert(_Off, _Count, _Ch);
}
	template<class _It>
void  insert(const_iterator _Where, _It _First, _It _Last)
{	
_Insert(_Where, _First, _Last, _Iter_cat(_First));
}
	template<class _It>
void  _Insert(const_iterator _Where, _It _Count, _It _Ch,
_Int_iterator_tag)
{	
insert(_Where, (size_type)_Count, (_Elem)_Ch);
}
	template<class _It>
void  _Insert(const_iterator _Where, _It _First, _It _Last,
input_iterator_tag)
{	
replace(_Where, _Where, _First, _Last);
}
	void  insert(const_iterator _Where, const_pointer _First, const_pointer _Last)
{	
replace(_Where, _Where, _First, _Last);
}
	void  insert(const_iterator _Where, const_iterator _First, const_iterator _Last)
{	
replace(_Where, _Where, _First, _Last);
}
	_Myt&  erase(size_type _Off = 0,
size_type _Count = npos)
{	
if (_Mysize < _Off)
_String_base::_Xran();	
if (_Mysize - _Off < _Count)
_Count = _Mysize - _Off;	
if (0 < _Count)
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
_Mysize - _Off - _Count);
size_type _Newsize = _Mysize - _Count;
_Eos(_Newsize);
}
return (*this);
}
	iterator  erase(const_iterator _Where)
{	
size_type _Count = _Pdif(_Where, begin());
erase(_Count, 1);
return (iterator(_Myptr() + _Count, this));
}
	iterator  erase(const_iterator _First, const_iterator _Last)
{	
size_type _Count = _Pdif(_First, begin());
erase(_Count, _Pdif(_Last, _First));
return (iterator(_Myptr() + _Count, this));
}
	void  clear()
{	
erase(begin(), end());
}
	_Myt&  replace(size_type _Off, size_type _N0, const _Myt& _Right)
{	
return (replace(_Off, _N0, _Right, 0, npos));
}
	_Myt&  replace(size_type _Off,
size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
{	
if (_Mysize < _Off || _Right.size() < _Roff)
_String_base::_Xran();	
if (_Mysize - _Off < _N0)
_N0 = _Mysize - _Off;	
size_type _Num = _Right.size() - _Roff;
if (_Num < _Count)
_Count = _Num;	
if (npos - _Count <= _Mysize - _N0)
_String_base::_Xlen();	
		size_type _Nm = _Mysize - _N0 - _Off;	
size_type _Newsize = _Mysize + _Count - _N0;
if (_Mysize < _Newsize)
_Grow(_Newsize);
		if (this != &_Right)
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Right._Myptr() + _Roff, _Count);	
}
else if (_Count <= _N0)
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Myptr() + _Roff, _Count);	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
}
else if (_Roff <= _Off)
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Myptr() + _Roff, _Count);	
}
else if (_Off + _N0 <= _Roff)
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Myptr() + (_Roff + _Count - _N0), _Count);	
}
else
{	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off,
_Myptr() + _Roff, _N0);	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _N0, _Myres - _Off - _N0, _Myptr() + _Roff + _Count,
_Count - _N0);	
}
		_Eos(_Newsize);
return (*this);
}
	_Myt&  replace(size_type _Off,
size_type _N0, const _Elem *_Ptr, size_type _Count)
{	
 
		if (_Inside(_Ptr))
return (replace(_Off, _N0, *this,
_Ptr - _Myptr(), _Count));	
if (_Mysize < _Off)
_String_base::_Xran();	
if (_Mysize - _Off < _N0)
_N0 = _Mysize - _Off;	
if (npos - _Count <= _Mysize - _N0)
_String_base::_Xlen();	
size_type _Nm = _Mysize - _N0 - _Off;
		if (_Count < _N0)
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
size_type _Num;
if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
{	
if (_N0 < _Count)
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
_Traits_helper::copy_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Ptr, _Count);	
_Eos(_Num);
}
return (*this);
}
	_Myt&  replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
{	
;
return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
}
	_Myt&  replace(size_type _Off,
size_type _N0, size_type _Count, _Elem _Ch)
{	
if (_Mysize < _Off)
_String_base::_Xran();	
if (_Mysize - _Off < _N0)
_N0 = _Mysize - _Off;	
if (npos - _Count <= _Mysize - _N0)
_String_base::_Xlen();	
size_type _Nm = _Mysize - _N0 - _Off;
		if (_Count < _N0)
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
size_type _Num;
if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
{	
if (_N0 < _Count)
_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
_Myptr() + _Off + _N0, _Nm);	
_Chassign(_Off, _Count, _Ch);	
_Eos(_Num);
}
return (*this);
}
	_Myt&  replace(const_iterator _First, const_iterator _Last, const _Myt& _Right)
{	
return (replace(
_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
}
	_Myt&  replace(const_iterator _First, const_iterator _Last, const _Elem *_Ptr,
size_type _Count)
{	
return (replace(
_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
}
	_Myt&  replace(const_iterator _First, const_iterator _Last, const _Elem *_Ptr)
{	
return (replace(
_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
}
	_Myt&  replace(const_iterator _First, const_iterator _Last,
size_type _Count, _Elem _Ch)
{	
return (replace(
_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
}
	template<class _It>
_Myt&  replace(const_iterator _First, const_iterator _Last,
_It _First2, _It _Last2)
{	
return (_Replace(_First, _Last,
_First2, _Last2, _Iter_cat(_First2)));
}
	template<class _It>
_Myt&  _Replace(const_iterator _First, const_iterator _Last,
_It _Count, _It _Ch, _Int_iterator_tag)
{	
return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));
}
	template<class _It>
_Myt&  _Replace(const_iterator _First, const_iterator _Last,
_It _First2, _It _Last2, input_iterator_tag)
{	
_Myt _Right(_First2, _Last2);
replace(_First, _Last, _Right);
return (*this);
}
	_Myt&  replace(const_iterator _First, const_iterator _Last,
const_pointer _First2, const_pointer _Last2)
{	
if (_First2 == _Last2)
erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
else
replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
&*_First2, _Last2 - _First2);
return (*this);
}
	_Myt&  replace(const_iterator _First, const_iterator _Last,
const_iterator _First2, const_iterator _Last2)
{	
if (_First2 == _Last2)
erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
else
replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
&*_First2, _Last2 - _First2);
return (*this);
}
	iterator  begin()
{	
return (iterator(_Myptr(), this));
}
	const_iterator  begin() const
{	
return (const_iterator(_Myptr(), this));
}
	iterator  end()
{	
return (iterator(_Myptr() + _Mysize, this));
}
	const_iterator  end() const
{	
return (const_iterator(_Myptr() + _Mysize, this));
}
	reverse_iterator  rbegin()
{	
return (reverse_iterator(end()));
}
	const_reverse_iterator  rbegin() const
{	
return (const_reverse_iterator(end()));
}
	reverse_iterator  rend()
{	
return (reverse_iterator(begin()));
}
	const_reverse_iterator  rend() const
{	
return (const_reverse_iterator(begin()));
}
	reference  at(size_type _Off)
{	
if (_Mysize <= _Off)
_String_base::_Xran();	
return (_Myptr()[_Off]);
}
	const_reference  at(size_type _Off) const
{	
if (_Mysize <= _Off)
_String_base::_Xran();	
return (_Myptr()[_Off]);
}
 
	reference  operator[](size_type _Off)
{	
 
		{ if (!(_Off <= _Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (_Myptr()[_Off]);
}
	const_reference  operator[](size_type _Off) const
{	
 
		{ if (!(_Off <= _Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (_Myptr()[_Off]);
}
 
 
  
 
	void  push_back(_Elem _Ch)
{	
insert(end(), _Ch);
}
	const _Elem * c_str() const
{	
return (_Myptr());
}
	const _Elem * data() const
{	
return (c_str());
}
	size_type  length() const
{	
return (_Mysize);
}
	size_type  size() const
{	
return (_Mysize);
}
	size_type  max_size() const
{	
size_type _Num = _Mybase::_Alval.max_size();
return (_Num <= 1 ? 1 : _Num - 1);
}
	void  resize(size_type _Newsize)
{	
resize(_Newsize, _Elem());
}
	void  resize(size_type _Newsize, _Elem _Ch)
{	
if (_Newsize <= _Mysize)
erase(_Newsize);
else
append(_Newsize - _Mysize, _Ch);
}
	size_type  capacity() const
{	
return (_Myres);
}
	void  reserve(size_type _Newcap = 0)
{	
if (_Mysize <= _Newcap && _Myres != _Newcap)
{	
size_type _Size = _Mysize;
if (_Grow(_Newcap, true))
_Eos(_Size);
}
}
	bool  empty() const
{	
return (_Mysize == 0);
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
size_type  copy(_Elem *_Dest,
size_type _Count, size_type _Off = 0) const
{	
 
		
return _Copy_s(_Dest, _Count, _Count, _Off);
}
	size_type  _Copy_s(_Elem *_Dest, size_type _Dest_size,
size_type _Count, size_type _Off = 0) const
{	
;
if (_Mysize < _Off)
_String_base::_Xran();	
if (_Mysize - _Off < _Count)
_Count = _Mysize - _Off;
_Traits_helper::copy_s<_Traits>(_Dest, _Dest_size, _Myptr() + _Off, _Count);
return (_Count);
}
	void  swap(_Myt& _Right)
{	
if (this == &_Right)
;	
else if (_Mybase::_Alval == _Right._Alval)
{	
 
			_Bxty _Tbx = _Bx;
_Bx = _Right._Bx, _Right._Bx = _Tbx;
			size_type _Tlen = _Mysize;
_Mysize = _Right._Mysize, _Right._Mysize = _Tlen;
			size_type _Tres = _Myres;
_Myres = _Right._Myres, _Right._Myres = _Tres;
}
else
{	
_Myt _Tmp = *this;
			*this = _Right;
_Right = _Tmp;
}
}
	size_type  find(const _Myt& _Right, size_type _Off = 0) const
{	
return (find(_Right._Myptr(), _Off, _Right.size()));
}
	size_type  find(const _Elem *_Ptr,
size_type _Off, size_type _Count) const
{	
 
		if (_Count == 0 && _Off <= _Mysize)
return (_Off);	
		size_type _Nm;
if (_Off < _Mysize && _Count <= (_Nm = _Mysize - _Off))
{	
const _Elem *_Uptr, *_Vptr;
for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;
(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
return (_Uptr - _Myptr());	
}
		return (npos);	
}
	size_type  find(const _Elem *_Ptr, size_type _Off = 0) const
{	
;
return (find(_Ptr, _Off, _Traits::length(_Ptr)));
}
	size_type  find(_Elem _Ch, size_type _Off = 0) const
{	
return (find((const _Elem *)&_Ch, _Off, 1));
}
	size_type  rfind(const _Myt& _Right, size_type _Off = npos) const
{	
return (rfind(_Right._Myptr(), _Off, _Right.size()));
}
	size_type  rfind(const _Elem *_Ptr,
size_type _Off, size_type _Count) const
{	
 
		if (_Count == 0)
return (_Off < _Mysize ? _Off : _Mysize);	
if (_Count <= _Mysize)
{	
const _Elem *_Uptr = _Myptr() +
(_Off < _Mysize - _Count ? _Off : _Mysize - _Count);
for (; ; --_Uptr)
if (_Traits::eq(*_Uptr, *_Ptr)
&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
return (_Uptr - _Myptr());	
else if (_Uptr == _Myptr())
break;	
}
		return (npos);	
}
	size_type  rfind(const _Elem *_Ptr, size_type _Off = npos) const
{	
;
return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
}
	size_type  rfind(_Elem _Ch, size_type _Off = npos) const
{	
return (rfind((const _Elem *)&_Ch, _Off, 1));
}
	size_type  find_first_of(const _Myt& _Right,
size_type _Off = 0) const
{	
return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
}
	size_type  find_first_of(const _Elem *_Ptr,
size_type _Off, size_type _Count) const
{	
 
		if (0 < _Count && _Off < _Mysize)
{	
const _Elem *const _Vptr = _Myptr() + _Mysize;
for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
return (_Uptr - _Myptr());	
}
		return (npos);	
}
	size_type  find_first_of(const _Elem *_Ptr, size_type _Off = 0) const
{	
;
return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
}
	size_type  find_first_of(_Elem _Ch, size_type _Off = 0) const
{	
return (find((const _Elem *)&_Ch, _Off, 1));
}
	size_type  find_last_of(const _Myt& _Right,
size_type _Off = npos) const
{	
return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
}
	size_type  find_last_of(const _Elem *_Ptr,
size_type _Off, size_type _Count) const
{	
 
		if (0 < _Count && 0 < _Mysize)
for (const _Elem *_Uptr = _Myptr()
+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
return (_Uptr - _Myptr());	
else if (_Uptr == _Myptr())
break;	
		return (npos);	
}
	size_type  find_last_of(const _Elem *_Ptr,
size_type _Off = npos) const
{	
;
return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
}
	size_type  find_last_of(_Elem _Ch, size_type _Off = npos) const
{	
return (rfind((const _Elem *)&_Ch, _Off, 1));
}
	size_type  find_first_not_of(const _Myt& _Right,
size_type _Off = 0) const
{	
return (find_first_not_of(_Right._Myptr(), _Off,
_Right.size()));
}
	size_type  find_first_not_of(const _Elem *_Ptr,
size_type _Off, size_type _Count) const
{	
 
		if (_Off < _Mysize)
{	
const _Elem *const _Vptr = _Myptr() + _Mysize;
for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
return (_Uptr - _Myptr());
}
return (npos);
}
	size_type  find_first_not_of(const _Elem *_Ptr,
size_type _Off = 0) const
{	
;
return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
}
	size_type  find_first_not_of(_Elem _Ch, size_type _Off = 0) const
{	
return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
}
	size_type  find_last_not_of(const _Myt& _Right,
size_type _Off = npos) const
{	
return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
}
	size_type  find_last_not_of(const _Elem *_Ptr,
size_type _Off, size_type _Count) const
{	
 
		if (0 < _Mysize)
for (const _Elem *_Uptr = _Myptr()
+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
return (_Uptr - _Myptr());
else if (_Uptr == _Myptr())
break;
return (npos);
}
	size_type  find_last_not_of(const _Elem *_Ptr,
size_type _Off = npos) const
{	
;
return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
}
	size_type  find_last_not_of(_Elem _Ch, size_type _Off = npos) const
{	
return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
}
	_Myt  substr(size_type _Off = 0, size_type _Count = npos) const
{	
return (_Myt(*this, _Off, _Count, get_allocator()));
}
	int  compare(const _Myt& _Right) const
{	
return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));
}
	int  compare(size_type _Off, size_type _N0,
const _Myt& _Right) const
{	
return (compare(_Off, _N0, _Right, 0, npos));
}
	int  compare(size_type _Off,
size_type _N0, const _Myt& _Right,
size_type _Roff, size_type _Count) const
{	
if (_Right.size() < _Roff)
_String_base::_Xran();	
if (_Right._Mysize - _Roff < _Count)
_Count = _Right._Mysize - _Roff;	
return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
}
	int  compare(const _Elem *_Ptr) const
{	
;
return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));
}
	int  compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
{	
;
return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
}
	int  compare(size_type _Off,
size_type _N0, const _Elem *_Ptr, size_type _Count) const
{	
 
		if (_Mysize < _Off)
_String_base::_Xran();	
if (_Mysize - _Off < _N0)
_N0 = _Mysize - _Off;	
		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,
_N0 < _Count ? _N0 : _Count);
return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
: _N0 == _Count ? 0 : +1);
}
	allocator_type  get_allocator() const
{	
return (_Mybase::_Alval);
}
	enum
{	
_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1
: 16 / sizeof(_Elem)};
protected:
enum
{	
_ALLOC_MASK = sizeof (_Elem) <= 1 ? 15
: sizeof (_Elem) <= 2 ? 7
: sizeof (_Elem) <= 4 ? 3
: sizeof (_Elem) <= 8 ? 1 : 0};
	void  _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
{	
if (_Count == 1)
_Traits::assign(*(_Myptr() + _Off), _Ch);
else
_Traits::assign(_Myptr() + _Off, _Count, _Ch);
}
	void  _Copy(size_type _Newsize, size_type _Oldlen)
{	
size_type _Newres = _Newsize | _ALLOC_MASK;
if (max_size() < _Newres)
_Newres = _Newsize;	
else if (_Newres / 3 < _Myres / 2
&& _Myres <= max_size() - _Myres / 2)
_Newres = _Myres + _Myres / 2;	
_Elem *_Ptr = 0;
		try {
_Ptr = _Mybase::_Alval.allocate(_Newres + 1);
} catch (...) {
_Newres = _Newsize;	
try {
_Ptr = _Mybase::_Alval.allocate(_Newres + 1);
} catch (...) {
_Tidy(true);	
throw;
}
}
		if (0 < _Oldlen)
_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	
_Tidy(true);
_Bx._Ptr = _Ptr;
_Myres = _Newres;
_Eos(_Oldlen);
}
	void  _Eos(size_type _Newsize)
{	
_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());
}
	bool  _Grow(size_type _Newsize,
bool _Trim = false)
{	
if (max_size() < _Newsize)
_String_base::_Xlen();	
if (_Myres < _Newsize)
_Copy(_Newsize, _Mysize);	
else if (_Trim && _Newsize < _BUF_SIZE)
_Tidy(true,	
_Newsize < _Mysize ? _Newsize : _Mysize);
else if (_Newsize == 0)
_Eos(0);	
return (0 < _Newsize);	
}
	bool  _Inside(const _Elem *_Ptr)
{	
if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)
return (false);	
else
return (true);
}
	static size_type __cdecl _Pdif(const_iterator _P2,
const_iterator _P1)
{	
return ((_P2)._Myptr == 0 ? 0 : _P2 - _P1);
}
	void  _Tidy(bool _Built = false,
size_type _Newsize = 0)
{	
if (!_Built)
;
else if (_BUF_SIZE <= _Myres)
{	
_Elem *_Ptr = _Bx._Ptr;
if (0 < _Newsize)
_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);
_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);
}
_Myres = _BUF_SIZE - 1;
_Eos(_Newsize);
}
	union _Bxty
{	
_Elem _Buf[_BUF_SIZE];
_Elem *_Ptr;
} _Bx;
	_Elem * _Myptr()
{	
return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
}
	const _Elem * _Myptr() const
{	
return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
}
	size_type _Mysize;	
size_type _Myres;	
};
	
template<class _Elem, class _Traits, class _Ax>
class _Move_operation_category<basic_string<_Elem, _Traits, _Ax> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
		
template<class _Elem,
class _Traits,
class _Alloc>
const typename basic_string<_Elem, _Traits, _Alloc>::size_type
basic_string<_Elem, _Traits, _Alloc>::npos =
(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
		
template<class _Elem,
class _Traits,
class _Alloc> inline
void __cdecl swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
typedef basic_string<char, char_traits<char>, allocator<char> >
string;
typedef basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> > wstring;
 
template class __declspec(dllimport) allocator<char>;
template class __declspec(dllimport) allocator<wchar_t>;
template class __declspec(dllimport) _String_val<char, allocator<char> >;
template class __declspec(dllimport) _String_val<wchar_t, allocator<wchar_t> >;
template class __declspec(dllimport) basic_string<char, char_traits<char>,
allocator<char> >;
template class __declspec(dllimport) basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >;
 
}
 #pragma warning(default: 4251)
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
class logic_error
: public std:: exception
{	
public:
explicit  logic_error(const string& _Message)
: _Str(_Message)
{	
}
	virtual  ~logic_error() throw ()
{	
}
	virtual const char * what() const throw ()
{	
return (_Str.c_str());
}
 
private:
string _Str;	
};
		
class domain_error
: public logic_error
{	
public:
explicit  domain_error(const string& _Message)
: logic_error(_Message)
{	
}
	virtual  ~domain_error() throw ()
{	
}
 
	};
		
class invalid_argument
: public logic_error
{	
public:
explicit  invalid_argument(const string& _Message)
: logic_error(_Message)
{	
}
	virtual  ~invalid_argument() throw ()
{	
}
 
	};
		
class length_error
: public logic_error
{	
public:
explicit  length_error(const string& _Message)
: logic_error(_Message)
{	
}
	virtual  ~length_error() throw ()
{	
}
 
	};
		
class out_of_range
: public logic_error
{	
public:
explicit  out_of_range(const string& _Message)
: logic_error(_Message)
{	
}
	virtual  ~out_of_range() throw ()
{	
}
 
	};
		
class runtime_error
: public std:: exception
{	
public:
explicit  runtime_error(const string& _Message)
: _Str(_Message)
{	
}
	virtual  ~runtime_error() throw ()
{	
}
	virtual const char * what() const throw ()
{	
return (_Str.c_str());
}
 
private:
string _Str;	
};
		
class overflow_error
: public runtime_error
{	
public:
explicit  overflow_error(const string& _Message)
: runtime_error(_Message)
{	
}
	virtual  ~overflow_error() throw ()
{	
}
 
	};
		
class underflow_error
: public runtime_error
{	
public:
explicit  underflow_error(const string& _Message)
: runtime_error(_Message)
{	
}
	virtual  ~underflow_error() throw ()
{	
}
 
	};
		
class range_error
: public runtime_error
{	
public:
explicit  range_error(const string& _Message)
: runtime_error(_Message)
{	
}
	virtual  ~range_error() throw ()
{	
}
 
	};
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4244)
namespace std {
template<class _Ty,
class _Ax = allocator<_Ty> >
class vector;
		
template<class _Ty,
class _Alloc>
class _Vector_const_iterator
: public _Ranit<_Ty, typename _Alloc::difference_type,
typename _Alloc::const_pointer, typename _Alloc::const_reference>
{	
public:
typedef _Vector_const_iterator<_Ty, _Alloc> _Myt;
typedef vector<_Ty, _Alloc> _Myvec;
typedef typename _Alloc::pointer _Tptr;
	typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef typename _Alloc::difference_type difference_type;
typedef typename _Alloc::const_pointer pointer;
typedef typename _Alloc::const_reference reference;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	typedef pointer _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
return _Myptr;
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
this->_Myptr = const_cast<_Tptr>(_Base);
}
	
	
	typedef _Tptr _Inner_type;
	_Vector_const_iterator()
{	
_Myptr = 0;
}
 
	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)
{	
{ if (!(_Pvector != 0 && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Set_container(_Pvector);
_Myptr = _Ptr;
}
 
	reference operator*() const
{	
 
 		{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (*_Myptr);
}
	pointer operator->() const
{	
return (&**this);
}
	_Myt& operator++()
{	
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
 
		++_Myptr;
return (*this);
}
	_Myt operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt& operator--()
{	
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
 
		--_Myptr;
return (*this);
}
	_Myt operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt& operator+=(difference_type _Off)
{	
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast && _Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
_Myptr += _Off;
return (*this);
}
	_Myt operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Myt operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const _Myt& _Right) const
{	
 
		{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (_Myptr - _Right._Myptr);
}
	reference operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
	bool operator==(const _Myt& _Right) const
{	
 
		{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (_Myptr == _Right._Myptr);
}
	bool operator!=(const _Myt& _Right) const
{	
return (!(*this == _Right));
}
	bool operator<(const _Myt& _Right) const
{	
 
		{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (_Myptr < _Right._Myptr);
}
	bool operator>(const _Myt& _Right) const
{	
return (_Right < *this);
}
	bool operator<=(const _Myt& _Right) const
{	
return (!(_Right < *this));
}
	bool operator>=(const _Myt& _Right) const
{	
return (!(*this < _Right));
}
 
	static void _Xlen()
{	
throw length_error("vector<T> too long");
}
	static void _Xran()
{	
throw out_of_range("invalid vector<T> subscript");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid vector<T> argument");
}
	_Tptr _Myptr;	
};
template<class _Ty,
class _Alloc> inline
_Vector_const_iterator<_Ty, _Alloc> operator+(
typename _Vector_const_iterator<_Ty, _Alloc>::difference_type _Off,
_Vector_const_iterator<_Ty, _Alloc> _Next)
{	
return (_Next += _Off);
}
		
template<class _Ty,
class _Alloc>
class _Vector_iterator
: public _Vector_const_iterator<_Ty, _Alloc>
{	
public:
typedef _Vector_iterator<_Ty, _Alloc> _Myt;
typedef _Vector_const_iterator<_Ty, _Alloc> _Mybase;
	typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef typename _Alloc::difference_type difference_type;
typedef typename _Alloc::pointer pointer;
typedef typename _Alloc::reference reference;
	typedef pointer _Checked_iterator_base_type;
	_Checked_iterator_base_type _Checked_iterator_base() const
{
return this->_Myptr;
}
	void _Checked_iterator_assign_from_base(_Checked_iterator_base_type _Base)
{
this->_Myptr = _Base;
}
	_Vector_iterator()
{	
}
 
	_Vector_iterator(pointer _Ptr, const _Container_base *_Pvector)
: _Mybase(_Ptr, _Pvector)
{	
}
 
	reference operator*() const
{	
return ((reference)**(_Mybase *)this);
}
	pointer operator->() const
{	
return (&**this);
}
	_Myt& operator++()
{	
++(*(_Mybase *)this);
return (*this);
}
	_Myt operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt& operator--()
{	
--(*(_Mybase *)this);
return (*this);
}
	_Myt operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt& operator+=(difference_type _Off)
{	
(*(_Mybase *)this) += _Off;
return (*this);
}
	_Myt operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Myt operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const _Mybase& _Right) const
{	
return (*(_Mybase *)this - _Right);
}
	reference operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
};
template<class _Ty,
class _Alloc> inline
_Vector_iterator<_Ty, _Alloc> operator+(
typename _Vector_iterator<_Ty, _Alloc>::difference_type _Off,
_Vector_iterator<_Ty, _Alloc> _Next)
{	
return (_Next += _Off);
}
		
template<class _Ty,
class _Alloc>
class _Vector_val
: public _Container_base_aux_alloc_real<_Alloc>
{	
protected:
_Vector_val(_Alloc _Al = _Alloc())
: _Container_base_aux_alloc_real<_Alloc>(_Al), _Alval(_Al)
{	
}
	typedef typename _Alloc::template
rebind<_Ty>::other _Alty;
	_Alty _Alval;	
};
		
template<class _Ty,
class _Ax>
class vector
: public _Vector_val<_Ty, _Ax>
{	
public:
typedef vector<_Ty, _Ax> _Myt;
typedef _Vector_val<_Ty, _Ax> _Mybase;
typedef typename _Mybase::_Alty _Alloc;
typedef _Alloc allocator_type;
typedef typename _Alloc::size_type size_type;
typedef typename _Alloc::difference_type _Dift;
typedef _Dift difference_type;
typedef typename _Alloc::pointer _Tptr;
typedef typename _Alloc::const_pointer _Ctptr;
typedef _Tptr pointer;
typedef _Ctptr const_pointer;
typedef typename _Alloc::reference _Reft;
typedef _Reft reference;
typedef typename _Alloc::const_reference const_reference;
typedef typename _Alloc::value_type value_type;
  
	typedef _Vector_iterator<_Ty, _Alloc> iterator;
typedef _Vector_const_iterator<_Ty, _Alloc> const_iterator;
	friend class _Vector_const_iterator<_Ty, _Alloc>;
	typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	vector()
: _Mybase()
{	
_Buy(0);
}
	explicit vector(const _Alloc& _Al)
: _Mybase(_Al)
{	
_Buy(0);
}
	explicit vector(size_type _Count)
: _Mybase()
{	
_Construct_n(_Count, _Ty());
}
	vector(size_type _Count, const _Ty& _Val)
: _Mybase()
{	
_Construct_n(_Count, _Val);
}
	vector(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
: _Mybase(_Al)
{	
_Construct_n(_Count, _Val);
}
	vector(const _Myt& _Right)
: _Mybase(_Right._Alval)
{	
if (_Buy(_Right.size()))
try {
_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);
} catch (...) {
_Tidy();
throw;
}
}
	template<class _Iter>
vector(_Iter _First, _Iter _Last)
: _Mybase()
{	
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
: _Mybase(_Al)
{	
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
{	
size_type _Size = (size_type)_Count;
_Construct_n(_Size, (_Ty)_Val);
}
	template<class _Iter>
void _Construct(_Iter _First,
_Iter _Last, input_iterator_tag)
{	
_Buy(0);
try {
insert(begin(), _First, _Last);
} catch (...) {
_Tidy();
throw;
}
}
	void _Construct_n(size_type _Count, const _Ty& _Val)
{	
if (_Buy(_Count))
{	
try {
_Mylast = _Ufill(_Myfirst, _Count, _Val);
} catch (...) {
_Tidy();
throw;
}
}
}
	~vector()
{	
_Tidy();
}
	_Myt& operator=(const _Myt& _Right)
{	
if (this != &_Right)
{	
 
			if (_Right.size() == 0)
clear();	
else if (_Right.size() <= size())
{	
pointer _Ptr = ::stdext:: unchecked_copy(_Right._Myfirst, _Right._Mylast,
_Myfirst);	
_Destroy(_Ptr, _Mylast);	
_Mylast = _Myfirst + _Right.size();
}
else if (_Right.size() <= capacity())
{	
pointer _Ptr = _Right._Myfirst + size();
::stdext:: unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);
_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);
}
else
{	
if (_Myfirst != 0)
{	
_Destroy(_Myfirst, _Mylast);
this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
}
if (_Buy(_Right.size()))
_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
_Myfirst);
}
}
return (*this);
}
	void reserve(size_type _Count)
{	
if (max_size() < _Count)
_Xlen();	
else if (capacity() < _Count)
{	
pointer _Ptr = this->_Alval.allocate(_Count);
			try {
_Umove(begin(), end(), _Ptr);
} catch (...) {
this->_Alval.deallocate(_Ptr, _Count);
throw;
}
			size_type _Size = size();
if (_Myfirst != 0)
{	
_Destroy(_Myfirst, _Mylast);
this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
}
 
			_Myend = _Ptr + _Count;
_Mylast = _Ptr + _Size;
_Myfirst = _Ptr;
}
}
	size_type capacity() const
{	
return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);
}
 
iterator begin()
{	
return (iterator(_Myfirst, this));
}
	const_iterator begin() const
{	
return (const_iterator(_Myfirst, this));
}
	iterator end()
{	
return (iterator(_Mylast, this));
}
	const_iterator end() const
{	
return (const_iterator(_Mylast, this));
}
	iterator _Make_iter(const_iterator _Where) const
{	
return (iterator(_Where._Myptr, this));
}
 
	reverse_iterator rbegin()
{	
return (reverse_iterator(end()));
}
	const_reverse_iterator rbegin() const
{	
return (const_reverse_iterator(end()));
}
	reverse_iterator rend()
{	
return (reverse_iterator(begin()));
}
	const_reverse_iterator rend() const
{	
return (const_reverse_iterator(begin()));
}
	void resize(size_type _Newsize)
{	
resize(_Newsize, _Ty());
}
	void resize(size_type _Newsize, _Ty _Val)
{	
if (size() < _Newsize)
_Insert_n(end(), _Newsize - size(), _Val);
else if (_Newsize < size())
erase(begin() + _Newsize, end());
}
	size_type size() const
{	
return (_Mylast - _Myfirst);
}
	size_type max_size() const
{	
return (this->_Alval.max_size());
}
	bool empty() const
{	
return (size() == 0);
}
	_Alloc get_allocator() const
{	
return (this->_Alval);
}
	const_reference at(size_type _Pos) const
{	
if (size() <= _Pos)
_Xran();
return (*(begin() + _Pos));
}
	reference at(size_type _Pos)
{	
if (size() <= _Pos)
_Xran();
return (*(begin() + _Pos));
}
	const_reference operator[](size_type _Pos) const
{	
 
		{ if (!(_Pos < size())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (*(_Myfirst + _Pos));
}
	reference operator[](size_type _Pos)
{	
 
		{ if (!(_Pos < size())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (*(_Myfirst + _Pos));
}
	reference front()
{	
return (*begin());
}
	const_reference front() const
{	
return (*begin());
}
	reference back()
{	
return (*(end() - 1));
}
	const_reference back() const
{	
return (*(end() - 1));
}
	void push_back(const _Ty& _Val)
{	
if (size() < capacity())
 
			_Mylast = _Ufill(_Mylast, 1, _Val);
		else
insert(end(), _Val);
}
 
	void pop_back()
{	
if (!empty())
{	
_Destroy(_Mylast - 1, _Mylast);
--_Mylast;
}
}
	template<class _Iter>
void assign(_Iter _First, _Iter _Last)
{	
_Assign(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
{	
_Assign_n((size_type)_Count, (_Ty)_Val);
}
	template<class _Iter>
void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
{	
erase(begin(), end());
insert(begin(), _First, _Last);
}
	void assign(size_type _Count, const _Ty& _Val)
{	
_Assign_n(_Count, _Val);
}
	iterator insert(const_iterator _Where, const _Ty& _Val)
{	
size_type _Off = size() == 0 ? 0 : _Where - begin();
_Insert_n(_Where, (size_type)1, _Val);
return (begin() + _Off);
}
	void insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
{	
_Insert_n(_Where, _Count, _Val);
}
	template<class _Iter>
void insert(const_iterator _Where, _Iter _First, _Iter _Last)
{	
_Insert(_Where, _First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
_Int_iterator_tag)
{	
_Insert_n(_Where, (size_type)_First, (_Ty)_Last);
}
	template<class _Iter>
void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
input_iterator_tag)
{	
 
		if (_First != _Last)
{	
size_type _Oldsize = size();
size_type _Whereoff = _Where._Myptr - _Myfirst;
			for (; _First != _Last; ++_First)
_Insert_n(end(), (size_type)1, (value_type)*_First);
			_Reverse(_Myfirst + _Whereoff, _Myfirst + _Oldsize);
_Reverse(_Myfirst + _Oldsize, _Mylast);
_Reverse(_Myfirst + _Whereoff, _Mylast);
}
}
	template<class _Iter>
void _Insert(const_iterator _Where,
_Iter _First, _Iter _Last, forward_iterator_tag)
{	
 
		size_type _Count = 0;
_Distance(_First, _Last, _Count);
size_type _Capacity = capacity();
		if (_Count == 0)
;
else if (max_size() - size() < _Count)
_Xlen();	
else if (_Capacity < size() + _Count)
{	
_Capacity = max_size() - _Capacity / 2 < _Capacity
? 0 : _Capacity + _Capacity / 2;	
if (_Capacity < size() + _Count)
_Capacity = size() + _Count;
pointer _Newvec = this->_Alval.allocate(_Capacity);
pointer _Ptr = _Newvec;
			try {
_Ptr = _Umove(_Myfirst, (_Where)._Myptr,
_Newvec);	
_Ptr = _Ucopy(_First, _Last, _Ptr);	
_Umove((_Where)._Myptr, _Mylast, _Ptr);	
} catch (...) {
_Destroy(_Newvec, _Ptr);
this->_Alval.deallocate(_Newvec, _Capacity);
throw;
}
			_Count += size();
if (_Myfirst != 0)
{	
_Destroy(_Myfirst, _Mylast);
this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
}
 
			_Myend = _Newvec + _Capacity;
_Mylast = _Newvec + _Count;
_Myfirst = _Newvec;
}
else
{	
_Ucopy(_First, _Last, _Mylast);
			_Reverse(_Where._Myptr, _Mylast);
_Reverse(_Mylast, _Mylast + _Count);
_Reverse(_Where._Myptr, _Mylast + _Count);
			_Mylast += _Count;
 
			}
}
 	void _Reverse(pointer _First, pointer _Last)
{	
for (; _First != _Last && _First != --_Last; ++_First)
{	
value_type _Temp = *_First;
			*_First = *_Last;
*_Last = _Temp;
}
}
 
	iterator erase(const_iterator _Where)
{	
::stdext:: unchecked_copy((_Where)._Myptr + 1, _Mylast,
(_Where)._Myptr);
_Destroy(_Mylast - 1, _Mylast);
--_Mylast;
return (_Make_iter(_Where));
}
	iterator erase(const_iterator _First_arg,
const_iterator _Last_arg)
{	
iterator _First = _Make_iter(_First_arg);
iterator _Last = _Make_iter(_Last_arg);
		if (_First != _Last)
{	
 
			pointer _Ptr = ::stdext:: unchecked_copy((_Last)._Myptr, _Mylast,
(_First)._Myptr);
			_Destroy(_Ptr, _Mylast);
_Mylast = _Ptr;
}
		return (_First);
		}
	void clear()
{	
erase(begin(), end());
}
	void swap(_Myt& _Right)
{	
if (this == &_Right)
;	
else if (this->_Alval == _Right._Alval)
{	
 
			this->_Swap_aux(_Right);
			std::swap(_Myfirst, _Right._Myfirst);
std::swap(_Mylast, _Right._Mylast);
std::swap(_Myend, _Right._Myend);
}
else
{	
this->_Swap_aux(_Right);
			_Myt _Ts = *this;
			*this = _Right;
_Right = _Ts;
}
}
protected:
void _Assign_n(size_type _Count, const _Ty& _Val)
{	
_Ty _Tmp = _Val;	
erase(begin(), end());
insert(begin(), _Count, _Tmp);
}
	bool _Buy(size_type _Capacity)
{	
_Myfirst = 0, _Mylast = 0, _Myend = 0;
if (_Capacity == 0)
return (false);
else if (max_size() < _Capacity)
_Xlen();	
else
{	
_Myfirst = this->_Alval.allocate(_Capacity);
_Mylast = _Myfirst;
_Myend = _Myfirst + _Capacity;
}
return (true);
}
	void _Destroy(pointer _First, pointer _Last)
{	
_Destroy_range(_First, _Last, this->_Alval);
}
	void _Tidy()
{	
if (_Myfirst != 0)
{	
 
			_Destroy(_Myfirst, _Mylast);
this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
}
_Myfirst = 0, _Mylast = 0, _Myend = 0;
}
	template<class _Iter>
pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
{	
return (::stdext:: unchecked_uninitialized_copy(_First, _Last,
_Ptr, this->_Alval));
}
	template<class _Iter>
pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
{	
return (::stdext:: _Unchecked_uninitialized_move(_First, _Last,
_Ptr, this->_Alval));
}
	void _Insert_n(const_iterator _Where,
size_type _Count, const _Ty& _Val)
{	
 
		size_type _Capacity = capacity();
		if (_Count == 0)
;
else if (max_size() - size() < _Count)
_Xlen();	
else if (_Capacity < size() + _Count)
{	
_Capacity = max_size() - _Capacity / 2 < _Capacity
? 0 : _Capacity + _Capacity / 2;	
if (_Capacity < size() + _Count)
_Capacity = size() + _Count;
pointer _Newvec = this->_Alval.allocate(_Capacity);
pointer _Ptr = _Newvec;
			try {
_Ptr = _Umove(_Myfirst, (_Where)._Myptr,
_Newvec);	
_Ptr = _Ufill(_Ptr, _Count, _Val);	
_Umove((_Where)._Myptr, _Mylast, _Ptr);	
} catch (...) {
_Destroy(_Newvec, _Ptr);
this->_Alval.deallocate(_Newvec, _Capacity);
throw;
}
			_Count += size();
if (_Myfirst != 0)
{	
_Destroy(_Myfirst, _Mylast);
this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
}
 
			_Myend = _Newvec + _Capacity;
_Mylast = _Newvec + _Count;
_Myfirst = _Newvec;
}
else if ((size_type)(_Mylast - (_Where)._Myptr) < _Count)
{	
_Ty _Tmp = _Val;	
			_Umove((_Where)._Myptr, _Mylast,
(_Where)._Myptr + _Count);	
			try {
_Ufill(_Mylast, _Count - (_Mylast - (_Where)._Myptr),
_Tmp);	
} catch (...) {
_Destroy((_Where)._Myptr + _Count, _Mylast + _Count);
throw;
}
			_Mylast += _Count;
 
			std::fill((_Where)._Myptr, _Mylast - _Count,
_Tmp);	
}
else
{	
_Ty _Tmp = _Val;	
			pointer _Oldend = _Mylast;
_Mylast = _Umove(_Oldend - _Count, _Oldend,
_Mylast);	
 
			::stdext:: _Unchecked_move_backward((_Where)._Myptr, _Oldend - _Count,
_Oldend);	
std::fill((_Where)._Myptr, (_Where)._Myptr + _Count,
_Tmp);	
}
}
	pointer _Ufill(pointer _Ptr, size_type _Count, const _Ty &_Val)
{	
::stdext:: unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);
return (_Ptr + _Count);
}
	static void _Xlen()
{	
throw length_error("vector<T> too long");
}
	static void _Xran()
{	
throw out_of_range("invalid vector<T> subscript");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid vector<T> argument");
}
 
	pointer _Myfirst;	
pointer _Mylast;	
pointer _Myend;	
};
	
template <class _Ty, class _Ax>
class _Move_operation_category<vector<_Ty, _Ax> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
		
template<class _Ty,
class _Alloc> inline
bool operator==(const vector<_Ty, _Alloc>& _Left,
const vector<_Ty, _Alloc>& _Right)
{	
return (_Left.size() == _Right.size()
&& equal(_Left.begin(), _Left.end(), _Right.begin()));
}
template<class _Ty,
class _Alloc> inline
bool operator!=(const vector<_Ty, _Alloc>& _Left,
const vector<_Ty, _Alloc>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty,
class _Alloc> inline
bool operator<(const vector<_Ty, _Alloc>& _Left,
const vector<_Ty, _Alloc>& _Right)
{	
return (lexicographical_compare(_Left.begin(), _Left.end(),
_Right.begin(), _Right.end()));
}
template<class _Ty,
class _Alloc> inline
bool operator>(const vector<_Ty, _Alloc>& _Left,
const vector<_Ty, _Alloc>& _Right)
{	
return (_Right < _Left);
}
template<class _Ty,
class _Alloc> inline
bool operator<=(const vector<_Ty, _Alloc>& _Left,
const vector<_Ty, _Alloc>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty,
class _Alloc> inline
bool operator>=(const vector<_Ty, _Alloc>& _Left,
const vector<_Ty, _Alloc>& _Right)
{	
return (!(_Left < _Right));
}
template<class _Ty,
class _Alloc> inline
void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
typedef unsigned _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	
		
template<class _Sizet,
class _Difft,
class _MycontTy>
class _Vb_iter_base
: public _Ranit<_Bool, _Difft, bool *, bool>
{	
public:
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	_Vb_iter_base()
: _Myptr(0), _Myoff(0)
{	
}
 
	_Vb_iter_base(_Vbase *_Ptr, _Sizet _Off,
const _Container_base *_Mypvbool)
: _Myptr(_Ptr), _Myoff(_Off)
{	
{ if (!(_Mypvbool != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Set_container(_Mypvbool);
}
	_Vbase *_Myptr;
_Sizet _Myoff;
	static void _Xlen()
{	
throw length_error("vector<bool> too long");
}
	static void _Xran()
{	
throw out_of_range("invalid vector<bool> subscript");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid vector<bool> argument");
}
 
_Vbase * _My_cont_begin() const
{
return (((_MycontTy *)this->_Getmycont())->_Myvec.begin())._Myptr;
}
	_Sizet _My_actual_offset() const
{
_Sizet _Off = this->_Myoff;
_Off += _VBITS * (this->_Myptr - _My_cont_begin());
return _Off;
}
	};
		
template<class _Sizet,
class _Difft,
class _MycontTy>
class _Vb_reference
: public _Vb_iter_base<_Sizet, _Difft, _MycontTy>
{	
public:
typedef _Vb_iter_base<_Sizet, _Difft, _MycontTy> _Mybase;
typedef _Vb_reference<_Sizet, _Difft, _MycontTy> _Mytype;
	_Vb_reference()
{	
}
 
_Vb_reference(const _Mybase& _Right)
: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getmycont())
{	
}
 
	_Mytype& operator=(const _Mytype& _Right)
{	
return (*this = bool(_Right));
}
	_Mytype& operator=(bool _Val)
{	
if (_Val)
*_Getptr() |= _Mask();
else
*_Getptr() &= ~_Mask();
return (*this);
}
	void flip()
{	
*_Getptr() ^= _Mask();
}
	bool operator~() const
{	
return (!bool(*this));
}
	operator bool() const
{	
return ((*_Getptr() & _Mask()) != 0);
}
	_Vbase *_Getptr() const
{	
 
 		{ if (!(this->_Has_container() && this->_Myptr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(this->_My_actual_offset() < ((_MycontTy *)this->_Getmycont())->_Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
		return (this->_Myptr);
}
protected:
_Vbase _Mask() const
{	
return ((_Vbase)(1 << this->_Myoff));
}
};
template<class _Sizet,
class _Difft,
class _MycontTy>
void swap(_Vb_reference<_Sizet, _Difft, _MycontTy> _Left,
_Vb_reference<_Sizet, _Difft, _MycontTy> _Right)
{	
bool _Val = _Left;
_Left = _Right;
_Right = _Val;
}
		
template<class _Sizet,
class _Difft,
class _MycontTy>
class _Vb_const_iterator
: public _Vb_iter_base<_Sizet, _Difft, _MycontTy>
{	
public:
typedef _Vb_iter_base<_Sizet, _Difft, _MycontTy> _Mybase;
typedef _Vb_const_iterator<_Sizet, _Difft, _MycontTy> _Mytype;
	typedef _Vb_reference<_Sizet, _Difft, _MycontTy> _Reft;
typedef bool const_reference;
	typedef random_access_iterator_tag iterator_category;
typedef _Bool value_type;
typedef _Sizet size_type;
typedef _Difft difference_type;
typedef const_reference *pointer;
typedef const_reference reference;
	_Vb_const_iterator()
{	
}
 
_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
: _Mybase((_Vbase *)_Ptr, 0, (_Container_base *)_Mypvbool)
 
		{	
}
	const_reference operator*() const
{	
return (_Reft(*this));
}
	_Mytype& operator++()
{	
_Inc();
return (*this);
}
	_Mytype operator++(int)
{	
_Mytype _Tmp = *this;
++*this;
return (_Tmp);
}
	_Mytype& operator--()
{	
_Dec();
return (*this);
}
	_Mytype operator--(int)
{	
_Mytype _Tmp = *this;
--*this;
return (_Tmp);
}
	_Mytype& operator+=(difference_type _Off)
{	
if (_Off == 0)
return (*this); 
{ if (!(this->_Has_container() && this->_Myptr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
if (_Off < 0)
{
{ if (!(this->_My_actual_offset() >= ((size_type)-_Off))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
else
{
{ if (!((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
}
if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
{	
this->_Myoff += _Off;
this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
this->_Myoff %= _VBITS;
}
else
{	
this->_Myoff += _Off;
this->_Myptr += this->_Myoff / _VBITS;
this->_Myoff %= _VBITS;
}
return (*this);
}
	_Mytype operator+(difference_type _Off) const
{	
_Mytype _Tmp = *this;
return (_Tmp += _Off);
}
	_Mytype& operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Mytype operator-(difference_type _Off) const
{	
_Mytype _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(
const _Mytype& _Right) const
{	
 
		return (_VBITS * (this->_Myptr - _Right._Myptr)
+ (difference_type)this->_Myoff
- (difference_type)_Right._Myoff);
}
	const_reference operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
	bool operator==(const _Mytype& _Right) const
{	
 
		return (this->_Myptr == _Right._Myptr
&& this->_Myoff == _Right._Myoff);
}
	bool operator!=(const _Mytype& _Right) const
{	
return (!(*this == _Right));
}
	bool operator<(const _Mytype& _Right) const
{	
 
		return (this->_Myptr < _Right._Myptr
|| this->_Myptr == _Right._Myptr
&& this->_Myoff < _Right._Myoff);
}
	bool operator>(const _Mytype& _Right) const
{	
return (_Right < *this);
}
	bool operator<=(const _Mytype& _Right) const
{	
return (!(_Right < *this));
}
	bool operator>=(const _Mytype& _Right) const
{	
return (!(*this < _Right));
}
protected:
 
	void _Dec()
{	
if (this->_Myoff != 0)
{
--this->_Myoff;
}
else
{
{ if (!(this->_Has_container() && this->_Myptr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(this->_Myptr > this->_My_cont_begin())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
--this->_Myptr;
this->_Myoff = _VBITS - 1;
}
}
	void _Inc()
{	
{ if (!(this->_Has_container() && this->_Myptr != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!((this->_My_actual_offset() + 1) <= ((_MycontTy *)this->_Getmycont())->_Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
if (this->_Myoff < _VBITS - 1)
++this->_Myoff;
else
this->_Myoff = 0, ++this->_Myptr;
}
};
template<class _Sizet,
class _Difft,
class _MycontTy>
_Vb_const_iterator<_Sizet, _Difft, _MycontTy> operator+(_Difft _Off,
_Vb_const_iterator<_Sizet, _Difft, _MycontTy> _Right)
{	
return (_Right += _Off);
}
	
template<class _Sizet,
class _Difft,
class _MycontTy>
class _Vb_iterator
: public _Vb_const_iterator<_Sizet, _Difft, _MycontTy>
{	
public:
typedef _Vb_const_iterator<_Sizet, _Difft, _MycontTy> _Mybase;
typedef _Vb_iterator<_Sizet, _Difft, _MycontTy> _Mytype;
	typedef _Vb_reference<_Sizet, _Difft, _MycontTy> _Reft;
typedef bool const_reference;
	typedef random_access_iterator_tag iterator_category;
typedef _Bool value_type;
typedef _Sizet size_type;
typedef _Difft difference_type;
typedef _Reft *pointer;
typedef _Reft reference;
	_Vb_iterator()
{	
}
 
_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
: _Mybase(_Ptr, _Mypvbool)
 
		{	
}
	reference operator*() const
{	
return (_Reft(*this));
}
	_Mytype& operator++()
{	
++*(_Mybase *)this;
return (*this);
}
	_Mytype operator++(int)
{	
_Mytype _Tmp = *this;
++*this;
return (_Tmp);
}
	_Mytype& operator--()
{	
--*(_Mybase *)this;
return (*this);
}
	_Mytype operator--(int)
{	
_Mytype _Tmp = *this;
--*this;
return (_Tmp);
}
	_Mytype& operator+=(difference_type _Off)
{	
*(_Mybase *)this += _Off;
return (*this);
}
	_Mytype operator+(difference_type _Off) const
{	
_Mytype _Tmp = *this;
return (_Tmp += _Off);
}
	_Mytype& operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Mytype operator-(difference_type _Off) const
{	
_Mytype _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const _Mybase& _Right) const
{	
return (*(_Mybase *)this - _Right);
}
	reference operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
};
template<class _Sizet,
class _Difft,
class _MycontTy>
_Vb_iterator<_Sizet, _Difft, _MycontTy> operator+(_Difft _Off,
_Vb_iterator<_Sizet, _Difft, _MycontTy> _Right)
{	
return (_Right += _Off);
}
		
template<class _Alloc>
class vector<_Bool, _Alloc>
: public _Container_base_aux_alloc_real<_Alloc>
{	
public:
typedef typename _Alloc::size_type size_type;
typedef typename _Alloc::difference_type _Dift;
typedef std::vector<_Vbase,
typename _Alloc::template rebind<_Vbase>::other>
_Vbtype;
typedef std::vector<_Bool, _Alloc> _Myt;
	typedef _Dift difference_type;
typedef _Bool _Ty;
typedef _Alloc allocator_type;
	typedef _Vb_reference<size_type, _Dift, _Myt> reference;
typedef bool const_reference;
typedef bool value_type;
	typedef reference _Reft;
typedef _Vb_const_iterator<size_type, difference_type, _Myt> const_iterator;
typedef _Vb_iterator<size_type, difference_type, _Myt> iterator;
	friend class _Vb_iter_base<size_type, difference_type, _Myt>;
friend class _Vb_reference<size_type, difference_type, _Myt>;
friend class _Vb_const_iterator<size_type, difference_type, _Myt>;
friend class _Vb_iterator<size_type, difference_type, _Myt>;
	typedef iterator pointer;
typedef const_iterator const_pointer;
typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	static const int _VBITS = std::_VBITS;
	vector()
: _Container_base_aux_alloc_real<_Alloc>(_Alloc()), _Mysize(0), _Myvec()
{	
}
	vector(const _Myt& _Right)
: _Container_base_aux_alloc_real<_Alloc>(_Right.get_allocator()), _Mysize(_Right._Mysize), _Myvec(_Right._Myvec)
{	
}
	explicit vector(const _Alloc& _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), _Mysize(0), _Myvec(_Al)
{	
}
	explicit vector(size_type _Count, bool _Val = false)
: _Container_base_aux_alloc_real<_Alloc>(_Alloc()), _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0))
{	
_Trim(_Count);
}
	vector(size_type _Count, bool _Val, const _Alloc& _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
{	
_Trim(_Count);
}
	template<class _Iter>
vector(_Iter _First, _Iter _Last)
: _Container_base_aux_alloc_real<_Alloc>(_Alloc()), _Mysize(0), _Myvec()
{	
_BConstruct(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), _Mysize(0), _Myvec(_Al)
{	
_BConstruct(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _BConstruct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
{	
size_type _Num = (size_type)_Count;
_Myvec.assign(_Num, (_Ty)_Val ? -1 : 0);
_Trim(_Num);
}
	template<class _Iter>
void _BConstruct(_Iter _First, _Iter _Last, input_iterator_tag)
{	
insert(begin(), _First, _Last);
}
	~vector()
{	
_Mysize = 0;
}
	void reserve(size_type _Count)
{	
_Myvec.reserve(_Nw(_Count));
}
	size_type capacity() const
{	
return (_Myvec.capacity() * _VBITS);
}
 
iterator begin()
{	
return (iterator((_Myvec.begin())._Myptr, this));
}
	const_iterator begin() const
{	
return (const_iterator((_Myvec.begin())._Myptr, this));
}
 
	iterator end()
{	
iterator _Tmp = begin();
if (0 < _Mysize)
_Tmp += _Mysize;
return (_Tmp);
}
	const_iterator end() const
{	
const_iterator _Tmp = begin();
if (0 < _Mysize)
_Tmp += _Mysize;
return (_Tmp);
}
	iterator _Make_iter(const_iterator _Where)
{	
iterator _Tmp = begin();
if (0 < _Mysize)
_Tmp += _Where - begin();
return (_Tmp);
}
	reverse_iterator rbegin()
{	
return (reverse_iterator(end()));
}
	const_reverse_iterator rbegin() const
{	
return (const_reverse_iterator(end()));
}
	reverse_iterator rend()
{	
return (reverse_iterator(begin()));
}
	const_reverse_iterator rend() const
{	
return (const_reverse_iterator(begin()));
}
	void resize(size_type _Newsize, bool _Val = false)
{	
if (size() < _Newsize)
_Insert_n(end(), _Newsize - size(), _Val);
else if (_Newsize < size())
erase(begin() + _Newsize, end());
}
	size_type size() const
{	
return (_Mysize);
}
	size_type max_size() const
{	
const size_type _Maxsize = _Myvec.max_size();
return (_Maxsize < (size_type)(-1) / _VBITS
? _Maxsize * _VBITS : (size_type)(-1));
}
	bool empty() const
{	
return (size() == 0);
}
	_Alloc get_allocator() const
{	
		_Alloc _Alret = _Myvec.get_allocator();
return _Alret;
}
	const_reference at(size_type _Off) const
{	
if (size() <= _Off)
_Xran();
return (*(begin() + _Off));
}
	reference at(size_type _Off)
{	
if (size() <= _Off)
_Xran();
return (*(begin() + _Off));
}
	const_reference operator[](size_type _Off) const
{	
return (*(begin() + _Off));
}
	reference operator[](size_type _Off)
{	
return (*(begin() + _Off));
}
	reference front()
{	
return (*begin());
}
	const_reference front() const
{	
return (*begin());
}
	reference back()
{	
return (*(end() - 1));
}
	const_reference back() const
{	
return (*(end() - 1));
}
	void push_back(bool _Val)
{	
insert(end(), _Val);
}
	void pop_back()
{	
if (!empty())
erase(end() - 1);
}
	template<class _Iter>
void assign(_Iter _First, _Iter _Last)
{	
_Assign(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
{	
_Assign_n((size_type)_Count, (bool)_Val);
}
	template<class _Iter>
void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
{	
erase(begin(), end());
insert(begin(), _First, _Last);
}
	void assign(size_type _Count, bool _Val)
{	
_Assign_n(_Count, _Val);
}
	iterator insert(const_iterator _Where, bool _Val)
{	
size_type _Off = _Where - begin();
_Insert_n(_Where, (size_type)1, _Val);
return (begin() + _Off);
}
	void insert(const_iterator _Where, size_type _Count, bool _Val)
{	
_Insert_n(_Where, _Count, _Val);
}
	template<class _Iter>
void insert(const_iterator _Where, _Iter _First, _Iter _Last)
{	
_Insert(_Where, _First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Insert(const_iterator _Where, _Iter _Count, _Iter _Val,
_Int_iterator_tag)
{	
_Insert_n(_Where, (size_type)_Count, (bool)_Val);
}
	template<class _Iter>
void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
input_iterator_tag)
{	
size_type _Off = _Where - begin();
		for (; _First != _Last; ++_First, ++_Off)
insert(begin() + _Off, *_First);
}
	template<class _Iter>
void _Insert(const_iterator _Where,
_Iter _First, _Iter _Last,
forward_iterator_tag)
{	
 
		size_type _Count = 0;
_Distance(_First, _Last, _Count);
		size_type _Off = _Insert_x(_Where, _Count);
std::copy(_First, _Last, begin() + _Off);
}
	iterator erase(const_iterator _Where_arg)
{	
iterator _Where = _Make_iter(_Where_arg);
size_type _Off = _Where - begin();
 
		std::copy(_Where + 1, end(), _Where);
		_Trim(_Mysize - 1);
return (begin() + _Off);
}
	iterator erase(const_iterator _First_arg, const_iterator _Last_arg)
{	
iterator _First = _Make_iter(_First_arg);
iterator _Last = _Make_iter(_Last_arg);
size_type _Off = _First - begin();
 
		iterator _Next = std::copy(_Last, end(), _First);
_Trim(_Next - begin());
		return (begin() + _Off);
}
	void clear()
{	
erase(begin(), end());
}
	void flip()
{	
for (_Vbtype::iterator _Next = _Myvec.begin();
_Next != _Myvec.end(); ++_Next)
*_Next = (_Vbase)~*_Next;
_Trim(_Mysize);
}
	void swap(_Myt& _Right)
{	
if (this != &_Right)
{	
 
			this->_Swap_aux(_Right);
			std::swap(_Mysize, _Right._Mysize);
_Myvec.swap(_Right._Myvec);
}
}
	static void swap(reference _Left, reference _Right)
{	
bool _Val = _Left;
		_Left = _Right;
_Right = _Val;
}
protected:
void _Assign_n(size_type _Count, bool _Val)
{	
erase(begin(), end());
_Insert_n(begin(), _Count, _Val);
}
	void _Insert_n(const_iterator _Where,
size_type _Count, bool _Val)
{	
size_type _Off = _Insert_x(_Where, _Count);
std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);
}
	size_type _Insert_x(const_iterator _Where, size_type _Count)
{	
size_type _Off = _Where - begin();
 
		if (_Count == 0)
;
else if (max_size() - size() < _Count)
_Xlen();	
else
{	
_Myvec.resize(_Nw(size() + _Count), 0);
if (size() == 0)
_Mysize += _Count;
else
{	
iterator _Oldend = end();
_Mysize += _Count;
std::copy_backward(begin() + _Off, _Oldend, end());
}
 
			}
return (_Off);
}
	static size_type _Nw(size_type _Count)
{	
return ((_Count + _VBITS - 1) / _VBITS);
}
 
	void _Trim(size_type _Size)
{	
if (max_size() < _Size)
_Xlen();	
size_type _Words = _Nw(_Size);
		if (_Words < _Myvec.size())
_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());
_Mysize = _Size;
_Size %= _VBITS;
if (0 < _Size)
_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
}
	void _Xlen() const
{	
throw length_error("vector<bool> too long");
}
	void _Xran() const
{	
throw out_of_range("invalid vector<bool> subscript");
}
	size_type _Mysize;	
_Vbtype _Myvec;	
};
typedef vector<bool, allocator<bool> > _Bvector;
}
 #pragma warning(default: 4244)
#pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4244)
namespace std {
		
template<class _Arg,
class _Result>
struct unary_function
{	
typedef _Arg argument_type;
typedef _Result result_type;
};
		
template<class _Arg1,
class _Arg2,
class _Result>
struct binary_function
{	
typedef _Arg1 first_argument_type;
typedef _Arg2 second_argument_type;
typedef _Result result_type;
};
		
template<class _Ty>
struct plus
: public binary_function<_Ty, _Ty, _Ty>
{	
_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left + _Right);
}
};
		
template<class _Ty>
struct minus
: public binary_function<_Ty, _Ty, _Ty>
{	
_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left - _Right);
}
};
		
template<class _Ty>
struct multiplies
: public binary_function<_Ty, _Ty, _Ty>
{	
_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left * _Right);
}
};
		
template<class _Ty>
struct divides
: public binary_function<_Ty, _Ty, _Ty>
{	
_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left / _Right);
}
};
		
template<class _Ty>
struct modulus
: public binary_function<_Ty, _Ty, _Ty>
{	
_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left % _Right);
}
};
		
template<class _Ty>
struct negate
: public unary_function<_Ty, _Ty>
{	
_Ty operator()(const _Ty& _Left) const
{	
return (-_Left);
}
};
		
template<class _Ty>
struct equal_to
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left == _Right);
}
};
		
template<class _Ty>
struct not_equal_to
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left != _Right);
}
};
		
template<class _Ty>
struct greater
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left > _Right);
}
};
		
template<class _Ty>
struct less
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left < _Right);
}
};
		
template<class _Ty>
struct greater_equal
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left >= _Right);
}
};
		
template<class _Ty>
struct less_equal
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left <= _Right);
}
};
		
template<class _Ty>
struct logical_and
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left && _Right);
}
};
		
template<class _Ty>
struct logical_or
: public binary_function<_Ty, _Ty, bool>
{	
bool operator()(const _Ty& _Left, const _Ty& _Right) const
{	
return (_Left || _Right);
}
};
		
template<class _Ty>
struct logical_not
: public unary_function<_Ty, bool>
{	
bool operator()(const _Ty& _Left) const
{	
return (!_Left);
}
};
		
template<class _Fn1>
class unary_negate
: public unary_function<typename _Fn1::argument_type, bool>
{	
public:
explicit unary_negate(const _Fn1& _Func)
: _Functor(_Func)
{	
}
	bool operator()(const typename _Fn1::argument_type& _Left) const
{	
return (!_Functor(_Left));
}
protected:
_Fn1 _Functor;	
};
		
template<class _Fn1> inline
unary_negate<_Fn1> not1(const _Fn1& _Func)
{	
return (std::unary_negate<_Fn1>(_Func));
}
		
template<class _Fn2>
class binary_negate
: public binary_function<typename _Fn2::first_argument_type,
typename _Fn2::second_argument_type, bool>
{	
public:
explicit binary_negate(const _Fn2& _Func)
: _Functor(_Func)
{	
}
	bool operator()(const typename _Fn2::first_argument_type& _Left,
const typename _Fn2::second_argument_type& _Right) const
{	
return (!_Functor(_Left, _Right));
}
protected:
_Fn2 _Functor;	
};
		
template<class _Fn2> inline
binary_negate<_Fn2> not2(const _Fn2& _Func)
{	
return (std::binary_negate<_Fn2>(_Func));
}
		
template<class _Fn2>
class binder1st
: public unary_function<typename _Fn2::second_argument_type,
typename _Fn2::result_type>
{	
public:
typedef unary_function<typename _Fn2::second_argument_type,
typename _Fn2::result_type> _Base;
typedef typename _Base::argument_type argument_type;
typedef typename _Base::result_type result_type;
	binder1st(const _Fn2& _Func,
const typename _Fn2::first_argument_type& _Left)
: op(_Func), value(_Left)
{	
}
	result_type operator()(const argument_type& _Right) const
{	
return (op(value, _Right));
}
	result_type operator()(argument_type& _Right) const
{	
return (op(value, _Right));
}
protected:
_Fn2 op;	
typename _Fn2::first_argument_type value;	
};
		
template<class _Fn2,
class _Ty> inline
binder1st<_Fn2> bind1st(const _Fn2& _Func, const _Ty& _Left)
{	
typename _Fn2::first_argument_type _Val(_Left);
return (std::binder1st<_Fn2>(_Func, _Val));
}
		
template<class _Fn2>
class binder2nd
: public unary_function<typename _Fn2::first_argument_type,
typename _Fn2::result_type>
{	
public:
typedef unary_function<typename _Fn2::first_argument_type,
typename _Fn2::result_type> _Base;
typedef typename _Base::argument_type argument_type;
typedef typename _Base::result_type result_type;
	binder2nd(const _Fn2& _Func,
const typename _Fn2::second_argument_type& _Right)
: op(_Func), value(_Right)
{	
}
	result_type operator()(const argument_type& _Left) const
{	
return (op(_Left, value));
}
	result_type operator()(argument_type& _Left) const
{	
return (op(_Left, value));
}
protected:
_Fn2 op;	
typename _Fn2::second_argument_type value;	
};
		
template<class _Fn2,
class _Ty> inline
binder2nd<_Fn2> bind2nd(const _Fn2& _Func, const _Ty& _Right)
{	
typename _Fn2::second_argument_type _Val(_Right);
return (std::binder2nd<_Fn2>(_Func, _Val));
}
		
template<class _Arg,
class _Result,
class _Fn = _Result (*)(_Arg)>
class pointer_to_unary_function
: public unary_function<_Arg, _Result>
{	
public:
explicit pointer_to_unary_function(_Fn _Left)
: _Pfun(_Left)
{	
}
	_Result operator()(_Arg _Left) const
{	
return (_Pfun(_Left));
}
protected:
_Fn _Pfun;	
};
		
template<class _Arg1,
class _Arg2,
class _Result,
class _Fn = _Result (*)(_Arg1, _Arg2)>
class pointer_to_binary_function
: public binary_function<_Arg1, _Arg2, _Result>
{	
public:
explicit pointer_to_binary_function(_Fn _Left)
: _Pfun(_Left)
{	
}
	_Result operator()(_Arg1 _Left, _Arg2 _Right) const
{	
return (_Pfun(_Left, _Right));
}
protected:
_Fn _Pfun;	
};
		
template<class _Arg,
class _Result> inline
pointer_to_unary_function<_Arg, _Result, _Result (__cdecl *)(_Arg)>
ptr_fun(_Result (__cdecl *_Left)(_Arg))
{	
return (std::pointer_to_unary_function<_Arg, _Result, _Result (__cdecl *)(_Arg)>(_Left));
}
 
template<class _Arg,
class _Result> inline
pointer_to_unary_function<_Arg, _Result,
_Result (__stdcall *)(_Arg)>
ptr_fun(_Result (__stdcall *_Left)(_Arg))
{	
return (std::pointer_to_unary_function<_Arg, _Result, _Result (__stdcall *)(_Arg)>(_Left));
}
template<class _Arg,
class _Result> inline
pointer_to_unary_function<_Arg, _Result,
_Result (__fastcall *)(_Arg)>
ptr_fun(_Result (__fastcall *_Left)(_Arg))
{	
return (std::pointer_to_unary_function<_Arg, _Result, _Result (__fastcall *)(_Arg)>(_Left));
}
template<class _Arg1,
class _Arg2,
class _Result> inline
pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__cdecl *)(_Arg1, _Arg2)>
ptr_fun(_Result (__cdecl *_Left)(_Arg1, _Arg2))
{	
return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result (__cdecl *)(_Arg1, _Arg2)>(_Left));
}
 
template<class _Arg1,
class _Arg2,
class _Result> inline
pointer_to_binary_function<_Arg1, _Arg2, _Result,
_Result(__stdcall *)(_Arg1, _Arg2)>
ptr_fun(_Result (__stdcall *_Left)(_Arg1, _Arg2))
{	
return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result,
_Result (__stdcall *)(_Arg1, _Arg2)>(_Left));
}
template<class _Arg1,
class _Arg2,
class _Result> inline
pointer_to_binary_function<_Arg1, _Arg2, _Result,
_Result(__fastcall *)(_Arg1, _Arg2)>
ptr_fun(_Result (__fastcall *_Left)(_Arg1, _Arg2))
{	
return (std::pointer_to_binary_function<_Arg1, _Arg2, _Result,
_Result (__fastcall *)(_Arg1, _Arg2)>(_Left));
}
		
template<class _Result,
class _Ty>
class mem_fun_t
: public unary_function<_Ty *, _Result>
{	
public:
explicit mem_fun_t(_Result (_Ty::*_Pm)())
: _Pmemfun(_Pm)
{	
}
	_Result operator()(_Ty *_Pleft) const
{	
return ((_Pleft->*_Pmemfun)());
}
private:
_Result (_Ty::*_Pmemfun)();	
};
		
template<class _Result,
class _Ty,
class _Arg>
class mem_fun1_t
: public binary_function<_Ty *, _Arg, _Result>
{	
public:
explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
: _Pmemfun(_Pm)
{	
}
	_Result operator()(_Ty *_Pleft, _Arg _Right) const
{	
return ((_Pleft->*_Pmemfun)(_Right));
}
private:
_Result (_Ty::*_Pmemfun)(_Arg);	
};
		
template<class _Result,
class _Ty>
class const_mem_fun_t
: public unary_function<const _Ty *, _Result>
{	
public:
explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const)
: _Pmemfun(_Pm)
{	
}
	_Result operator()(const _Ty *_Pleft) const
{	
return ((_Pleft->*_Pmemfun)());
}
private:
_Result (_Ty::*_Pmemfun)() const;	
};
		
template<class _Result,
class _Ty,
class _Arg>
class const_mem_fun1_t
: public binary_function<const _Ty *, _Arg, _Result>
{	
public:
explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const)
: _Pmemfun(_Pm)
{	
}
	_Result operator()(const _Ty *_Pleft, _Arg _Right) const
{	
return ((_Pleft->*_Pmemfun)(_Right));
}
private:
_Result (_Ty::*_Pmemfun)(_Arg) const;	
};
		
template<class _Result,
class _Ty> inline
mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
{	
return (std::mem_fun_t<_Result, _Ty>(_Pm));
}
template<class _Result,
class _Ty,
class _Arg> inline
mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
{	
return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
}
template<class _Result,
class _Ty> inline
const_mem_fun_t<_Result, _Ty>
mem_fun(_Result (_Ty::*_Pm)() const)
{	
return (std::const_mem_fun_t<_Result, _Ty>(_Pm));
}
template<class _Result,
class _Ty,
class _Arg> inline
const_mem_fun1_t<_Result, _Ty, _Arg>
mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
{	
return (std::const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
}
		
template<class _Result,
class _Ty,
class _Arg> inline
mem_fun1_t<_Result, _Ty, _Arg> mem_fun1(_Result (_Ty::*_Pm)(_Arg))
{	
return (std::mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
}
		
template<class _Result,
class _Ty>
class mem_fun_ref_t
: public unary_function<_Ty, _Result>
{	
public:
explicit mem_fun_ref_t(_Result (_Ty::*_Pm)())
: _Pmemfun(_Pm)
{	
}
	_Result operator()(_Ty& _Left) const
{	
return ((_Left.*_Pmemfun)());
}
private:
_Result (_Ty::*_Pmemfun)();	
};
		
template<class _Result,
class _Ty,
class _Arg>
class mem_fun1_ref_t
: public binary_function<_Ty, _Arg, _Result>
{	
public:
explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
: _Pmemfun(_Pm)
{	
}
	_Result operator()(_Ty& _Left, _Arg _Right) const
{	
return ((_Left.*_Pmemfun)(_Right));
}
private:
_Result (_Ty::*_Pmemfun)(_Arg);	
};
		
template<class _Result,
class _Ty>
class const_mem_fun_ref_t
: public unary_function<_Ty, _Result>
{	
public:
explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const)
: _Pmemfun(_Pm)
{	
}
	_Result operator()(const _Ty& _Left) const
{	
return ((_Left.*_Pmemfun)());
}
private:
_Result (_Ty::*_Pmemfun)() const;	
};
		
template<class _Result,
class _Ty,
class _Arg>
class const_mem_fun1_ref_t
: public binary_function<_Ty, _Arg, _Result>
{	
public:
explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const)
: _Pmemfun(_Pm)
{	
}
	_Result operator()(const _Ty& _Left, _Arg _Right) const
{	
return ((_Left.*_Pmemfun)(_Right));
}
private:
_Result (_Ty::*_Pmemfun)(_Arg) const;	
};
		
template<class _Result,
class _Ty> inline
mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
{	
return (std::mem_fun_ref_t<_Result, _Ty>(_Pm));
}
template<class _Result,
class _Ty,
class _Arg> inline
mem_fun1_ref_t<_Result, _Ty, _Arg>
mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
{	
return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
}
template<class _Result,
class _Ty> inline
const_mem_fun_ref_t<_Result, _Ty>
mem_fun_ref(_Result (_Ty::*_Pm)() const)
{	
return (std::const_mem_fun_ref_t<_Result, _Ty>(_Pm));
}
template<class _Result,
class _Ty,
class _Arg> inline
const_mem_fun1_ref_t<_Result, _Ty, _Arg>
mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
{	
return (std::const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
}
		
template<class _Result,
class _Ty,
class _Arg> inline
mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun1_ref(_Result (_Ty::*_Pm)(_Arg))
{	
return (std::mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
}
 
}
namespace std {
namespace tr1 {	
template<class _Kty>
class hash
: public unary_function<_Kty, size_t>
{	
public:
size_t operator()(const _Kty& _Keyval) const
{	
ldiv_t _Qrem = ldiv((size_t)_Keyval, 127773);
		_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot;
if (_Qrem.rem < 0)
_Qrem.rem += 2147483647;
return ((size_t)_Qrem.rem);
}
};
template<>
class hash<std::string>
{	
public:
typedef std::string _Kty;
	size_t operator()(const _Kty& _Keyval) const
{	
size_t _Val = 2166136261U;
size_t _First = 0;
size_t _Last = _Keyval.size();
size_t _Stride = 1 + _Last / 10;
		if (_Stride < _Last)
_Last -= _Stride;
for(; _First < _Last; _First += _Stride)
_Val = 16777619U * _Val ^ (size_t)_Keyval[_First];
return (_Val);
}
};
template<>
class hash<std::wstring>
{	
public:
typedef std::wstring _Kty;
	size_t operator()(const _Kty& _Keyval) const
{	
size_t _Val = 2166136261U;
size_t _First = 0;
size_t _Last = _Keyval.size();
size_t _Stride = 1 + _Last / 10;
		if (_Stride < _Last)
_Last -= _Stride;
for(; _First < _Last; _First += _Stride)
_Val = 16777619U * _Val ^ (size_t)_Keyval[_First];
return (_Val);
}
};
	}	
}
 #pragma warning(default: 4244)
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4127)
namespace std {
		
template<class _Traits>
class _Tree_nod
: public _Traits	
{	
protected:
struct _Node;
friend struct _Node;
typedef _Node *_Nodeptr;	
	typedef typename _Traits::allocator_type allocator_type;
typedef typename _Traits::key_compare key_compare;
typedef typename _Traits::value_type value_type;
	struct _Node
{	
_Node(_Nodeptr _Larg, _Nodeptr _Parg, _Nodeptr _Rarg,
const value_type& _Val, char _Carg)
: _Left(_Larg), _Parent(_Parg), _Right(_Rarg),
_Myval(_Val), _Color(_Carg), _Isnil(false)
{	
}
		_Nodeptr _Left;	
_Nodeptr _Parent;	
_Nodeptr _Right;	
value_type _Myval;	
char _Color;	
char _Isnil;	
};
	_Tree_nod(const key_compare& _Parg,
allocator_type _Al)
: _Traits(_Parg, _Al), _Alnod(_Al)
{	
}
	typename allocator_type::template rebind<_Node>::other
_Alnod;	
};
		
template<class _Traits>
class _Tree_ptr
: public _Tree_nod<_Traits>
{	
protected:
	typedef _Tree_nod<_Traits> _Mybase;
typedef typename _Mybase::_Node _Node;
typedef typename _Mybase::_Nodeptr _Nodeptr;
typedef typename _Traits::allocator_type allocator_type;
typedef typename _Traits::key_compare key_compare;
	_Tree_ptr(const key_compare& _Parg,
allocator_type _Al)
: _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
{	
}
	typename allocator_type::template rebind<_Nodeptr>::other
_Alptr;	
};
		
template<class _Traits>
class _Tree_val
: public _Tree_ptr<_Traits>
{	
protected:
typedef typename _Traits::allocator_type allocator_type;
typedef typename _Traits::key_compare key_compare;
	_Tree_val(const key_compare& _Parg,
allocator_type _Al)
: _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
{	
}
	allocator_type _Alval;	
};
		
template<class _Traits>
class _Tree
: public _Tree_val<_Traits>
{	
public:
typedef _Tree<_Traits> _Myt;
typedef _Tree_val<_Traits> _Mybase;
typedef typename _Traits::key_type key_type;
typedef typename _Traits::key_compare key_compare;
typedef typename _Traits::value_compare value_compare;
typedef typename _Traits::value_type value_type;
typedef typename _Traits::allocator_type allocator_type;
 
	typedef typename allocator_type::pointer _ITptr;
typedef typename allocator_type::reference _IReft;
protected:
	typedef typename _Mybase::_Node _Node;
typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename allocator_type::template rebind<_Nodeptr>::other
_Nodeptr_alloc;
typedef typename _Nodeptr_alloc::reference _Nodepref;
	typedef typename allocator_type::template rebind<key_type>::other
_Key_alloc;
typedef typename _Key_alloc::const_reference _Keyref;
	typedef typename allocator_type::template rebind<char>::other
_Char_alloc;
typedef typename _Char_alloc::reference _Charref;
	typedef typename allocator_type::reference _Vref;
	enum _Redbl
{	
_Red, _Black};
	static _Charref _Color(_Nodeptr _Pnode)
{	
return ((_Charref)(*_Pnode)._Color);
}
	static _Charref _Isnil(_Nodeptr _Pnode)
{	
return ((_Charref)(*_Pnode)._Isnil);
}
	static _Keyref _Key(_Nodeptr _Pnode)
{	
return (_Mybase::_Kfn(_Myval(_Pnode)));
}
	static _Nodepref _Left(_Nodeptr _Pnode)
{	
return ((_Nodepref)(*_Pnode)._Left);
}
	static _Nodepref _Parent(_Nodeptr _Pnode)
{	
return ((_Nodepref)(*_Pnode)._Parent);
}
	static _Nodepref _Right(_Nodeptr _Pnode)
{	
return ((_Nodepref)(*_Pnode)._Right);
}
	static _Vref _Myval(_Nodeptr _Pnode)
{	
return ((_Vref)(*_Pnode)._Myval);
}
public:
typedef typename allocator_type::size_type size_type;
typedef typename allocator_type::difference_type _Dift;
typedef _Dift difference_type;
typedef typename allocator_type::pointer _Tptr;
typedef typename allocator_type::const_pointer _Ctptr;
typedef typename allocator_type::reference _Reft;
typedef _Tptr pointer;
typedef _Ctptr const_pointer;
typedef _Reft reference;
typedef typename allocator_type::const_reference const_reference;
		
class const_iterator;
friend class const_iterator;
	class const_iterator
: public _Bidit<value_type, _Dift, _Ctptr, const_reference>
{	
public:
friend class _Tree<_Traits>;
typedef bidirectional_iterator_tag iterator_category;
typedef _Dift difference_type;
typedef _Ctptr pointer;
typedef const_reference reference;
		typedef _Range_checked_iterator_tag _Checked_iterator_category;
		const_iterator()
: _Ptr(0)
{	
}
 
 
		const_iterator(_Nodeptr _Pnode, const _Myt *_Plist)
: _Ptr(_Pnode)
{	
{ if (!(_Plist != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Set_container(_Plist);
}
 
		const_reference operator*() const
{	
 
			{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
			return (_Myval(_Ptr));
}
		_Ctptr operator->() const
{	
return (&**this);
}
		const_iterator& operator++()
{	
_Inc();
return (*this);
}
		const_iterator operator++(int)
{	
const_iterator _Tmp = *this;
++*this;
return (_Tmp);
}
		const_iterator& operator--()
{	
_Dec();
return (*this);
}
		const_iterator operator--(int)
{	
const_iterator _Tmp = *this;
--*this;
return (_Tmp);
}
		bool operator==(const const_iterator& _Right) const
{	
 
			{ if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
			return (_Ptr == _Right._Ptr);
}
		bool operator!=(const const_iterator& _Right) const
{	
return (!(*this == _Right));
}
		void _Dec()
{	
 
			{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
			if (_Isnil(_Ptr))
{
_Ptr = _Right(_Ptr);	
if (_Isnil(_Ptr))
				{
{ ((void)0); ::_invalid_parameter_noinfo(); };
}
			}
else if (!_Isnil(_Left(_Ptr)))
_Ptr = _Max(_Left(_Ptr));	
else
{	
_Nodeptr _Pnode;
while (!_Isnil(_Pnode = _Parent(_Ptr))
&& _Ptr == _Left(_Pnode))
_Ptr = _Pnode;	
if (_Isnil(_Ptr))
					{
{ ((void)0); ::_invalid_parameter_noinfo(); };
}
				else
_Ptr = _Pnode;	
}
}
		void _Inc()
{	
 
			{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
if (_Isnil(_Ptr))
{
{ ((void)0); ::_invalid_parameter_noinfo(); };
				}
			else if (!_Isnil(_Right(_Ptr)))
_Ptr = _Min(_Right(_Ptr));	
else
{	
_Nodeptr _Pnode;
while (!_Isnil(_Pnode = _Parent(_Ptr))
&& _Ptr == _Right(_Pnode))
_Ptr = _Pnode;	
_Ptr = _Pnode;	
}
}
		_Nodeptr _Mynode() const
{	
return (_Ptr);
}
 
	protected:
		_Nodeptr _Ptr;	
};
		
class iterator;
friend class iterator;
	class iterator
: public const_iterator
{	
public:
typedef bidirectional_iterator_tag iterator_category;
typedef _Dift difference_type;
typedef _ITptr pointer;
typedef _IReft reference;
		iterator()
{	
}
 
 
		iterator(_Nodeptr _Pnode, const _Myt *_Plist)
: const_iterator(_Pnode, _Plist)
{	
}
 
		reference operator*() const
{	
return ((reference)**(const_iterator *)this);
}
		pointer operator->() const
{	
return (&**this);
}
		iterator& operator++()
{	
++(*(const_iterator *)this);
return (*this);
}
		iterator operator++(int)
{	
iterator _Tmp = *this;
++*this;
return (_Tmp);
}
		iterator& operator--()
{	
--(*(const_iterator *)this);
return (*this);
}
		iterator operator--(int)
{	
iterator _Tmp = *this;
--*this;
return (_Tmp);
}
};
	typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
typedef pair<iterator, bool> _Pairib;
typedef pair<iterator, iterator> _Pairii;
typedef pair<const_iterator, const_iterator> _Paircc;
	explicit _Tree(const key_compare& _Parg,
const allocator_type& _Al)
: _Mybase(_Parg, _Al)
{	
_Init();
}
	_Tree(const value_type *_First, const value_type *_Last,
const key_compare& _Parg, const allocator_type& _Al)
: _Mybase(_Parg, _Al)
{	
_Init();
try {
insert(_First, _Last);
} catch (...) {
_Tidy();
throw;
}
}
	_Tree(const _Myt& _Right)
: _Mybase(_Right.key_comp(), _Right.get_allocator())
{	
_Init();
try {
_Copy(_Right);
} catch (...) {
_Tidy();
throw;
}
}
	~_Tree()
{	
_Tidy();
}
	_Myt& operator=(const _Myt& _Right)
{	
if (this != &_Right)
{	
erase(begin(), end());
this->comp = _Right.comp;
_Copy(_Right);
}
return (*this);
}
	iterator begin()
{	
return (iterator(_Lmost(), this));
}
	const_iterator begin() const
{	
return (const_iterator(_Lmost(), this));
}
	iterator end()
{	
return (iterator(_Myhead, this));
}
	const_iterator end() const
{	
return (const_iterator(_Myhead, this));
}
	iterator _Make_iter(const_iterator _Where) const
{	
return (iterator(iterator(_Where._Ptr, this)));
}
	reverse_iterator rbegin()
{	
return (reverse_iterator(end()));
}
	const_reverse_iterator rbegin() const
{	
return (const_reverse_iterator(end()));
}
	reverse_iterator rend()
{	
return (reverse_iterator(begin()));
}
	const_reverse_iterator rend() const
{	
return (const_reverse_iterator(begin()));
}
	size_type size() const
{	
return (_Mysize);
}
	size_type max_size() const
{	
return (this->_Alval.max_size());
}
	bool empty() const
{	
return (size() == 0);
}
	allocator_type get_allocator() const
{	
return (this->_Alval);
}
	key_compare key_comp() const
{	
return (this->comp);
}
	value_compare value_comp() const
{	
return (value_compare(key_comp()));
}
	_Pairib insert(const value_type& _Val)
{	
_Nodeptr _Trynode = _Root();
_Nodeptr _Wherenode = _Myhead;
bool _Addleft = true;	
while (!_Isnil(_Trynode))
{	
_Wherenode = _Trynode;
_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));
_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);
}
		if (this->_Multi)
return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
else
{	
iterator _Where = iterator(_Wherenode, this);
if (!_Addleft)
;	
else if (_Where == begin())
return (_Pairib(_Insert(true, _Wherenode, _Val), true));
else
--_Where;	
			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
else
return (_Pairib(_Where, false));
}
}
	iterator insert(const_iterator _Where,
const value_type& _Val)
{	
 
		const_iterator _Next;
		if (size() == 0)
return (_Insert(true, _Myhead, _Val));	
else if (this->_Multi)
{	
if (_Where == begin())
{	
if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
return (_Insert(true, _Where._Mynode(), _Val));
}
else if (_Where == end())
{	
if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
return (_Insert(false, _Rmost(), _Val));
}
else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
&& !this->comp(this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
{	
if (_Isnil(_Right(_Next._Mynode())))
return (_Insert(false, _Next._Mynode(), _Val));
else
return (_Insert(true, _Where._Mynode(), _Val));
}
else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
&& (++(_Next = _Where) == end()
|| !this->comp(_Key(_Next._Mynode()), this->_Kfn(_Val))))
{	
if (_Isnil(_Right(_Where._Mynode())))
return (_Insert(false, _Where._Mynode(), _Val));
else
return (_Insert(true, _Next._Mynode(), _Val));
}
}
else
{	
if (_Where == begin())
{	
if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))
return (_Insert(true, _Where._Mynode(), _Val));
}
else if (_Where == end())
{	
if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))
return (_Insert(false, _Rmost(), _Val));
}
else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
&& this->comp(_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
{	
if (_Isnil(_Right(_Next._Mynode())))
return (_Insert(false, _Next._Mynode(), _Val));
else
return (_Insert(true, _Where._Mynode(), _Val));
}
else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
&& (++(_Next = _Where) == end()
|| this->comp(this->_Kfn(_Val), _Key(_Next._Mynode()))))
{	
if (_Isnil(_Right(_Where._Mynode())))
return (_Insert(false, _Where._Mynode(), _Val));
else
return (_Insert(true, _Next._Mynode(), _Val));
}
}
		return (insert(_Val).first);	
}
	template<class _Iter>
void insert(_Iter _First, _Iter _Last)
{	
 
		for (; _First != _Last; ++_First)
insert(*_First);
}
	iterator erase(const_iterator _Where)
{	
 
		if (_Isnil(_Where._Mynode()))
throw out_of_range("invalid map/set<T> iterator");
_Nodeptr _Erasednode = _Where._Mynode();	
++_Where;	
		_Nodeptr _Fixnode;	
_Nodeptr _Fixnodeparent;	
_Nodeptr _Pnode = _Erasednode;
		if (_Isnil(_Left(_Pnode)))
_Fixnode = _Right(_Pnode);	
else if (_Isnil(_Right(_Pnode)))
_Fixnode = _Left(_Pnode);	
else
{	
_Pnode = _Where._Mynode();	
_Fixnode = _Right(_Pnode);	
}
		if (_Pnode == _Erasednode)
{	
_Fixnodeparent = _Parent(_Erasednode);
if (!_Isnil(_Fixnode))
_Parent(_Fixnode) = _Fixnodeparent;	
			if (_Root() == _Erasednode)
_Root() = _Fixnode;	
else if (_Left(_Fixnodeparent) == _Erasednode)
_Left(_Fixnodeparent) = _Fixnode;	
else
_Right(_Fixnodeparent) = _Fixnode;	
			if (_Lmost() == _Erasednode)
_Lmost() = _Isnil(_Fixnode)
? _Fixnodeparent	
: _Min(_Fixnode);	
			if (_Rmost() == _Erasednode)
_Rmost() = _Isnil(_Fixnode)
? _Fixnodeparent	
: _Max(_Fixnode);	
}
else
{	
_Parent(_Left(_Erasednode)) = _Pnode;	
_Left(_Pnode) = _Left(_Erasednode);	
			if (_Pnode == _Right(_Erasednode))
_Fixnodeparent = _Pnode;	
else
{	
_Fixnodeparent = _Parent(_Pnode);	
if (!_Isnil(_Fixnode))
_Parent(_Fixnode) = _Fixnodeparent;	
_Left(_Fixnodeparent) = _Fixnode;	
_Right(_Pnode) = _Right(_Erasednode);	
_Parent(_Right(_Erasednode)) = _Pnode;	
}
			if (_Root() == _Erasednode)
_Root() = _Pnode;	
else if (_Left(_Parent(_Erasednode)) == _Erasednode)
_Left(_Parent(_Erasednode)) = _Pnode;	
else
_Right(_Parent(_Erasednode)) = _Pnode;	
			_Parent(_Pnode) = _Parent(_Erasednode);	
std::swap(_Color(_Pnode), _Color(_Erasednode));	
}
		if (_Color(_Erasednode) == _Black)
{	
for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
_Fixnodeparent = _Parent(_Fixnode))
if (_Fixnode == _Left(_Fixnodeparent))
{	
_Pnode = _Right(_Fixnodeparent);
if (_Color(_Pnode) == _Red)
{	
_Color(_Pnode) = _Black;
_Color(_Fixnodeparent) = _Red;
_Lrotate(_Fixnodeparent);
_Pnode = _Right(_Fixnodeparent);
}
					if (_Isnil(_Pnode))
_Fixnode = _Fixnodeparent;	
else if (_Color(_Left(_Pnode)) == _Black
&& _Color(_Right(_Pnode)) == _Black)
{	
_Color(_Pnode) = _Red;
_Fixnode = _Fixnodeparent;
}
else
{	
if (_Color(_Right(_Pnode)) == _Black)
{	
_Color(_Left(_Pnode)) = _Black;
_Color(_Pnode) = _Red;
_Rrotate(_Pnode);
_Pnode = _Right(_Fixnodeparent);
}
						_Color(_Pnode) = _Color(_Fixnodeparent);
_Color(_Fixnodeparent) = _Black;
_Color(_Right(_Pnode)) = _Black;
_Lrotate(_Fixnodeparent);
break;	
}
}
else
{	
_Pnode = _Left(_Fixnodeparent);
if (_Color(_Pnode) == _Red)
{	
_Color(_Pnode) = _Black;
_Color(_Fixnodeparent) = _Red;
_Rrotate(_Fixnodeparent);
_Pnode = _Left(_Fixnodeparent);
}
if (_Isnil(_Pnode))
_Fixnode = _Fixnodeparent;	
else if (_Color(_Right(_Pnode)) == _Black
&& _Color(_Left(_Pnode)) == _Black)
{	
_Color(_Pnode) = _Red;
_Fixnode = _Fixnodeparent;
}
else
{	
if (_Color(_Left(_Pnode)) == _Black)
{	
_Color(_Right(_Pnode)) = _Black;
_Color(_Pnode) = _Red;
_Lrotate(_Pnode);
_Pnode = _Left(_Fixnodeparent);
}
						_Color(_Pnode) = _Color(_Fixnodeparent);
_Color(_Fixnodeparent) = _Black;
_Color(_Left(_Pnode)) = _Black;
_Rrotate(_Fixnodeparent);
break;	
}
}
			_Color(_Fixnode) = _Black;	
}
		this->_Alnod.destroy(_Erasednode);	
this->_Alnod.deallocate(_Erasednode, 1);
		if (0 < _Mysize)
--_Mysize;
		return (_Make_iter(_Where));	
}
	iterator erase(const_iterator _First, const_iterator _Last)
{	
if (_First == begin() && _Last == end())
{	
clear();
return (begin());
}
else
{	
while (_First != _Last)
erase(_First++);
return (_Make_iter(_First));
}
}
	size_type erase(const key_type& _Keyval)
{	
_Pairii _Where = equal_range(_Keyval);
size_type _Num = 0;
_Distance(_Where.first, _Where.second, _Num);
erase(_Where.first, _Where.second);
return (_Num);
}
	void erase(const key_type *_First, const key_type *_Last)
{	
;
while (_First != _Last)
erase(*_First++);
}
	void clear()
{	
 
		_Erase(_Root());
_Root() = _Myhead, _Mysize = 0;
_Lmost() = _Myhead, _Rmost() = _Myhead;
}
	iterator find(const key_type& _Keyval)
{	
iterator _Where = lower_bound(_Keyval);
return (_Where == end()
|| this->comp(_Keyval, _Key(_Where._Mynode()))
? end() : _Where);
}
	const_iterator find(const key_type& _Keyval) const
{	
const_iterator _Where = lower_bound(_Keyval);
return (_Where == end()
|| this->comp(_Keyval, _Key(_Where._Mynode()))
? end() : _Where);
}
	size_type count(const key_type& _Keyval) const
{	
_Paircc _Ans = equal_range(_Keyval);
size_type _Num = 0;
_Distance(_Ans.first, _Ans.second, _Num);
return (_Num);
}
	iterator lower_bound(const key_type& _Keyval)
{	
return (iterator(_Lbound(_Keyval), this));
}
	const_iterator lower_bound(const key_type& _Keyval) const
{	
return (const_iterator(_Lbound(_Keyval), this));
}
	iterator upper_bound(const key_type& _Keyval)
{	
return (iterator(_Ubound(_Keyval), this));
}
	const_iterator upper_bound(const key_type& _Keyval) const
{	
return (const_iterator(_Ubound(_Keyval), this));
}
	_Pairii equal_range(const key_type& _Keyval)
{	
return (_Eqrange(_Keyval));
}
	_Paircc equal_range(const key_type& _Keyval) const
{	
return (_Eqrange(_Keyval));
}
	void swap(_Myt& _Right)
{	
if (this == &_Right)
;	
else if (get_allocator() == _Right.get_allocator())
{	
 
			this->_Swap_aux(_Right);
			std::swap(this->comp, _Right.comp);
std::swap(_Myhead, _Right._Myhead);
std::swap(_Mysize, _Right._Mysize);
}
else
{	
this->_Swap_aux(_Right);
			_Myt _Tmp = *this;
			*this = _Right;
_Right = _Tmp;
}
}
protected:
void _Copy(const _Myt& _Right)
{	
_Root() = _Copy(_Right._Root(), _Myhead);
_Mysize = _Right.size();
if (!_Isnil(_Root()))
{	
_Lmost() = _Min(_Root());
_Rmost() = _Max(_Root());
}
else
_Lmost() = _Myhead, _Rmost() = _Myhead;	
}
	_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
{	
_Nodeptr _Newroot = _Myhead;	
		if (!_Isnil(_Rootnode))
{	
_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
_Myval(_Rootnode), _Color(_Rootnode));
if (_Isnil(_Newroot))
_Newroot = _Pnode;	
			try {
_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);
_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);
} catch (...) {
_Erase(_Newroot);	
throw;
}
}
		return (_Newroot);	
}
	_Paircc _Eqrange(const key_type& _Keyval) const
{	
_Nodeptr _Pnode = _Root();
_Nodeptr _Lonode = _Myhead;	
_Nodeptr _Hinode = _Myhead;	
		while (!_Isnil(_Pnode))
if (this->comp(_Key(_Pnode), _Keyval))
_Pnode = _Right(_Pnode);	
else
{	
if (_Isnil(_Hinode)
&& this->comp(_Keyval, _Key(_Pnode)))
_Hinode = _Pnode;	
_Lonode = _Pnode;
_Pnode = _Left(_Pnode);	
}
		_Pnode = _Isnil(_Hinode) ? _Root()
: _Left(_Hinode);	
while (!_Isnil(_Pnode))
if (this->comp(_Keyval, _Key(_Pnode)))
{	
_Hinode = _Pnode;
_Pnode = _Left(_Pnode);	
}
else
_Pnode = _Right(_Pnode);	
		const_iterator _First = const_iterator(_Lonode, this);
const_iterator _Last = const_iterator(_Hinode, this);
return (_Paircc(_First, _Last));
}
	_Pairii _Eqrange(const key_type& _Keyval)
{	
_Nodeptr _Pnode = _Root();
_Nodeptr _Lonode = _Myhead;	
_Nodeptr _Hinode = _Myhead;	
		while (!_Isnil(_Pnode))
if (this->comp(_Key(_Pnode), _Keyval))
_Pnode = _Right(_Pnode);	
else
{	
if (_Isnil(_Hinode)
&& this->comp(_Keyval, _Key(_Pnode)))
_Hinode = _Pnode;	
_Lonode = _Pnode;
_Pnode = _Left(_Pnode);	
}
		_Pnode = _Isnil(_Hinode) ? _Root()
: _Left(_Hinode);	
while (!_Isnil(_Pnode))
if (this->comp(_Keyval, _Key(_Pnode)))
{	
_Hinode = _Pnode;
_Pnode = _Left(_Pnode);	
}
else
_Pnode = _Right(_Pnode);	
		iterator _First = iterator(_Lonode, this);
iterator _Last = iterator(_Hinode, this);
return (_Pairii(_First, _Last));
}
	void _Erase(_Nodeptr _Rootnode)
{	
for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)
{	
_Erase(_Right(_Pnode));
_Pnode = _Left(_Pnode);
this->_Alnod.destroy(_Rootnode);	
this->_Alnod.deallocate(_Rootnode, 1);
}
}
	void _Init()
{	
_Myhead = _Buynode();
_Isnil(_Myhead) = true;
_Root() = _Myhead;
_Lmost() = _Myhead, _Rmost() = _Myhead;
_Mysize = 0;
}
	iterator _Insert(bool _Addleft, _Nodeptr _Wherenode,
const value_type& _Val)
{	
if (max_size() - 1 <= _Mysize)
throw length_error("map/set<T> too long");
_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
_Val, _Red);
		++_Mysize;
if (_Wherenode == _Myhead)
{	
_Root() = _Newnode;
_Lmost() = _Newnode, _Rmost() = _Newnode;
}
else if (_Addleft)
{	
_Left(_Wherenode) = _Newnode;
if (_Wherenode == _Lmost())
_Lmost() = _Newnode;
}
else
{	
_Right(_Wherenode) = _Newnode;
if (_Wherenode == _Rmost())
_Rmost() = _Newnode;
}
		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )
if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))
{	
_Wherenode = _Right(_Parent(_Parent(_Pnode)));
if (_Color(_Wherenode) == _Red)
{	
_Color(_Parent(_Pnode)) = _Black;
_Color(_Wherenode) = _Black;
_Color(_Parent(_Parent(_Pnode))) = _Red;
_Pnode = _Parent(_Parent(_Pnode));
}
else
{	
if (_Pnode == _Right(_Parent(_Pnode)))
{	
_Pnode = _Parent(_Pnode);
_Lrotate(_Pnode);
}
_Color(_Parent(_Pnode)) = _Black;	
_Color(_Parent(_Parent(_Pnode))) = _Red;
_Rrotate(_Parent(_Parent(_Pnode)));
}
}
else
{	
_Wherenode = _Left(_Parent(_Parent(_Pnode)));
if (_Color(_Wherenode) == _Red)
{	
_Color(_Parent(_Pnode)) = _Black;
_Color(_Wherenode) = _Black;
_Color(_Parent(_Parent(_Pnode))) = _Red;
_Pnode = _Parent(_Parent(_Pnode));
}
else
{	
if (_Pnode == _Left(_Parent(_Pnode)))
{	
_Pnode = _Parent(_Pnode);
_Rrotate(_Pnode);
}
_Color(_Parent(_Pnode)) = _Black;	
_Color(_Parent(_Parent(_Pnode))) = _Red;
_Lrotate(_Parent(_Parent(_Pnode)));
}
}
		_Color(_Root()) = _Black;	
return (iterator(_Newnode, this));
}
	_Nodeptr _Lbound(const key_type& _Keyval) const
{	
_Nodeptr _Pnode = _Root();
_Nodeptr _Wherenode = _Myhead;	
		while (!_Isnil(_Pnode))
if (this->comp(_Key(_Pnode), _Keyval))
_Pnode = _Right(_Pnode);	
else
{	
_Wherenode = _Pnode;
_Pnode = _Left(_Pnode);	
}
		return (_Wherenode);	
}
	_Nodeptr& _Lmost() const
{	
return (_Left(_Myhead));
}
	void _Lrotate(_Nodeptr _Wherenode)
{	
_Nodeptr _Pnode = _Right(_Wherenode);
_Right(_Wherenode) = _Left(_Pnode);
		if (!_Isnil(_Left(_Pnode)))
_Parent(_Left(_Pnode)) = _Wherenode;
_Parent(_Pnode) = _Parent(_Wherenode);
		if (_Wherenode == _Root())
_Root() = _Pnode;
else if (_Wherenode == _Left(_Parent(_Wherenode)))
_Left(_Parent(_Wherenode)) = _Pnode;
else
_Right(_Parent(_Wherenode)) = _Pnode;
		_Left(_Pnode) = _Wherenode;
_Parent(_Wherenode) = _Pnode;
}
	static _Nodeptr _Max(_Nodeptr _Pnode)
{	
while (!_Isnil(_Right(_Pnode)))
_Pnode = _Right(_Pnode);
return (_Pnode);
}
	static _Nodeptr _Min(_Nodeptr _Pnode)
{	
while (!_Isnil(_Left(_Pnode)))
_Pnode = _Left(_Pnode);
return (_Pnode);
}
	_Nodeptr& _Rmost() const
{	
return (_Right(_Myhead));
}
	_Nodeptr& _Root() const
{	
return (_Parent(_Myhead));
}
	void _Rrotate(_Nodeptr _Wherenode)
{	
_Nodeptr _Pnode = _Left(_Wherenode);
_Left(_Wherenode) = _Right(_Pnode);
		if (!_Isnil(_Right(_Pnode)))
_Parent(_Right(_Pnode)) = _Wherenode;
_Parent(_Pnode) = _Parent(_Wherenode);
		if (_Wherenode == _Root())
_Root() = _Pnode;
else if (_Wherenode == _Right(_Parent(_Wherenode)))
_Right(_Parent(_Wherenode)) = _Pnode;
else
_Left(_Parent(_Wherenode)) = _Pnode;
		_Right(_Pnode) = _Wherenode;
_Parent(_Wherenode) = _Pnode;
}
	_Nodeptr _Ubound(const key_type& _Keyval) const
{	
_Nodeptr _Pnode = _Root();
_Nodeptr _Wherenode = _Myhead;	
		while (!_Isnil(_Pnode))
if (this->comp(_Keyval, _Key(_Pnode)))
{	
_Wherenode = _Pnode;
_Pnode = _Left(_Pnode);	
}
else
_Pnode = _Right(_Pnode);	
		return (_Wherenode);	
}
 
	_Nodeptr _Buynode()
{	
_Nodeptr _Wherenode = this->_Alnod.allocate(1);
int _Linkcnt = 0;
		try {
this->_Alptr.construct(&_Left(_Wherenode), 0);
++_Linkcnt;
this->_Alptr.construct(&_Parent(_Wherenode), 0);
++_Linkcnt;
this->_Alptr.construct(&_Right(_Wherenode), 0);
} catch (...) {
if (1 < _Linkcnt)
this->_Alptr.destroy(&_Parent(_Wherenode));
if (0 < _Linkcnt)
this->_Alptr.destroy(&_Left(_Wherenode));
this->_Alnod.deallocate(_Wherenode, 1);
throw;
}
_Color(_Wherenode) = _Black;
_Isnil(_Wherenode) = false;
return (_Wherenode);
}
	_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg,
_Nodeptr _Rarg, const value_type& _Val, char _Carg)
{	
_Nodeptr _Wherenode = this->_Alnod.allocate(1);
try {
new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);
} catch (...) {
this->_Alnod.deallocate(_Wherenode, 1);
throw;
}
return (_Wherenode);
}
	void _Tidy()
{	
erase(begin(), end());
this->_Alptr.destroy(&_Left(_Myhead));
this->_Alptr.destroy(&_Parent(_Myhead));
this->_Alptr.destroy(&_Right(_Myhead));
this->_Alnod.deallocate(_Myhead, 1);
_Myhead = 0, _Mysize = 0;
}
	static void _Xran()
{	
throw out_of_range("invalid map/set<T> iterator");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid map/set<T> argument");
}
	_Nodeptr _Myhead;	
size_type _Mysize;	
};
	
template <class _Traits>
class _Move_operation_category<_Tree<_Traits> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
		
template<class _Traits> inline
bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
{	
return (_Left.size() == _Right.size()
&& equal(_Left.begin(), _Left.end(), _Right.begin()));
}
template<class _Traits> inline
bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Traits> inline
bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
{	
return (lexicographical_compare(_Left.begin(), _Left.end(),
_Right.begin(), _Right.end()));
}
template<class _Traits> inline
bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
{	
return (_Right < _Left);
}
template<class _Traits> inline
bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Traits> inline
bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
{	
return (!(_Left < _Right));
}
}
 #pragma warning(default:4127)
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Kty,	
class _Ty,	
class _Pr,	
class _Alloc,	
bool _Mfl>	
class _Tmap_traits
: public _Container_base_aux_alloc_real<_Alloc>
{	
public:
typedef _Kty key_type;
typedef pair<const _Kty, _Ty> value_type;
typedef _Pr key_compare;
typedef typename _Alloc::template rebind<value_type>::other
allocator_type;
	typedef typename allocator_type::pointer _ITptr;
typedef typename allocator_type::reference _IReft;
	enum
{	
_Multi = _Mfl};
	_Tmap_traits(_Pr _Parg, _Alloc _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), comp(_Parg)
{	
}
	class value_compare
: public binary_function<value_type, value_type, bool>
{	
friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;
	public:
bool operator()(const value_type& _Left,
const value_type& _Right) const
{	
return (comp(_Left.first, _Right.first));
}
		value_compare(key_compare _Pred)
: comp(_Pred)
{	
}
	protected:
key_compare comp;	
};
	static const _Kty& _Kfn(const value_type& _Val)
{	
return (_Val.first);
}
	_Pr comp;	
};
		
template<class _Kty,
class _Ty,
class _Pr = less<_Kty>,
class _Alloc = allocator<pair<const _Kty, _Ty> > >
class map
: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
{	
public:
typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
typedef _Kty key_type;
typedef _Ty mapped_type;
typedef _Ty referent_type;	
typedef _Pr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	map()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit map(const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
}
	map(const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
}
	template<class _Iter>
map(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
map(_Iter _First, _Iter _Last,
const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
map(_Iter _First, _Iter _Last,
const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
 
	mapped_type& operator[](const key_type& _Keyval)
{	
iterator _Where = this->lower_bound(_Keyval);
if (_Where == this->end()
|| this->comp(_Keyval, this->_Key(_Where._Mynode())))
_Where = this->insert(_Where,
value_type(_Keyval, mapped_type()));
return ((*_Where).second);
}
};
	
template<class _Kty, class _Ty, class _Pr, class _Alloc>
class _Move_operation_category<map<_Kty, _Ty, _Pr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
template<class _Kty,
class _Ty,
class _Pr,
class _Alloc> inline
void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
map<_Kty, _Ty, _Pr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
		
template<class _Kty,
class _Ty,
class _Pr = less<_Kty>,
class _Alloc = allocator<pair<const _Kty, _Ty> > >
class multimap
: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
{	
public:
typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
typedef _Kty key_type;
typedef _Ty mapped_type;
typedef _Ty referent_type;	
typedef _Pr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	multimap()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit multimap(const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
}
multimap(const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
}
	template<class _Iter>
multimap(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
insert(*_First);
}
	template<class _Iter>
multimap(_Iter _First, _Iter _Last,
const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
;
for (; _First != _Last; ++_First)
insert(*_First);
}
	template<class _Iter>
multimap(_Iter _First, _Iter _Last,
const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
;
for (; _First != _Last; ++_First)
insert(*_First);
}
	iterator insert(const value_type& _Val)
{	
return (_Mybase::insert(_Val).first);
}
	iterator insert(const_iterator _Where, const value_type& _Val)
{	
return (_Mybase::insert(_Where, _Val));
}
 
	template<class _Iter>
void insert(_Iter _First, _Iter _Last)
{	
 
		for (; _First != _Last; ++_First)
insert(*_First);
}
};
	
template<class _Kty, class _Ty, class _Pr, class _Alloc>
class _Move_operation_category<multimap<_Kty, _Ty, _Pr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
template<class _Kty,
class _Ty,
class _Pr,
class _Alloc> inline
void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
 
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma once
#pragma pack(push,8)
 
 
struct __type_info_node {
void *memPtr;
__type_info_node* next;
};
extern __type_info_node __type_info_root_node;
class type_info {
public:
virtual ~type_info();
__declspec(dllimport) bool  operator==(const type_info& rhs) const;
__declspec(dllimport) bool  operator!=(const type_info& rhs) const;
__declspec(dllimport) int  before(const type_info& rhs) const;
__declspec(dllimport) const char*  name(__type_info_node* __ptype_info_node = &__type_info_root_node) const;
__declspec(dllimport) const char*  raw_name() const;
private:
void *_m_data;
char _m_d_name[1];
type_info(const type_info& rhs);
type_info&  operator=(const type_info& rhs);
__declspec(dllimport) static const char *__cdecl _Name_base(const type_info *,__type_info_node* __ptype_info_node);
__declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *);
};
 
 namespace std {
using ::type_info;
 }
 namespace std {
class __declspec(dllimport) bad_cast : public exception {
public:
     bad_cast(const char * _Message = "bad cast");
bad_cast(const bad_cast &);
virtual  ~bad_cast();
};
class __declspec(dllimport) bad_typeid : public exception {
public:
     bad_typeid(const char * _Message = "bad typeid");
bad_typeid(const bad_typeid &);
virtual  ~bad_typeid();
};
class __declspec(dllimport) __non_rtti_object : public bad_typeid {
public:
     __non_rtti_object(const char * _Message);
__non_rtti_object(const __non_rtti_object &);
virtual  ~__non_rtti_object();
};
 }
 
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
struct _DebugHeapTag_t
{	
int _Type;
};
}
		
 
   
   
  
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
#pragma once
 
extern "C" {
                                
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isctype([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Type);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isctype_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Type, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl isalpha([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isalpha_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl isupper([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isupper_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl islower([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _islower_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl isdigit([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isdigit_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl isxdigit([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isxdigit_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl isspace([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isspace_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl ispunct([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _ispunct_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl isalnum([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isalnum_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl isprint([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isprint_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl isgraph([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _isgraph_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl iscntrl([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _iscntrl_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl toupper([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl tolower([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl _tolower([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _tolower_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)]  __declspec(dllimport) int __cdecl _toupper([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl _toupper_l([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C, [SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl __isascii([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl __toascii([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl __iscsymf([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int __cdecl __iscsym([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _C);
}
#pragma once
 
#pragma pack(push,8)
extern "C" {
struct lconv {
char *decimal_point;
char *thousands_sep;
char *grouping;
char *int_curr_symbol;
char *currency_symbol;
char *mon_decimal_point;
char *mon_thousands_sep;
char *mon_grouping;
char *positive_sign;
char *negative_sign;
char int_frac_digits;
char frac_digits;
char p_cs_precedes;
char p_sep_by_space;
char n_cs_precedes;
char n_sep_by_space;
char p_sign_posn;
char n_sign_posn;
};
 __declspec(dllimport) int __cdecl _configthreadlocale([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Flag);
__declspec(dllimport) char * __cdecl setlocale([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Category, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Locale);
__declspec(dllimport) struct lconv * __cdecl localeconv(void);
__declspec(dllimport) _locale_t __cdecl _get_current_locale(void);
__declspec(dllimport) _locale_t __cdecl _create_locale([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Category, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Locale);
__declspec(dllimport) void __cdecl _free_locale([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_get_current_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_create_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _Category, [SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Locale);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_free_locale" " instead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale([SA_Pre(Null=SA_Maybe)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] _locale_t _Locale);
}
#pragma pack(pop)
#pragma pack(push,8)
extern "C" {
		
		
typedef struct _Collvec
{	
unsigned long _Hand;	
unsigned int _Page;		
} _Collvec;
typedef struct _Ctypevec
{	
unsigned long _Hand;	
unsigned int _Page;		
const short *_Table;
int _Delfl;
} _Ctypevec;
typedef struct _Cvtvec
{	
unsigned long _Hand;	
unsigned int _Page;		
} _Cvtvec;
		
__declspec(dllimport) _Collvec __cdecl _Getcoll();
__declspec(dllimport) _Ctypevec __cdecl _Getctype();
__declspec(dllimport) _Cvtvec __cdecl _Getcvt();
__declspec(dllimport) int __cdecl _Getdateorder();
__declspec(dllimport) int __cdecl _Mbrtowc([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] wchar_t *, const char *, size_t,
mbstate_t *, const _Cvtvec *);
__declspec(dllimport) float __cdecl _Stof(const char *, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **, 
long);
__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
[SA_Pre(Null=SA_No,WritableElements="\n@""_End1-_String1")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="return")] [SA_Post(Deref=1,Valid=SA_Yes)] char * _String1, 
[SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char * _End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb([SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] char *, wchar_t, mbstate_t *,
const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
[SA_Pre(Null=SA_No,WritableElements="\n@""_End1-_String1")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="return")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_String1, 
[SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
short*, const _Ctypevec*);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
}
extern "C" {
__declspec(dllimport) void *__cdecl _Gettnames();
__declspec(dllimport) char *__cdecl _Getdays();
__declspec(dllimport) char *__cdecl _Getmonths();
__declspec(dllimport) size_t __cdecl _Strftime(
[SA_Pre(Null=SA_No,WritableElements="_Maxsize")] [SA_Pre(Deref=1,Valid=SA_No)] char *, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] size_t _Maxsize, 
[SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)]  const char *, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] const struct tm *, void *);
}
extern "C" {
_locale_t __cdecl _GetLocaleForCP(unsigned int);
}
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
namespace std {
		
class __declspec(dllimport) _Timevec
{	
public:
_Timevec(void *_Ptr = 0)
: _Timeptr(_Ptr)
{	
}
	 _Timevec(const _Timevec& _Right)
{	
*this = _Right;
}
	 ~_Timevec()
{	
free(_Timeptr);
}
	_Timevec&  operator=(const _Timevec& _Right)
{	
_Timeptr = _Right._Timeptr;
((_Timevec *)&_Right)->_Timeptr = 0;
return (*this);
}
	void * _Getptr() const
{	
return (_Timeptr);
}
private:
void *_Timeptr;	
};
		
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Locinfo
{	
public:
typedef ::_Collvec _Collvec;
typedef ::_Ctypevec _Ctypevec;
typedef ::_Cvtvec _Cvtvec;
typedef std::_Timevec _Timevec;
    static  void __cdecl _Locinfo_ctor(_Locinfo *, const char *);
static  void __cdecl _Locinfo_ctor(_Locinfo *, const string&);
static  void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *);
static  void __cdecl _Locinfo_dtor(_Locinfo *);
static  _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo *, int, const char *);
	 _Locinfo(const char *_Pch = "C")
        : _Lock(0)
        {
if (_Pch == 0)
throw runtime_error("bad locale name");
_Locinfo_ctor(this, _Pch);
}
	 _Locinfo(int _I, const char *_Pch)
        : _Lock(0)
        {
if (_Pch == 0)
throw runtime_error("bad locale name");
_Locinfo_ctor(this, _I, _Pch);
}
	 _Locinfo(const string& locstr)
        : _Lock(0)
		{
_Locinfo_ctor(this, locstr);
}
	 ~_Locinfo()
{
_Locinfo_dtor(this);
}
	_Locinfo&  _Addcats(int _I, const char *_Pch)
{
if (_Pch == 0)
throw runtime_error("bad locale name");
return _Locinfo_Addcats(this, _I, _Pch);
}
	string  _Getname() const
{	
return (_Newlocname);
}
	_Collvec  _Getcoll() const
{	
return (::_Getcoll());
}
	_Ctypevec  _Getctype() const
{	
return (::_Getctype());
}
	_Cvtvec  _Getcvt() const
{	
return (::_Getcvt());
}
	const lconv * _Getlconv() const
{	
return (localeconv());
}
	_Timevec  _Gettnames() const
{	
return (_Timevec(::_Gettnames()));
}
	const char * _Getdays() const
{	
const char *_Ptr = ::_Getdays();
if (_Ptr != 0)
{	
((_Locinfo *)this)->_Days = _Ptr;
free((void *)_Ptr);
}
return (_Days.size() != 0 ? _Days.c_str()
: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
":Thu:Thursday:Fri:Friday:Sat:Saturday");
}
	const char * _Getmonths() const
{	
const char *_Ptr = ::_Getmonths();
if (_Ptr != 0)
{	
((_Locinfo *)this)->_Months = _Ptr;
free((void *)_Ptr);
}
return (_Months.size() != 0 ? _Months.c_str()
: ":Jan:January:Feb:February:Mar:March"
":Apr:April:May:May:Jun:June"
":Jul:July:Aug:August:Sep:September"
":Oct:October:Nov:November:Dec:December");
}
	const char * _Getfalse() const
{	
return ("false");
}
	const char * _Gettrue() const
{	
return ("true");
}
	int  _Getdateorder() const
{	
return ::_Getdateorder();
}
private:
	_Lockit _Lock;	
	string _Days;	
string _Months;	
string _Oldlocname;	
string _Newlocname;	
};
#pragma warning(pop)
		
template<class _Elem> inline
int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
const _Elem *_First2, const _Elem *_Last2,
const _Locinfo::_Collvec *)
{	
for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
if (*_First1 < *_First2)
return (-1);	
else if (*_First2 < *_First1)
return (+1);	
return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
}
template<> inline
int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
const char *_First2, const char *_Last2,
const _Locinfo::_Collvec *_Vector)
{	
return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
}
template<> inline
int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
const wchar_t *_First2, const wchar_t *_Last2,
const _Locinfo::_Collvec *_Vector)
{	
return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
}
		
template<class _Elem> inline
size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
const _Elem *_First2, const _Elem *_Last2,
const _Locinfo::_Collvec *)
{	
size_t _Count = _Last2 - _First2;
if (_Count <= (size_t)(_Last1 - _First1))
::memcpy_s((_First1), ((_Last1 - _First1)* sizeof(_Elem)), (_First2), (_Count * sizeof (_Elem)));
return (_Count);
}
template<> inline
size_t __cdecl _LStrxfrm(
[SA_Pre(Null=SA_No,WritableElements="\n@""_Last1-_First1")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="return")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_First1, 
[SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] char *_Last1,
const char *_First2, const char *_Last2,
const _Locinfo::_Collvec *_Vector)
{	
return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
}
template<> inline
size_t __cdecl _LStrxfrm(
[SA_Pre(Null=SA_No,WritableElements="\n@""_Last1-_First1")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="return")] [SA_Post(Deref=1,Valid=SA_Yes)] wchar_t *_First1, 
[SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *_Last1,
const wchar_t *_First2, const wchar_t *_Last2,
const _Locinfo::_Collvec *_Vector)
{	
return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
}
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
namespace std {
		
template<class _Dummy>
class _Locbase
{	
public:
static const int collate = ((1 << (1)) >> 1);
static const int ctype = ((1 << (2)) >> 1);
static const int monetary = ((1 << (3)) >> 1);
static const int numeric = ((1 << (4)) >> 1);
static const int time = ((1 << (5)) >> 1);
static const int messages = ((1 << (6)) >> 1);
static const int all = (((1 << (7)) >> 1) - 1);
static const int none = 0;
};
template<class _Dummy>
const int _Locbase<_Dummy>::collate;
template<class _Dummy>
const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
const int _Locbase<_Dummy>::time;
template<class _Dummy>
const int _Locbase<_Dummy>::messages;
template<class _Dummy>
const int _Locbase<_Dummy>::all;
template<class _Dummy>
const int _Locbase<_Dummy>::none;
		
class locale;
template<class _Facet>
const _Facet& __cdecl use_facet(const locale&);
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) locale
: public _Locbase<int>
{	
public:
typedef int category;
			
class __declspec(dllimport) id
{	
public:
id(size_t _Val = 0)
: _Id(_Val)
{	
}
		 operator size_t()
{	
if (_Id == 0)
{	
{ ::std:: _Lockit _Lock(0);
if (_Id == 0)
_Id = ++_Id_cnt;
}
}
return (_Id);
}
	private:
id(const id&);	
id&  operator=(const id&);	
		size_t _Id;	
static  int& __cdecl _Id_cnt_func();
		 static int _Id_cnt;	
		};
	class _Locimp;
			
class facet
{	
friend class locale;
friend class _Locimp;
	public:
__declspec(dllimport) static size_t __cdecl _Getcat(const facet ** = 0,
const locale * = 0)
{	
return ((size_t)(-1));
}
		__declspec(dllimport) void  _Incref()
{	
{ ::std:: _Lockit _Lock(0);
if (_Refs < (size_t)(-1))
++_Refs;
}
}
		__declspec(dllimport) facet * _Decref()
{	
{ ::std:: _Lockit _Lock(0);
if (0 < _Refs && _Refs < (size_t)(-1))
--_Refs;
return (_Refs == 0 ? this : 0);
}
}
		void  _Register()
{
			facet_Register(this);
			}
  
		__declspec(dllimport) virtual  ~facet()
{	
}
	protected:
__declspec(dllimport) explicit  facet(size_t _Initrefs = 0)
: _Refs(_Initrefs)
{	
}
	private:
		static void __cdecl facet_Register(facet *);	
		 facet(const facet&);	
facet&  operator=(const facet&);	
		size_t _Refs;	
};
#pragma warning(push)
#pragma warning(disable:4275)
	class __declspec(dllimport) _Locimp
: public facet
{	
protected:
~_Locimp()
{
_Locimp_dtor(this);
}
	private:
static  void __cdecl _Locimp_dtor(_Locimp *); 
static void _Locimp_ctor(_Locimp *,const _Locimp&);	
static  void __cdecl _Locimp_Addfac(_Locimp *,facet *, size_t);	
friend class locale;
		 _Locimp(bool _Transparent = false)
: locale::facet(1), _Facetvec(0), _Facetcount(0),
_Catmask(none), _Xparent(_Transparent), _Name("*")
{ }
		 _Locimp(const _Locimp& _Right)
: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
_Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name(_Right._Name)
{
_Locimp_ctor(this, _Right);
}
		void  _Addfac(facet *_Pfacet, size_t _Id)
{
_Locimp_Addfac(this, _Pfacet, _Id);
}
		static _Locimp * _Makeloc(const _Locinfo&,
category, _Locimp *, const locale *);	
		static void _Makewloc(const _Locinfo&,
category, _Locimp *, const locale *);	
 
static void _Makeushloc(const _Locinfo&,
category, _Locimp *, const locale *);	
		static void _Makexloc(const _Locinfo&,
category, _Locimp *, const locale *);	
		facet **_Facetvec;	
size_t _Facetcount;	
category _Catmask;	
bool _Xparent;	
string _Name;	
		static  _Locimp *& __cdecl _Clocptr_func();	
		 static _Locimp *_Clocptr;	
private:
_Locimp&  operator=(const _Locimp&);	
		};
#pragma warning(pop)
	__declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")) locale&  _Addfac(facet *_Fac, size_t _Id,
size_t _Catmask)
{
if (1 < this->_Ptr->_Refs)
{	
this->_Ptr->_Decref();
this->_Ptr = new _Locimp(*this->_Ptr);
}
this->_Ptr->_Addfac(_Fac, _Id);
		if (_Catmask != 0)
this->_Ptr->_Name = "*";
return (*this);
}
	template<class _Elem,
class _Traits,
class _Alloc>
bool  operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right) const
{	
const std::collate<_Elem>& _Coll_fac =
std::use_facet<std::collate<_Elem> >(*this);
		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
}
	template<class _Facet>
locale  combine(const locale& _Loc) const
{	
_Facet *_Facptr;
		try {
_Facptr = (_Facet *)&std::use_facet<_Facet>(_Loc);
} catch (...) {
throw runtime_error("locale::combine facet missing");
}
		_Locimp *_Newimp = new _Locimp(*_Ptr);
_Newimp->_Addfac(_Facptr, _Facet::id);
_Newimp->_Catmask = 0;
_Newimp->_Name = "*";
return (locale(_Newimp));
}
	template<class _Facet>
locale(const locale& _Loc, const _Facet *_Facptr)
: _Ptr(new _Locimp(*_Loc._Ptr))
{	
if (_Facptr != 0)
{	
_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
if (_Facet::_Getcat() != (size_t)(-1))
{	
_Ptr->_Catmask = 0;
_Ptr->_Name = "*";
}
}
}
	 locale() throw ()
: _Ptr(_Init())
{	
_Getgloballocale()->_Incref();
}
	 locale(_Uninitialized)
{	
}
	 locale(const locale& _Right) throw ()
: _Ptr(_Right._Ptr)
{	
_Ptr->_Incref();
}
	 locale(const locale& _Loc, const locale& _Other,
category _Cat) 	
: _Ptr(new _Locimp(*_Loc._Ptr))
{	
try {
{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
}
} catch (...) {
delete (_Ptr->_Decref());
throw;
}
}
	explicit  locale(const char *_Locname,
category _Cat = all) 	
: _Ptr(new _Locimp)
{	
try {
_Init();
{ _Locinfo _Lobj(_Cat, _Locname);
if (_Lobj._Getname().compare("*") == 0)
throw runtime_error("bad locale name");
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
}
} catch (...) {
delete (_Ptr->_Decref());
throw;
}
}
	 locale(const locale& _Loc, const char * _Locname,
category _Cat) 	
: _Ptr(new _Locimp(*_Loc._Ptr))
{	
try {
{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
bool _Hadname = _Lobj._Getname().compare("*") != 0;
_Lobj._Addcats(_Cat, _Locname);
			if (_Hadname && _Lobj._Getname().compare("*") == 0)
throw runtime_error("bad locale name");
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
}
} catch (...) {
delete (_Ptr->_Decref());
throw;
}
}
	 ~locale() throw ()
{	
if (_Ptr != 0)
delete (_Ptr->_Decref());
}
	locale&  operator=(const locale& _Right) throw ()
{	
if (_Ptr != _Right._Ptr)
{	
delete (_Ptr->_Decref());
_Ptr = _Right._Ptr;
_Ptr->_Incref();
}
return (*this);
}
	string  name() const
{	
return (_Ptr->_Name);
}
	const facet * _Getfacet(size_t _Id) const 	
{	
const facet *_Facptr = _Id < _Ptr->_Facetcount
? _Ptr->_Facetvec[_Id] : 0;	
if (_Facptr != 0 || !_Ptr->_Xparent)
return (_Facptr);	
else
{	
locale::_Locimp *_Ptr = _Getgloballocale();
return (_Id < _Ptr->_Facetcount
? _Ptr->_Facetvec[_Id]	
: 0);	
}
}
	bool  operator==(const locale& _Loc) const
{	
return (_Ptr == _Loc._Ptr
|| name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
}
	bool  operator!=(const locale& _Right) const
{	
return (!(*this == _Right));
}
	static  const locale& __cdecl classic();	
	static  locale __cdecl global(const locale&);	
	static  locale __cdecl empty();	
private:
locale(_Locimp *_Ptrimp)
: _Ptr(_Ptrimp)
{	
}
	static  _Locimp *__cdecl _Getgloballocale();
static  _Locimp *__cdecl _Init();	
static  void __cdecl _Setgloballocale(void *);
	_Locimp *_Ptr;	
};
#pragma warning(pop)
		
template<class _Facet>
struct _Facetptr
{	
static const locale::facet *_Psave;
};
template<class _Facet>
const locale::facet *_Facetptr<_Facet>::_Psave = 0;
template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it."))
locale _Addfac(locale _Loc, const _Facet *_Facptr)
{	
size_t _Cat = _Facet::_Getcat(0, 0);
locale _Newloc = _Loc._Addfac((_Facet *)_Facptr, _Facet::id, _Cat);
		return (_Newloc);
}
  
  
template<class _Facet> inline
const _Facet& __cdecl use_facet(const locale& _Loc)
{	
{ ::std:: _Lockit _Lock(0);	
const locale::facet *_Psave =
_Facetptr<_Facet>::_Psave;	
		size_t _Id = _Facet::id;
const locale::facet *_Pf = _Loc._Getfacet(_Id);
		if (_Pf != 0)
;	
else if (_Psave != 0)
_Pf = _Psave;	
else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))
 
throw bad_cast();	
	
		else
{	
_Pf = _Psave;
_Facetptr<_Facet>::_Psave = _Psave;
			locale::facet *_Pfmod = (_Facet *)_Psave;
_Pfmod->_Incref();
_Pfmod->_Register();
}
		return ((const _Facet&)(*_Pf));	
}
}
template<class _Facet> inline __declspec(deprecated("This is an obsolete part of the Standard C++ Library Implementation. Do not use it."))
const _Facet& __cdecl use_facet(const locale& _Loc, const _Facet *,
bool = false)
{	
return use_facet<_Facet>(_Loc);
}
		
template<class _Elem,
class _InIt> inline
int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
const _Elem *_Ptr)
{	
for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
if (_Ptr[_Off] == _Ptr[0])
++_Numfields;	
string _Str(_Numfields, '\0');	
	int _Ans = -2;	
for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
{	
bool  _Prefix = false;	
size_t _Off = 0;	
size_t _Field = 0;	
		for (; _Field < _Numfields; ++_Field)
{	
for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
;	
			if (_Str[_Field] != '\0')
_Off += _Str[_Field];	
else if (_Ptr[_Off += _Column] == _Ptr[0]
|| _Ptr[_Off] == (_Elem)0)
{	
_Str[_Field] = (char)(_Column < 127
? _Column : 127);	
_Ans = (int)_Field;	
}
else if (_First == _Last || _Ptr[_Off] != *_First)
_Str[_Field] = (char)(_Column < 127
? _Column : 127);	
else
_Prefix = true;	
}
		if (!_Prefix || _First == _Last)
break;	
}
return (_Ans);	
}
		
template<class _Elem> inline
char __cdecl _Maklocbyte(_Elem _Char,
const _Locinfo::_Cvtvec&)
{	
return ((char)(unsigned char)_Char);
}
template<> inline
char __cdecl _Maklocbyte(wchar_t _Char,
const _Locinfo::_Cvtvec& _Cvt)
{	
char _Byte = '\0';
mbstate_t _Mbst1 = {0};
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
return (_Byte);
}
		
template<class _Elem> inline
_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
const _Locinfo::_Cvtvec&)
{	
return ((_Elem)(unsigned char)_Byte);
}
template<> inline
wchar_t __cdecl _Maklocchr(char _Byte, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *,
const _Locinfo::_Cvtvec& _Cvt)
{	
wchar_t _Wc = L'\0';
mbstate_t _Mbst1 = {0};
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
return (_Wc);
}
		
template<class _Elem> inline
_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
const _Locinfo::_Cvtvec&)
{	
size_t _Count = ::strlen(_Ptr) + 1;
_Elem *_Ptrdest = new _Elem[_Count];
#pragma warning(push)
#pragma warning(disable: 6011)
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
return (_Ptrdest);
#pragma warning(pop)
}
template<> inline
wchar_t *__cdecl _Maklocstr(const char *_Ptr, [SA_Pre(Null=SA_Maybe,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] wchar_t *,
const _Locinfo::_Cvtvec& _Cvt)
{	
size_t _Count, _Count1;
size_t _Wchars;
const char *_Ptr1;
int _Bytes;
wchar_t _Wc;
mbstate_t _Mbst1 = {0};
	_Count1 = ::strlen(_Ptr) + 1;
for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
break;
++_Wchars;	
	wchar_t *_Ptrdest = new wchar_t[_Wchars];
wchar_t *_Ptrnext = _Ptrdest;
mbstate_t _Mbst2 = {0};
#pragma warning(push)
#pragma warning(disable: 6011)
	for (; 0 < _Wchars;
_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
break;
*_Ptrnext = L'\0';
#pragma warning(pop)
return (_Ptrdest);
}
#pragma warning(push)
#pragma warning(disable:4275)
class __declspec(dllimport) codecvt_base
: public locale::facet
{	
public:
enum
{	
ok, partial, error, noconv};
typedef int result;
	 codecvt_base(size_t _Refs = 0)
: locale::facet(_Refs)
{	
}
	bool  always_noconv() const throw ()
{	
return (do_always_noconv());
}
	int  max_length() const throw ()
{	
return (do_max_length());
}
	int  encoding() const throw ()
{	
return (do_encoding());
}
	 ~codecvt_base()
{	
}
protected:
virtual bool  do_always_noconv() const throw ()
{	
return (true);
}
	virtual int  do_max_length() const throw ()
{	
return (1);
}
	virtual int  do_encoding() const throw ()
{	
return (1);	
}
};
#pragma warning(pop)
		
template<class _Elem,
class _Byte,
class _Statype>
class codecvt
: public codecvt_base
{	
public:
typedef _Elem intern_type;
typedef _Byte extern_type;
typedef _Statype state_type;
	result  in(_Statype& _State,
const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
{	
return (do_in(_State,
_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
}
	result  out(_Statype& _State,
const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
return (do_out(_State,
_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
}
	result  unshift(_Statype& _State,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
return (do_unshift(_State, _First2, _Last2, _Mid2));
}
	int  length(const _Statype& _State, const _Byte *_First1,
const _Byte *_Last1, size_t _Count) const
{	
return (do_length(_State, _First1, _Last1, _Count));
}
	 static locale::id id;	
	explicit  codecvt(size_t _Refs = 0)
: codecvt_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
: codecvt_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
_Locinfo(_Ploc->name()));
return (2);
}
protected:
virtual  ~codecvt()
{	
}
protected:
void  _Init(const _Locinfo&)
{	
}
	virtual result  do_in(_Statype&,
const _Byte *_First1, const _Byte *, const _Byte *& _Mid1,
_Elem *_First2, _Elem *, _Elem *& _Mid2) const
{	
_Mid1 = _First1, _Mid2 = _First2;
return (noconv);	
}
	virtual result  do_out(_Statype&,
const _Elem *_First1, const _Elem *, const _Elem *& _Mid1,
_Byte *_First2, _Byte *, _Byte *& _Mid2) const
{	
_Mid1 = _First1, _Mid2 = _First2;
return (noconv);	
}
	virtual result  do_unshift(_Statype&,
_Byte *_First2, _Byte *, _Byte *&_Mid2) const
{	
_Mid2 = _First2;
return (noconv);	
}
	virtual int  do_length(const _Statype&, const _Byte *_First1,
const _Byte *_Last1, size_t _Count) const
{	
return ((int)(_Count < (size_t)(_Last1 - _First1)
? _Count : _Last1 - _First1));	
}
};
		
template<class _Elem,
class _Byte,
class _Statype>
locale::id codecvt<_Elem, _Byte, _Statype>::id;
		
template<> class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
: public codecvt_base
{	
public:
typedef wchar_t _Elem;
typedef char _Byte;
typedef _Mbstatet _Statype;
typedef _Elem intern_type;
typedef _Byte extern_type;
typedef _Statype state_type;
	result  in(_Statype& _State,
const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
{	
return (do_in(_State,
_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
}
	result  out(_Statype& _State,
const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
return (do_out(_State,
_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
}
	result  unshift(_Statype& _State,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
return (do_unshift(_State,
_First2, _Last2, _Mid2));
}
	int  length(const _Statype& _State, const _Byte *_First1,
const _Byte *_Last1, size_t _Count) const
{	
return (do_length(_State, _First1, _Last1, _Count));
}
	static  locale::id& __cdecl _Id_func();
	 static locale::id id;	
	explicit  codecvt(size_t _Refs = 0)
: codecvt_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
: codecvt_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
_Locinfo(_Ploc->name()));
return (2);
}
protected:
virtual  ~codecvt()
{	
}
protected:
void  _Init(const _Locinfo& _Lobj)
{	
_Cvt = _Lobj._Getcvt();
}
	virtual result  do_in(_Statype& _State,
const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
{	
;
;
_Mid1 = _First1, _Mid2 = _First2;
result _Ans = _Mid1 == _Last1 ? ok : partial;
int _Bytes;
		while (_Mid1 != _Last1 && _Mid2 != _Last2)
switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
&_State, &_Cvt))
{	
case -2:	
_Mid1 = _Last1;
return (_Ans);
			case -1:	
return (error);
			case 0:	
if (*_Mid2 == (_Elem)0)
_Bytes = (int)::strlen(_Mid1) + 1;
			default:	
if (_Bytes == -3)
_Bytes = 0;	
_Mid1 += _Bytes;
++_Mid2;
_Ans = ok;
}
return (_Ans);
}
	virtual result  do_out(_Statype& _State,
const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
;
;
_Mid1 = _First1, _Mid2 = _First2;
result _Ans = _Mid1 == _Last1 ? ok : partial;
int _Bytes;
		while (_Mid1 != _Last1 && _Mid2 != _Last2)
if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
&_State, &_Cvt)) < 0)
return (error);	
else
++_Mid1, _Mid2 += _Bytes, _Ans = ok;
else
{	
_Byte _Buf[5];
_Statype _Stsave = _State;
				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
&_State, &_Cvt)) < 0)
return (error);	
else if (_Last2 - _Mid2 < _Bytes)
{	
_State = _Stsave;
return (_Ans);
}
else
{	
::memcpy_s((_Mid2), (_Last2 - _Mid2), (_Buf), (_Bytes));
++_Mid1, _Mid2 += _Bytes, _Ans = ok;
}
}
return (_Ans);
}
	virtual result  do_unshift(_Statype& _State,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
;
_Mid2 = _First2;
result _Ans = ok;
int _Bytes;
_Byte _Buf[5];
_Statype _Stsave = _State;
		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
_Ans = error;	
else if (_Last2 - _Mid2 < --_Bytes)
{	
_State = _Stsave;
_Ans = partial;
}
else if (0 < _Bytes)
{	
::memcpy_s((_Mid2), (_Last2 - _Mid2), (_Buf), (_Bytes));
_Mid2 += _Bytes;
}
return (_Ans);
}
	virtual int  do_length(const _Statype& _State, const _Byte *_First1,
const _Byte *_Last1, size_t _Count) const
{	
 
		;
int _Wchars;
const _Byte *_Mid1;
_Statype _Mystate = _State;
		for (_Wchars = 0, _Mid1 = _First1;
(size_t)_Wchars < _Count && _Mid1 != _Last1; )
{	
int _Bytes;
_Elem _Ch;
			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
&_Mystate, &_Cvt))
{	
case -2:	
return (_Wchars);
			case -1:	
return (_Wchars);
			case 0:	
if (_Ch == (_Elem)0)
_Bytes = (int)::strlen(_Mid1) + 1;
			default:	
if (_Bytes == -3)
_Bytes = 0;	
_Mid1 += _Bytes;
++_Wchars;
}
}
return (_Wchars);
		}
	virtual bool  do_always_noconv() const throw ()
{	
return (false);
}
	virtual int  do_max_length() const throw ()
{	
return (5);
}
private:
_Locinfo::_Cvtvec _Cvt;	
};
		
template<> class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
: public codecvt_base
{	
public:
typedef unsigned short _Elem;
typedef char _Byte;
typedef _Mbstatet _Statype;
typedef _Elem intern_type;
typedef _Byte extern_type;
typedef _Statype state_type;
	result  in(_Statype& _State,
const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
{	
return (do_in(_State,
_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
}
	result  out(_Statype& _State,
const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
return (do_out(_State,
_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
}
	result  unshift(_Statype& _State,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
return (do_unshift(_State,
_First2, _Last2, _Mid2));
}
	int  length(const _Statype& _State, const _Byte *_First1,
const _Byte *_Last1, size_t _Count) const
{	
return (do_length(_State, _First1, _Last1, _Count));
}
	static  locale::id& __cdecl _Id_func();
	 static locale::id id;	
	explicit  codecvt(size_t _Refs = 0)
: codecvt_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
: codecvt_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
_Locinfo(_Ploc->name()));
return (2);
}
protected:
virtual  ~codecvt()
{	
}
protected:
codecvt(const char *_Locname, size_t _Refs = 0)
: codecvt_base(_Refs)
{	
{ _Locinfo _Lobj(_Locname);
_Init(_Lobj);
}
}
	void  _Init(const _Locinfo& _Lobj)
{	
_Cvt = _Lobj._Getcvt();
}
	virtual result  do_in(_Statype& _State,
const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
{	
;
;
_Mid1 = _First1, _Mid2 = _First2;
result _Ans = _Mid1 == _Last1 ? ok : partial;
int _Bytes;
		while (_Mid1 != _Last1 && _Mid2 != _Last2)
switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
&_State, &_Cvt))
{	
case -2:	
_Mid1 = _Last1;
return (_Ans);
			case -1:	
return (error);
			case 0:	
if (*_Mid2 == (_Elem)0)
_Bytes = (int)::strlen(_Mid1) + 1;
			default:	
if (_Bytes == -3)
_Bytes = 0;	
_Mid1 += _Bytes;
++_Mid2;
_Ans = ok;
}
return (_Ans);
}
	virtual result  do_out(_Statype& _State,
const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
;
;
_Mid1 = _First1, _Mid2 = _First2;
result _Ans = _Mid1 == _Last1 ? ok : partial;
int _Bytes;
		while (_Mid1 != _Last1 && _Mid2 != _Last2)
if (5 <= _Last2 - _Mid2)
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
&_State, &_Cvt)) < 0)
return (error);	
else
++_Mid1, _Mid2 += _Bytes, _Ans = ok;
else
{	
_Byte _Buf[5];
_Statype _Stsave = _State;
				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
&_State, &_Cvt)) < 0)
return (error);	
else if (_Last2 - _Mid2 < _Bytes)
{	
_State = _Stsave;
return (_Ans);
}
else
{	
::memcpy_s((_Mid2), (_Last2 - _Mid2), (_Buf), (_Bytes));
++_Mid1, _Mid2 += _Bytes, _Ans = ok;
}
}
return (_Ans);
}
	virtual result  do_unshift(_Statype& _State,
_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
{	
;
_Mid2 = _First2;
result _Ans = ok;
int _Bytes;
_Byte _Buf[5];
_Statype _Stsave = _State;
		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
_Ans = error;	
else if (_Last2 - _Mid2 < --_Bytes)
{	
_State = _Stsave;
_Ans = partial;
}
else if (0 < _Bytes)
{	
::memcpy_s((_Mid2), (_Last2 - _Mid2), (_Buf), (_Bytes));
_Mid2 += _Bytes;
}
return (_Ans);
}
	virtual int  do_length(const _Statype& _State, const _Byte *_First1,
const _Byte *_Last1, size_t _Count) const
{	
;
int _Wchars;
const _Byte *_Mid1;
_Statype _Mystate = _State;
		for (_Wchars = 0, _Mid1 = _First1;
(size_t)_Wchars < _Count && _Mid1 != _Last1; )
{	
int _Bytes;
_Elem _Ch;
			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
&_Mystate, &_Cvt))
{	
case -2:	
return (_Wchars);
			case -1:	
return (_Wchars);
			case 0:	
if (_Ch == (_Elem)0)
_Bytes = (int)::strlen(_Mid1) + 1;
			default:	
if (_Bytes == -3)
_Bytes = 0;	
_Mid1 += _Bytes;
++_Wchars;
}
}
return (_Wchars);
}
	virtual bool  do_always_noconv() const throw ()
{	
return (false);
}
	virtual int  do_max_length() const throw ()
{	
return (5);
}
private:
_Locinfo::_Cvtvec _Cvt;	
};
		
template<class _Elem,
class _Byte,
class _Statype>
class codecvt_byname
: public codecvt<_Elem, _Byte, _Statype>
{	
public:
explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
: codecvt<_Elem, _Byte, _Statype>(_Locname, _Refs)
{	
}
protected:
virtual  ~codecvt_byname()
{	
}
};
#pragma warning(push)
#pragma warning(disable:4275)
struct __declspec(dllimport) ctype_base
: public locale::facet
{	
enum
{	
alnum = 0x4|0x2|0x1|0x100, alpha = 0x2|0x1|0x100,
cntrl = 0x20, digit = 0x4, graph = 0x4|0x2|0x10|0x1|0x100,
lower = 0x2, print = 0x4|0x2|0x10|0x40|0x1|0x100|0x80,
punct = 0x10, space = 0x8|0x40|0x000, upper = 0x1,
xdigit = 0x80};
typedef short mask;	
	 ctype_base(size_t _Refs = 0)
: locale::facet(_Refs)
{	
}
	 ~ctype_base()
{	
}
protected:
static void __cdecl _Xran()
{	
throw out_of_range("out_of_range in ctype<T>");
}
};
#pragma warning(pop)
		
template<class _Elem>
class ctype
: public ctype_base
{	
public:
typedef _Elem char_type;
	bool  is(mask _Maskval, _Elem _Ch) const
{	
return (do_is(_Maskval, _Ch));
}
	const _Elem * is(const _Elem *_First, const _Elem *_Last,
mask *_Dest) const
{	
return (do_is(_First, _Last, _Dest));
}
	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
const _Elem *_Last) const
{	
return (do_scan_is(_Maskval, _First, _Last));
}
	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
const _Elem *_Last) const
{	
return (do_scan_not(_Maskval, _First, _Last));
}
	_Elem  tolower(_Elem _Ch) const
{	
return (do_tolower(_Ch));
}
	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
{	
return (do_tolower(_First, _Last));
}
	_Elem  toupper(_Elem _Ch) const
{	
return (do_toupper(_Ch));
}
	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
{	
return (do_toupper(_First, _Last));
}
	_Elem  widen(char _Byte) const
{	
return (do_widen(_Byte));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const char * widen(const char *_First, const char *_Last,
_Elem *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
}
	const char * _Widen_s(const char *_First, const char *_Last,
_Elem *_Dest, size_t _Dest_size) const
{	
return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
}
	char  narrow(_Elem _Ch, char _Dflt = '\0') const
{	
return (do_narrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
}
	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, size_t _Dest_size) const
{	
return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
}
	 static locale::id id;	
	explicit  ctype(size_t _Refs = 0)
: ctype_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
: ctype_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new ctype<_Elem>(
_Locinfo(_Ploc->name()));
return (2);
}
protected:
virtual  ~ctype()
{	
if (_Ctype._Delfl)
free((void *)_Ctype._Table);
}
protected:
void  _Init(const _Locinfo& _Lobj)
{	
_Ctype = _Lobj._Getctype();
}
	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
{	
return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
& _Maskval) != 0);
}
	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
mask *_Dest) const
{	
;
;
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
return (_First);
}
	virtual const _Elem * do_scan_is(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && !is(_Maskval, *_First); ++_First)
;
return (_First);
}
	virtual const _Elem * do_scan_not(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && is(_Maskval, *_First); ++_First)
;
return (_First);
}
	virtual _Elem  do_tolower(_Elem _Ch) const
{	
unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
if (_Byte == '\0')
return (_Ch);
else
return (widen((char)_Tolower(_Byte, &_Ctype)));
}
	virtual const _Elem * do_tolower(_Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
{	
unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
if (_Byte != '\0')
*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
}
return ((const _Elem *)_First);
}
	virtual _Elem  do_toupper(_Elem _Ch) const
{	
unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
if (_Byte == '\0')
return (_Ch);
else
return (widen((char)_Toupper(_Byte, &_Ctype)));
}
	virtual const _Elem * do_toupper(_Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
{	
unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
if (_Byte != '\0')
*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
}
return ((const _Elem *)_First);
}
	virtual _Elem  do_widen(char _Byte) const
{	
return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const char * do_widen(const char *_First,
const char *_Last, _Elem *_Dest) const
{	
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
}
	virtual const char * _Do_widen_s(const char *_First,
const char *_Last, _Elem *_Dest, size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
return (_First);
}
	char  _Donarrow(_Elem _Ch, char _Dflt) const
{	
char _Byte;
if (_Ch == (_Elem)0)
return ('\0');
else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
return (_Dflt);
else
return (_Byte);
}
	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
{	
return (_Donarrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const _Elem * do_narrow(const _Elem *_First,
const _Elem *_Last, char _Dflt, [SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
}
	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
const _Elem *_Last, char _Dflt, 
[SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Donarrow(*_First, _Dflt);
return (_First);
}
private:
_Locinfo::_Ctypevec _Ctype;	
_Locinfo::_Cvtvec _Cvt;		
};
		
template<class _Elem>
locale::id ctype<_Elem>::id;
		
template<> class __declspec(dllimport) ctype<char>
: public ctype_base
{	
typedef ctype<char> _Myt;
public:
typedef char _Elem;
typedef _Elem char_type;
	bool  is(mask _Maskval, _Elem _Ch) const
{	
return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
}
	const _Elem * is(const _Elem *_First,
const _Elem *_Last, mask *_Dest) const
{	
;
;
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Ctype._Table[(unsigned char)*_First];
return (_First);
}
	const _Elem * scan_is(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && !is(_Maskval, *_First); ++_First)
;
return (_First);
}
	const _Elem * scan_not(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && is(_Maskval, *_First); ++_First)
;
return (_First);
}
	_Elem  tolower(_Elem _Ch) const
{	
return (do_tolower(_Ch));
}
	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
{	
return (do_tolower(_First, _Last));
}
	_Elem  toupper(_Elem _Ch) const
{	
return (do_toupper(_Ch));
}
	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
{	
return (do_toupper(_First, _Last));
}
	_Elem  widen(char _Byte) const
{	
return (do_widen(_Byte));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const _Elem * widen(const char *_First, const char *_Last,
_Elem *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
}
	const _Elem * _Widen_s(const char *_First, const char *_Last,
_Elem *_Dest, size_t _Dest_size) const
{	
return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
}
	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
{	
return (do_narrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
}
	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
}
	static  locale::id& __cdecl _Id_func();
	 static locale::id id;	
	explicit  ctype(const mask *_Table = 0,
bool _Deletetable = false,
size_t _Refs = 0)
: ctype_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
if (_Table != 0)
{	
_Tidy();
_Ctype._Table = _Table;
_Ctype._Delfl = _Deletetable ? -1 : 0;
}
}
	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
: ctype_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new ctype<_Elem>(
_Locinfo(_Ploc->name()));
return (2);
}
	 static const size_t table_size = 1 << 8;	
protected:
virtual  ~ctype()
{	
_Tidy();
}
protected:
void  _Init(const _Locinfo& _Lobj)
{	
_Ctype = _Lobj._Getctype();
}
	void  _Tidy()
{	
if (0 < _Ctype._Delfl)
free((void *)_Ctype._Table);
else if (_Ctype._Delfl < 0)
delete[] (void *)_Ctype._Table;
}
	virtual _Elem  do_tolower(_Elem _Ch) const
{	
return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
}
	virtual const _Elem * do_tolower(_Elem *_First,
const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
return ((const _Elem *)_First);
}
	virtual _Elem  do_toupper(_Elem _Ch) const
{	
return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
}
	virtual const _Elem * do_toupper(_Elem *_First,
const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
return ((const _Elem *)_First);
}
	virtual _Elem  do_widen(char _Byte) const
{	
return (_Byte);
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const _Elem * do_widen(const char *_First,
const char *_Last, _Elem *_Dest) const
{	
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
}
	virtual const _Elem * _Do_widen_s(const char *_First,
const char *_Last, _Elem *_Dest, size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
::memcpy_s((_Dest), (_Dest_size), (_First), (_Last - _First));
return (_Last);
}
	virtual _Elem  do_narrow(_Elem _Ch, char) const
{	
return (_Ch);
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const _Elem * do_narrow(const _Elem *_First,
const _Elem *_Last, char _Dflt, 
[SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
}
	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
const _Elem *_Last, char, [SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
::memcpy_s((_Dest), (_Dest_size), (_First), (_Last - _First));
return (_Last);
}
	const mask * table() const throw ()
{	
return (_Ctype._Table);
}
	static const mask *__cdecl classic_table() throw ()
{	
const _Myt& _Ctype_fac = use_facet<_Myt >(locale::classic());
return (_Ctype_fac.table());
}
private:
_Locinfo::_Ctypevec _Ctype;	
};
		
template<> class __declspec(dllimport) ctype<wchar_t>
: public ctype_base
{	
typedef ctype<wchar_t> _Myt;
public:
typedef wchar_t _Elem;
typedef _Elem char_type;
	bool  is(mask _Maskval, _Elem _Ch) const
{	
return (do_is(_Maskval, _Ch));
}
	const _Elem * is(const _Elem *_First, const _Elem *_Last,
mask *_Dest) const
{	
return (do_is(_First, _Last, _Dest));
}
	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
const _Elem *_Last) const
{	
return (do_scan_is(_Maskval, _First, _Last));
}
	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
const _Elem *_Last) const
{	
return (do_scan_not(_Maskval, _First, _Last));
}
	_Elem  tolower(_Elem _Ch) const
{	
return (do_tolower(_Ch));
}
	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
{	
return (do_tolower(_First, _Last));
}
	_Elem  toupper(_Elem _Ch) const
{	
return (do_toupper(_Ch));
}
	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
{	
return (do_toupper(_First, _Last));
}
	_Elem  widen(char _Byte) const
{	
return (do_widen(_Byte));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const char * widen(const char *_First, const char *_Last,
_Elem *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
}
	const char * _Widen_s(const char *_First, const char *_Last,
_Elem *_Dest, size_t _Dest_size) const
{	
return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
}
	char  narrow(_Elem _Ch, char _Dflt = '\0') const
{	
return (do_narrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
}
	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
}
	static  locale::id& __cdecl _Id_func();
	 static locale::id id;	
	explicit  ctype(size_t _Refs = 0)
: ctype_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
: ctype_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new ctype<_Elem>(
_Locinfo(_Ploc->name()));
return (2);
}
protected:
virtual  ~ctype()
{	
if (_Ctype._Delfl)
free((void *)_Ctype._Table);
}
protected:
void  _Init(const _Locinfo& _Lobj)
{	
_Ctype = _Lobj._Getctype();
_Cvt = _Lobj._Getcvt();
}
	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
{	
return ((::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
}
	virtual const wchar_t * do_is(const _Elem *_First,
const _Elem *_Last, mask *_Dest) const
{	
;
;
return (::_Getwctypes(_First, _Last, _Dest, &_Ctype));
}
	virtual const _Elem * do_scan_is(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && !is(_Maskval, *_First); ++_First)
;
return (_First);
}
	virtual const _Elem * do_scan_not(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && is(_Maskval, *_First); ++_First)
;
return (_First);
}
	virtual _Elem  do_tolower(_Elem _Ch) const
{	
return (_Towlower(_Ch, &_Ctype));
}
	virtual const _Elem * do_tolower(_Elem *_First,
const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
*_First = _Towlower(*_First, &_Ctype);
return ((const _Elem *)_First);
}
	virtual _Elem  do_toupper(_Elem _Ch) const
{	
return (_Towupper(_Ch, &_Ctype));
}
	virtual const _Elem * do_toupper(_Elem *_First,
const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
*_First = _Towupper(*_First, &_Ctype);
return ((const _Elem *)_First);
}
	_Elem  _Dowiden(char _Byte) const
{	
mbstate_t _Mbst = {0};
wchar_t _Wc;
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
? (wchar_t)(wint_t)(0xFFFF) : _Wc);
}
	virtual _Elem  do_widen(char _Byte) const
{	
return (_Dowiden(_Byte));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const char * do_widen(const char *_First,
const char *_Last, _Elem *_Dest) const
{	
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
}
	virtual const char * _Do_widen_s(const char *_First,
const char *_Last, _Elem *_Dest, size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Dowiden(*_First);
return (_First);
}
	char  _Donarrow(_Elem _Ch, char _Dflt) const
{	
char _Buf[5];
mbstate_t _Mbst = {0};
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
? _Dflt : _Buf[0]);
}
	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
{	
return (_Donarrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const _Elem * do_narrow(const _Elem *_First,
const _Elem *_Last, char _Dflt,  
[SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
}
	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
const _Elem *_Last, char _Dflt, 
[SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Donarrow(*_First, _Dflt);
return (_First);
}
private:
_Locinfo::_Ctypevec _Ctype;	
_Locinfo::_Cvtvec _Cvt;		
};
		
template<> class __declspec(dllimport) ctype<unsigned short>
: public ctype_base
{	
typedef ctype<unsigned short> _Myt;
public:
typedef unsigned short _Elem;
typedef _Elem char_type;
	bool  is(mask _Maskval, _Elem _Ch) const
{	
return (do_is(_Maskval, _Ch));
}
	const _Elem * is(const _Elem *_First, const _Elem *_Last,
mask *_Dest) const
{	
return (do_is(_First, _Last, _Dest));
}
	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
const _Elem *_Last) const
{	
return (do_scan_is(_Maskval, _First, _Last));
}
	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
const _Elem *_Last) const
{	
return (do_scan_not(_Maskval, _First, _Last));
}
	_Elem  tolower(_Elem _Ch) const
{	
return (do_tolower(_Ch));
}
	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
{	
return (do_tolower(_First, _Last));
}
	_Elem  toupper(_Elem _Ch) const
{	
return (do_toupper(_Ch));
}
	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
{	
return (do_toupper(_First, _Last));
}
	_Elem  widen(char _Byte) const
{	
return (do_widen(_Byte));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const char * widen(const char *_First, const char *_Last,
_Elem *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
}
	const char * _Widen_s(const char *_First, const char *_Last,
_Elem *_Dest, size_t _Dest_size) const
{	
return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
}
	char  narrow(_Elem _Ch, char _Dflt = '\0') const
{	
return (do_narrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
#pragma warning(push)
#pragma warning(disable:4996)
return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
}
	const _Elem * _Narrow_s(const _Elem *_First, const _Elem *_Last,
char _Dflt, [SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
}
	static  locale::id& __cdecl _Id_func();
	 static locale::id id;	
	explicit  ctype(size_t _Refs = 0)
: ctype_base(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
: ctype_base(_Refs)
{	
_Init(_Lobj);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new ctype<_Elem>(
_Locinfo(_Ploc->name()));
return (2);
}
protected:
virtual  ~ctype()
{	
if (_Ctype._Delfl)
free((void *)_Ctype._Table);
}
protected:
ctype(const char *_Locname, size_t _Refs = 0)
: ctype_base(_Refs)
{	
{ _Locinfo _Lobj(_Locname);
_Init(_Lobj);
}
}
	void  _Init(const _Locinfo& _Lobj)
{	
_Ctype = _Lobj._Getctype();
_Cvt = _Lobj._Getcvt();
}
	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
{	
return ((::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
}
	virtual const _Elem * do_is(const _Elem *_First,
const _Elem *_Last, mask *_Dest) const
{	
;
;
return ((const _Elem *)::_Getwctypes((const wchar_t *)_First,
(const wchar_t *)_Last, _Dest, &_Ctype));
}
	virtual const _Elem * do_scan_is(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && !is(_Maskval, *_First); ++_First)
;
return (_First);
}
	virtual const _Elem * do_scan_not(mask _Maskval,
const _Elem *_First, const _Elem *_Last) const
{	
;
for (; _First != _Last && is(_Maskval, *_First); ++_First)
;
return (_First);
}
	virtual _Elem  do_tolower(_Elem _Ch) const
{	
return (_Towlower(_Ch, &_Ctype));
}
	virtual const _Elem * do_tolower(_Elem *_First,
const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
*_First = _Towlower(*_First, &_Ctype);
return ((const _Elem *)_First);
}
	virtual _Elem  do_toupper(_Elem _Ch) const
{	
return (_Towupper(_Ch, &_Ctype));
}
	virtual const _Elem * do_toupper(_Elem *_First,
const _Elem *_Last) const
{	
;
for (; _First != _Last; ++_First)
*_First = _Towupper(*_First, &_Ctype);
return ((const _Elem *)_First);
}
	_Elem  _Dowiden(char _Byte) const
{	
mbstate_t _Mbst = {0};
unsigned short _Wc;
return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
? (unsigned short)(wint_t)(0xFFFF) : _Wc);
}
	virtual _Elem  do_widen(char _Byte) const
{	
return (_Dowiden(_Byte));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const char * do_widen(const char *_First,
const char *_Last, _Elem *_Dest) const
{	
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
}
	virtual const char * _Do_widen_s(const char *_First,
const char *_Last, _Elem *_Dest, size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Dowiden(*_First);
return (_First);
}
	char  _Donarrow(_Elem _Ch, char _Dflt) const
{	
char _Buf[5];
mbstate_t _Mbst = {0};
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
? _Dflt : _Buf[0]);
}
	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
{	
return (_Donarrow(_Ch, _Dflt));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual const _Elem * do_narrow(const _Elem *_First,
const _Elem *_Last, char _Dflt, [SA_Pre(Null=SA_No,WritableElements="\n@""_Last-_First")] [SA_Pre(Deref=1,Valid=SA_No)] char *_Dest) const
{	
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
}
	virtual const _Elem * _Do_narrow_s(const _Elem *_First,
const _Elem *_Last, char _Dflt, 
[SA_Pre(Null=SA_No,WritableElements="_Dest_size")] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(ValidElements="\n@""_Last-_First")] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Dest, 
size_t _Dest_size) const
{	
;
;
{ if (!(_Dest_size >= (size_t)(_Last - _First))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Donarrow(*_First, _Dflt);
return (_First);
}
private:
_Locinfo::_Ctypevec _Ctype;	
_Locinfo::_Cvtvec _Cvt;		
};
		
template<class _Elem>
class ctype_byname
: public ctype<_Elem>
{	
public:
explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
: ctype<_Elem>(_Locname, _Refs)
{	
}
protected:
virtual  ~ctype_byname()
{	
}
};
		
template<> class ctype_byname<char>
: public ctype<char>
{	
public:
explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
: ctype<char>(_Locname, _Refs)
{	
}
protected:
virtual  ~ctype_byname()
{	
}
};
 
template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;
 
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable:4412)
namespace std {
 
 
 
 
 
 
 
 
 
 
 
		
template<class _Dummy>
class _Iosb
{	
public:
enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
{	
_Fmtmask = 0xffff, _Fmtzero = 0};
	static const _Fmtflags skipws = (_Fmtflags)0x0001;
static const _Fmtflags unitbuf = (_Fmtflags)0x0002;
static const _Fmtflags uppercase = (_Fmtflags)0x0004;
static const _Fmtflags showbase = (_Fmtflags)0x0008;
static const _Fmtflags showpoint = (_Fmtflags)0x0010;
static const _Fmtflags showpos = (_Fmtflags)0x0020;
static const _Fmtflags left = (_Fmtflags)0x0040;
static const _Fmtflags right = (_Fmtflags)0x0080;
static const _Fmtflags internal = (_Fmtflags)0x0100;
static const _Fmtflags dec = (_Fmtflags)0x0200;
static const _Fmtflags oct = (_Fmtflags)0x0400;
static const _Fmtflags hex = (_Fmtflags)0x0800;
static const _Fmtflags scientific = (_Fmtflags)0x1000;
static const _Fmtflags fixed = (_Fmtflags)0x2000;
	static const _Fmtflags hexfloat =
(_Fmtflags)0x3000;	
	static const _Fmtflags boolalpha = (_Fmtflags)0x4000;
static const _Fmtflags _Stdio = (_Fmtflags)0x8000;
static const _Fmtflags adjustfield = (_Fmtflags)(0x0040
| 0x0080 | 0x0100);
static const _Fmtflags basefield = (_Fmtflags)(0x0200
| 0x0400 | 0x0800);
static const _Fmtflags floatfield = (_Fmtflags)(0x1000
| 0x2000);
	enum _Iostate
{	
_Statmask = 0x17};
	static const _Iostate goodbit = (_Iostate)0x0;
static const _Iostate eofbit = (_Iostate)0x1;
static const _Iostate failbit = (_Iostate)0x2;
static const _Iostate badbit = (_Iostate)0x4;
static const _Iostate _Hardfail = (_Iostate)0x10;
	enum _Openmode
{	
_Openmask = 0xff};
	static const _Openmode in = (_Openmode)0x01;
static const _Openmode out = (_Openmode)0x02;
static const _Openmode ate = (_Openmode)0x04;
static const _Openmode app = (_Openmode)0x08;
static const _Openmode trunc = (_Openmode)0x10;
static const _Openmode _Nocreate = (_Openmode)0x40;
static const _Openmode _Noreplace = (_Openmode)0x80;
static const _Openmode binary = (_Openmode)0x20;
	enum _Seekdir
{	
_Seekmask = 0x3};
static const _Seekdir beg = (_Seekdir)0;
static const _Seekdir cur = (_Seekdir)1;
static const _Seekdir end = (_Seekdir)2;
	enum
{	
_Openprot = 0x40};
};
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags
_Iosb<_Dummy>::hexfloat;	
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;
		
class __declspec(dllimport) ios_base
: public _Iosb<int>
{	
public:
typedef int fmtflags;
typedef int iostate;
typedef int openmode;
typedef int seekdir;
	typedef std::streamoff streamoff;
typedef std::streampos streampos;
	enum event
{	
erase_event, imbue_event, copyfmt_event};
	typedef void (__cdecl *event_callback)(event, ios_base&, int);
typedef unsigned int io_state, open_mode, seek_dir;
			
class failure
: public runtime_error
{	
public:
explicit  failure(const string &_Message)
: runtime_error(_Message)
{	
}
		virtual  ~failure() throw ()
{	
}
		};
			
class __declspec(dllimport) Init
{	
public:
Init()
{
_Init_ctor(this);
}
		 ~Init()
{
_Init_dtor(this);
}
	private:
static  void __cdecl _Init_ctor(Init *);
static  void __cdecl _Init_dtor(Init *);
		 static int& __cdecl _Init_cnt_func();	
		 static int _Init_cnt;	
		};
	ios_base&  operator=(const ios_base& _Right)
{	
if (this != &_Right)
{	
_Mystate = _Right._Mystate;
copyfmt(_Right);
}
return (*this);
}
	 operator void *() const
{	
return (fail() ? 0 : (void *)this);
}
	bool  operator!() const
{	
return (fail());
}
    void  clear(iostate _State, bool _Reraise)
{	
_Mystate = (iostate)(_State & _Statmask);
if ((_Mystate & _Except) == 0)
;
else if (_Reraise)
throw;
else if (_Mystate & _Except & badbit)
throw failure("ios_base::badbit set");
else if (_Mystate & _Except & failbit)
throw failure("ios_base::failbit set");
else
throw failure("ios_base::eofbit set");
}
	void  clear(iostate _State = goodbit)
{	
clear(_State, false);
}
	void  clear(io_state _State)
{	
clear((iostate)_State);
}
	iostate  rdstate() const
{	
return (_Mystate);
}
	void  setstate(iostate _State, bool _Exreraise)
{	
if (_State != goodbit)
clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
}
	void  setstate(iostate _State)
{	
if (_State != goodbit)
clear((iostate)((int)rdstate() | (int)_State), false);
}
	void  setstate(io_state _State)
{	
setstate((iostate)_State);
}
	bool  good() const
{	
return (rdstate() == goodbit);
}
	bool  eof() const
{	
return ((int)rdstate() & (int)eofbit);
}
	bool  fail() const
{	
return (((int)rdstate()
& ((int)badbit | (int)failbit)) != 0);
}
	bool  bad() const
{	
return (((int)rdstate() & (int)badbit) != 0);
}
	
	
iostate  exceptions() const
{	
return (_Except);
}
	void  exceptions(iostate _Newexcept)
{	
_Except = (iostate)((int)_Newexcept & (int)_Statmask);
clear(_Mystate);
}
	void  exceptions(io_state _State)
{	
exceptions((iostate)_State);
}
	fmtflags  flags() const
{	
return (_Fmtfl);
}
	fmtflags  flags(fmtflags _Newfmtflags)
{	
fmtflags _Oldfmtflags = _Fmtfl;
_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
return (_Oldfmtflags);
}
	fmtflags  setf(fmtflags _Newfmtflags)
{	
ios_base::fmtflags _Oldfmtflags = _Fmtfl;
_Fmtfl = (fmtflags)((int)_Fmtfl
| (int)_Newfmtflags & (int)_Fmtmask);
return (_Oldfmtflags);
}
	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
{	
ios_base::fmtflags _Oldfmtflags = _Fmtfl;
_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
return (_Oldfmtflags);
}
	void  unsetf(fmtflags _Mask)
{	
_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
}
	streamsize  precision() const
{	
return (_Prec);
}
	streamsize  precision(streamsize _Newprecision)
{	
streamsize _Oldprecision = _Prec;
_Prec = _Newprecision;
return (_Oldprecision);
}
	streamsize  width() const
{	
return (_Wide);
}
	streamsize  width(streamsize _Newwidth)
{	
streamsize _Oldwidth = _Wide;
_Wide = _Newwidth;
return (_Oldwidth);
}
	locale  getloc() const
{	
return (*_Ploc);
}
	locale  imbue(const locale& _Loc)
{	
locale _Oldlocale = *_Ploc;
*_Ploc = _Loc;
_Callfns(imbue_event);
return (_Oldlocale);
}
	static int __cdecl xalloc()
{	
{ ::std:: _Lockit _Lock(2);	
return (_Index++);
}
}
	long&  iword(int _Idx)
{	
return (_Findarr(_Idx)._Lo);
}
	void *&  pword(int _Idx)
{	
return (_Findarr(_Idx)._Vp);
}
	void  register_callback(event_callback _Pfn, int _Idx)
{	
_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
}
	ios_base&  copyfmt(const ios_base& _Other)
{	
if (this != &_Other)
{	
_Tidy();
*_Ploc = *_Other._Ploc;
_Fmtfl = _Other._Fmtfl;
_Prec = _Other._Prec;
_Wide = _Other._Wide;
_Iosarray *_Ptr = _Other._Arr;
            for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
{	
iword(_Ptr->_Index) = _Ptr->_Lo;
pword(_Ptr->_Index) = _Ptr->_Vp;
}
            for (_Fnarray *_Q = _Other._Calls; _Q != 0; _Q = _Q->_Next)
register_callback(_Q->_Pfn, _Q->_Index);	
            _Callfns(copyfmt_event);	
exceptions(_Other._Except);	
}
return (*this);
}
	virtual  ~ios_base()
{
_Ios_base_dtor(this);
}
	static bool __cdecl sync_with_stdio(bool _Newsync = true)
{	
{ ::std:: _Lockit _Lock(2);	
const bool _Oldsync = _Sync;
_Sync = _Newsync;
return (_Oldsync);
}
}
	static  void __cdecl _Addstd(ios_base *);
size_t _Stdstr;	
protected:
ios_base()
{	
}
	void  _Init()
{	
_Ploc = 0;
_Stdstr = 0;
_Except = goodbit;
_Fmtfl = skipws | dec;
_Prec = 6;
_Wide = 0;
_Arr = 0;
_Calls = 0;
clear(goodbit);
_Ploc = new locale;
}
private:
	struct _Iosarray
{	
public:
_Iosarray(int _Idx, _Iosarray *_Link)
: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
{	
}
		_Iosarray *_Next;	
int _Index;	
long _Lo;	
void *_Vp;	
};
			
struct _Fnarray
{	
_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
{	
}
		_Fnarray *_Next;	
int _Index;	
event_callback _Pfn;	
};
	void  _Callfns(event _Ev)
{	
for (_Fnarray *_Ptr = _Calls; _Ptr != 0; _Ptr = _Ptr->_Next)
(*_Ptr->_Pfn)(_Ev, *this, _Ptr->_Index);
}
	_Iosarray&  _Findarr(int _Idx)
{	
_Iosarray *_Ptr, *_Q;
        for (_Ptr = _Arr, _Q = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
if (_Ptr->_Index == _Idx)
return (*_Ptr);	
else if (_Q == 0 && _Ptr->_Lo == 0 && _Ptr->_Vp == 0)
_Q = _Ptr;	
        if (_Q != 0)
{	
_Q->_Index = _Idx;
return (*_Q);
}
        _Arr = new _Iosarray(_Idx, _Arr);	
return (*_Arr);
}
	void __cdecl _Tidy()
{	
_Callfns(erase_event);
_Iosarray *_Q1, *_Q2;
        for (_Q1 = _Arr; _Q1 != 0; _Q1 = _Q2)
_Q2 = _Q1->_Next, delete (_Q1);	
_Arr = 0;
        _Fnarray *_Q3, *_Q4;
for (_Q3 = _Calls; _Q3 != 0; _Q3 = _Q4)
_Q4 = _Q3->_Next, delete (_Q3);	
_Calls = 0;
}
    static  void __cdecl _Ios_base_dtor(ios_base *);
	iostate _Mystate;	
iostate _Except;	
fmtflags _Fmtfl;	
streamsize _Prec;	
streamsize _Wide;	
_Iosarray *_Arr;	
_Fnarray *_Calls;	
locale *_Ploc;	
	 static int _Index;	
static bool _Sync;	
    static  int& __cdecl _Index_func();
static  bool& __cdecl _Sync_func();
};
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Elem,
class _Traits>
class basic_streambuf
{	
	basic_streambuf(const basic_streambuf<_Elem, _Traits>&);	
basic_streambuf<_Elem, _Traits>&
operator=(const basic_streambuf<_Elem, _Traits>&);	
protected:
basic_streambuf()
: _Plocale(new(locale))
{	
_Init();
}
	basic_streambuf(_Uninitialized)
{	
}
public:
typedef basic_streambuf<_Elem, _Traits> _Myt;
typedef _Elem char_type;
typedef _Traits traits_type;
	virtual  ~basic_streambuf()
{	
delete (_Plocale);
}
	typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	pos_type pubseekoff(off_type _Off, ios_base::seekdir _Way,
ios_base::openmode _Mode = ios_base::in | ios_base::out)
{	
return (seekoff(_Off, _Way, _Mode));
}
	pos_type pubseekoff(off_type _Off, ios_base::seek_dir _Way,
ios_base::open_mode _Mode)
{	
return (pubseekoff(_Off, (ios_base::seekdir)_Way,
(ios_base::openmode)_Mode));
}
	pos_type pubseekpos(pos_type _Pos,
ios_base::openmode _Mode = ios_base::in | ios_base::out)
{	
return (seekpos(_Pos, _Mode));
}
	pos_type pubseekpos(pos_type _Pos, ios_base::open_mode _Mode)
{	
return (seekpos(_Pos, (ios_base::openmode)_Mode));
}
	_Myt *pubsetbuf(_Elem *_Buffer, streamsize _Count)
{	
return (setbuf(_Buffer, _Count));
}
	locale pubimbue(const locale &_Newlocale)
{	
locale _Oldlocale = *_Plocale;
imbue(_Newlocale);
*_Plocale = _Newlocale;
return (_Oldlocale);
}
	locale getloc() const
{	
return (*_Plocale);
}
	streamsize in_avail()
{	
streamsize _Res = _Gnavail();
return (0 < _Res ? _Res : showmanyc());
}
	int pubsync()
{	
return (sync());
}
	int_type sbumpc()
{	
return (0 < _Gnavail()
? _Traits::to_int_type(*_Gninc()) : uflow());
}
	int_type sgetc()
{	
return (0 < _Gnavail()
? _Traits::to_int_type(*gptr()) : underflow());
}
	streamsize _Sgetn_s(_Elem *_Ptr, size_t _Ptr_size, streamsize _Count)
{	
return _Xsgetn_s(_Ptr, _Ptr_size, _Count);
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
streamsize sgetn(_Elem *_Ptr, streamsize _Count)
{	
#pragma warning(push)
#pragma warning(disable:4996)
return xsgetn(_Ptr, _Count);
#pragma warning(pop)
}
	int_type snextc()
{	
return (1 < _Gnavail()
? _Traits::to_int_type(*_Gnpreinc())
: _Traits::eq_int_type(_Traits::eof(), sbumpc())
? _Traits::eof() : sgetc());
}
	int_type sputbackc(_Elem _Ch)
{	
return (gptr() != 0 && eback() < gptr()
&& _Traits::eq(_Ch, gptr()[-1])
? _Traits::to_int_type(*_Gndec())
: pbackfail(_Traits::to_int_type(_Ch)));
}
	void stossc()
{	
if (0 < _Gnavail())
_Gninc();
else
uflow();
}
	int_type sungetc()
{	
return (gptr() != 0 && eback() < gptr()
? _Traits::to_int_type(*_Gndec()) : pbackfail());
}
	int_type sputc(_Elem _Ch)
{	
return (0 < _Pnavail()
? _Traits::to_int_type(*_Pninc() = _Ch)
: overflow(_Traits::to_int_type(_Ch)));
}
	streamsize sputn(const _Elem *_Ptr, streamsize _Count)
{	
return (xsputn(_Ptr, _Count));
}
	void _Lock()
{	
_Mylock._Lock();
}
	void _Unlock()
{	
_Mylock._Unlock();
}
protected:
_Elem *eback() const
{	
return (*_IGfirst);
}
	_Elem *gptr() const
{	
return (*_IGnext);
}
	_Elem *pbase() const
{	
return (*_IPfirst);
}
	_Elem *pptr() const
{	
return (*_IPnext);
}
	_Elem *egptr() const
{	
return (*_IGnext + *_IGcount);
}
	void gbump(int _Off)
{	
*_IGcount -= _Off;
*_IGnext += _Off;
}
	void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
{	
*_IGfirst = _First;
*_IGnext = _Next;
*_IGcount = (int)(_Last - _Next);
}
	_Elem *epptr() const
{	
return (*_IPnext + *_IPcount);
}
	_Elem *_Gndec()
{	
++*_IGcount;
return (--*_IGnext);
}
	_Elem *_Gninc()
{	
--*_IGcount;
return ((*_IGnext)++);
}
	_Elem *_Gnpreinc()
{	
--*_IGcount;
return (++(*_IGnext));
}
	streamsize _Gnavail() const
{	
return (*_IGnext != 0 ? *_IGcount : 0);
}
	void pbump(int _Off)
{	
*_IPcount -= _Off;
*_IPnext += _Off;
}
	void setp(_Elem *_First, _Elem *_Last)
{	
*_IPfirst = _First;
*_IPnext = _First;
*_IPcount = (int)(_Last - _First);
}
	void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
{	
*_IPfirst = _First;
*_IPnext = _Next;
*_IPcount = (int)(_Last - _Next);
}
	_Elem *_Pninc()
{	
--*_IPcount;
return ((*_IPnext)++);
}
	streamsize _Pnavail() const
{	
return (*_IPnext != 0 ? *_IPcount : 0);
}
	void _Init()
{	
_IGfirst = &_Gfirst, _IPfirst = &_Pfirst;
_IGnext = &_Gnext, _IPnext = &_Pnext;
_IGcount = &_Gcount, _IPcount = &_Pcount;
setp(0, 0), setg(0, 0, 0);
}
	void _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
_Elem **_Pf, _Elem **_Pn, int *_Pc)
{	
_IGfirst = _Gf, _IPfirst = _Pf;
_IGnext = _Gn, _IPnext = _Pn;
_IGcount = _Gc, _IPcount = _Pc;
}
	virtual int_type  overflow(int_type = _Traits::eof())
{	
return (_Traits::eof());
}
	virtual int_type  pbackfail(int_type = _Traits::eof())
{	
return (_Traits::eof());
}
	virtual streamsize  showmanyc()
{	
return (0);
}
	virtual int_type  underflow()
{	
return (_Traits::eof());
}
	virtual int_type  uflow()
{	
return (_Traits::eq_int_type(_Traits::eof(), underflow())
? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
virtual streamsize  xsgetn(_Elem * _Ptr,
streamsize _Count)
{	
		return _Xsgetn_s(_Ptr, (size_t)-1, _Count);
}
	virtual streamsize  _Xsgetn_s(_Elem * _Ptr,
size_t _Ptr_size, streamsize _Count)
{	
int_type _Meta;
streamsize _Stream_size, _Size, _Copied;
		for (_Copied = 0; 0 < _Count; )
if (0 < (_Stream_size = _Gnavail()))
{	
_Size = _Stream_size;
if (_Count < _Size)
_Size = _Count;
_Traits_helper::copy_s<_Traits>(_Ptr, _Ptr_size, gptr(), _Size);
_Ptr += _Size;
_Copied += _Size;
_Count -= _Size;
gbump((int)_Size);
}
else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
break;	
else
{	
*_Ptr++ = _Traits::to_char_type(_Meta);
++_Copied;
--_Count;
}
		return (_Copied);
}
	virtual streamsize  xsputn(const _Elem *_Ptr,
streamsize _Count)
{	
streamsize _Stream_size, _Size, _Copied;
		for (_Copied = 0; 0 < _Count; )
if (0 < (_Stream_size = _Pnavail()))
{	
_Size = _Stream_size;
if (_Count < _Size)
_Size = _Count;
_Traits_helper::copy_s<_Traits>(pptr(), _Stream_size, _Ptr, _Size);
_Ptr += _Size;
_Copied += _Size;
_Count -= _Size;
pbump((int)_Size);
}
else if (_Traits::eq_int_type(_Traits::eof(),
overflow(_Traits::to_int_type(*_Ptr))))
break;	
else
{	
++_Ptr;
++_Copied;
--_Count;
}
		return (_Copied);
}
	virtual pos_type  seekoff(off_type, ios_base::seekdir,
ios_base::openmode = ios_base::in | ios_base::out)
{	
return (streampos(_BADOFF));
}
	virtual pos_type  seekpos(pos_type,
ios_base::openmode = ios_base::in | ios_base::out)
{	
return (streampos(_BADOFF));
}
	virtual _Myt * setbuf(_Elem *, streamsize)
{	
return (this);
}
	virtual int  sync()
{	
return (0);
}
	virtual void  imbue(const locale&)
{	
}
private:
_Mutex _Mylock;	
_Elem *_Gfirst;	
_Elem *_Pfirst;	
_Elem **_IGfirst;	
_Elem **_IPfirst;	
_Elem *_Gnext;	
_Elem *_Pnext;	
_Elem **_IGnext;	
_Elem **_IPnext;	
int _Gcount;	
int _Pcount;	
int *_IGcount;	
int *_IPcount;	
locale *_Plocale;	
};
 
template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
 
		
template<class _Elem,
class _Traits>
class istreambuf_iterator
: public iterator<input_iterator_tag,
_Elem, typename _Traits::off_type, _Elem *, _Elem&>
{	
typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
typedef _Elem char_type;
typedef _Traits traits_type;
typedef basic_streambuf<_Elem, _Traits> streambuf_type;
typedef basic_istream<_Elem, _Traits> istream_type;
	typedef typename traits_type::int_type int_type;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
: _Strbuf(_Sb), _Got(_Sb == 0)
{	
}
	istreambuf_iterator(istream_type& _Istr) throw ()
: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
{	
}
	_Elem operator*() const
{	
if (!_Got)
((_Myt *)this)->_Peek();
 
		return (_Val);
}
	_Myt& operator++()
{	
 
		_Inc();
return (*this);
}
	_Myt operator++(int)
{	
if (!_Got)
_Peek();
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	bool equal(const _Myt& _Right) const
{	
if (!_Got)
((_Myt *)this)->_Peek();
if (!_Right._Got)
((_Myt *)&_Right)->_Peek();
return (_Strbuf == 0 && _Right._Strbuf == 0
|| _Strbuf != 0 && _Right._Strbuf != 0);
}
private:
void _Inc()
{	
if (_Strbuf == 0
|| traits_type::eq_int_type(traits_type::eof(),
_Strbuf->sbumpc()))
_Strbuf = 0, _Got = true;
else
_Got = false;
}
	_Elem _Peek()
{	
int_type _Meta;
if (_Strbuf == 0
|| traits_type::eq_int_type(traits_type::eof(),
_Meta = _Strbuf->sgetc()))
_Strbuf = 0;
else
_Val = traits_type::to_char_type(_Meta);
_Got = true;
return (_Val);
}
	streambuf_type *_Strbuf;	
bool _Got;	
_Elem _Val;	
};
		
template<class _Elem,
class _Traits> inline
bool  operator==(
const istreambuf_iterator<_Elem, _Traits>& _Left,
const istreambuf_iterator<_Elem, _Traits>& _Right)
{	
return (_Left.equal(_Right));
}
template<class _Elem,
class _Traits> inline
bool  operator!=(
const istreambuf_iterator<_Elem, _Traits>& _Left,
const istreambuf_iterator<_Elem, _Traits>& _Right)
{	
return (!(_Left == _Right));
}
		
template<class _Elem,
class _Traits>
class ostreambuf_iterator
: public _Outit
{	
typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
typedef _Elem char_type;
typedef _Traits traits_type;
typedef basic_streambuf<_Elem, _Traits> streambuf_type;
typedef basic_ostream<_Elem, _Traits> ostream_type;
	typedef _Range_checked_iterator_tag _Checked_iterator_category;
	ostreambuf_iterator(streambuf_type *_Sb) throw ()
: _Failed(false), _Strbuf(_Sb)
{	
}
	ostreambuf_iterator(ostream_type& _Ostr) throw ()
: _Failed(false), _Strbuf(_Ostr.rdbuf())
{	
}
	_Myt& operator=(_Elem _Right)
{	
if (_Strbuf == 0
|| traits_type::eq_int_type(_Traits::eof(),
_Strbuf->sputc(_Right)))
_Failed = true;
return (*this);
}
	_Myt& operator*()
{	
return (*this);
}
	_Myt& operator++()
{	
return (*this);
}
	_Myt& operator++(int)
{	
return (*this);
}
	bool failed() const throw ()
{	
return (_Failed);
}
private:
bool _Failed;	
streambuf_type *_Strbuf;	
};
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
		
extern "C" {
extern __declspec(dllimport) float __cdecl _Stofx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **,
long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **,
long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **,
long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **, int,
int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)] char **,
int, int *);
  
extern __declspec(dllimport) __int64 __cdecl _Stollx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)]  char **,
int, int *);
extern __declspec(dllimport) unsigned __int64 __cdecl _Stoullx(const char *,[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] [SA_Post(Deref=1,Null=SA_Maybe)] [SA_Post(Deref=2,Valid=SA_Yes)]  char **,
int, int *);
}
  
   
namespace std {
 
#pragma warning(push)
#pragma warning(disable:4275)
template<class _Elem>
class numpunct
: public locale::facet
{	
public:
typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
string_type;
typedef _Elem char_type;
	 static locale::id id;	
	_Elem  decimal_point() const
{	
return (do_decimal_point());
}
	_Elem  thousands_sep() const
{	
return (do_thousands_sep());
}
	string  grouping() const
{	
return (do_grouping());
}
	string_type  falsename() const
{	
return (do_falsename());
}
	string_type  truename() const
{	
return (do_truename());
}
	explicit  numpunct(size_t _Refs = 0)
: locale::facet(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
if (_Kseparator == 0)
_Kseparator =	
_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
}
}
	 numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
: locale::facet(_Refs)
{	
_Init(_Lobj, _Isdef);
}
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new numpunct<_Elem>(
_Locinfo(_Ploc->name()), 0, true);
return (4);
}
protected:
virtual  ~numpunct()
{	
_Tidy();
}
protected:
numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
: locale::facet(_Refs)
{	
{ _Locinfo _Lobj(_Locname);
_Init(_Lobj, _Isdef);
}
}
	void  _Init(const _Locinfo& _Lobj, bool _Isdef = false)
{	
const lconv *_Ptr = _Lobj._Getlconv();
		_Grouping = 0;
_Falsename = 0;
_Truename = 0;
		try {
_Grouping = _Maklocstr(_Ptr->grouping, (char *)0, _Lobj._Getcvt());
_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Lobj._Getcvt());
_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Lobj._Getcvt());
} catch (...) {
_Tidy();
throw;
}
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem *)0, _Lobj._Getcvt());
_Kseparator =
_Maklocchr(_Ptr->thousands_sep[0], (_Elem *)0, _Lobj._Getcvt());
		if (_Isdef)
{	
_Grouping = _Maklocstr("", (char *)0, _Lobj._Getcvt());
_Dp = _Maklocchr('.', (_Elem *)0, _Lobj._Getcvt());
_Kseparator = _Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
}
}
	virtual _Elem  do_decimal_point() const
{	
return (_Dp);
}
	virtual _Elem  do_thousands_sep() const
{	
return (_Kseparator);
}
	virtual string  do_grouping() const
{	
return (string(_Grouping));
}
	virtual string_type  do_falsename() const
{	
return (string_type(_Falsename));
}
	virtual string_type  do_truename() const
{	
return (string_type(_Truename));
}
private:
void  _Tidy()
{	
delete[] ((void *)_Grouping);
delete[] ((void *)_Falsename);
delete[] ((void *)_Truename);
}
	const char *_Grouping;	
_Elem _Dp;	
_Elem _Kseparator;	
const _Elem *_Falsename;	
const _Elem *_Truename;	
};
typedef numpunct<char> _Npc;
typedef numpunct<wchar_t> _Npwc;
		
template<class _Elem>
class numpunct_byname
: public numpunct<_Elem>
{	
public:
explicit  numpunct_byname(const char *_Locname, size_t _Refs = 0)
: numpunct<_Elem>(_Locname, _Refs)
{	
}
protected:
virtual  ~numpunct_byname()
{	
}
};
		
template<class _Elem>
locale::id numpunct<_Elem>::id;
		
template<class _Elem,
class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
class num_get
: public locale::facet
{	
public:
typedef numpunct<_Elem> _Mypunct;
typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
_Mystr;
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new num_get<_Elem, _InIt>(
_Locinfo(_Ploc->name()));
return (4);
}
	 static locale::id id;	
protected:
virtual  ~num_get()
{	
}
protected:
void _Init(const _Locinfo& _Lobj)
{	
_Cvt = _Lobj._Getcvt();
}
	_Locinfo::_Cvtvec _Cvt;		
public:
explicit  num_get(size_t _Refs = 0)
: locale::facet(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
: locale::facet(_Refs)
{	
_Init(_Lobj);
}
	typedef _Elem char_type;
typedef _InIt iter_type;
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase,	ios_base::iostate& _State,
_Bool& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase,	ios_base::iostate& _State,
unsigned short& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase,	ios_base::iostate& _State,
unsigned int& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
long& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
unsigned long& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
 
_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
__int64& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
unsigned __int64& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
float& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
double& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
long double& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
	_InIt  get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
void *& _Val) const
{	
return (do_get(_First, _Last, _Iosbase, _State, _Val));
}
protected:
virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
_Bool& _Val) const
{	
;
int _Ans = -1;	
		if (_Iosbase.flags() & ios_base::boolalpha)
{	
typedef typename _Mystr::size_type _Mystrsize;
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
_Mystr _Str((_Mystrsize)1, (char_type)0);
_Str += _Punct_fac.falsename();
_Str += (char_type)0;
_Str += _Punct_fac.truename();	
_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
}
else
{	
char _Ac[32], *_Ep;
int _Errno = 0;
const unsigned long _Ulo = ::_Stoulx(_Ac, &_Ep,
_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
_Iosbase.getloc()), &_Errno);
if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
_Ans = _Ulo;
}
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ans < 0)
_State |= ios_base::failbit;
else
_Val = _Ans != 0;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
unsigned short& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
_Iosbase.getloc());	
char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
const unsigned long _Ans =
::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
_State |= ios_base::failbit;
else
_Val = (unsigned short)(_Ac[0] == '-'
? 0 -_Ans : _Ans);	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
unsigned int& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
_Iosbase.getloc());	
char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
const unsigned long _Ans =
::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
_State |= ios_base::failbit;
else
_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
long& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
const long _Ans = ::_Stolx(_Ac, &_Ep,
_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
_Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
unsigned long& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
const unsigned long _Ans = ::_Stoulx(_Ac, &_Ep,
_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
_Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
 
virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
__int64& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
const __int64 _Ans = ::_Stollx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
unsigned __int64& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
const unsigned __int64 _Ans = ::_Stoullx(_Ac, &_Ep, _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
float& _Val) const
{	
;
char _Ac[8 + 36 + 16], *_Ep;
int _Errno = 0;
const float _Ans = ::_Stofx(_Ac, &_Ep,
_Getffld(_Ac, _First, _Last,
_Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
double& _Val) const
{	
;
char _Ac[8 + 36 + 16], *_Ep;
int _Errno = 0;
const double _Ans = ::_Stodx(_Ac, &_Ep,
_Getffld(_Ac, _First, _Last,
_Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
long double& _Val) const
{	
;
char _Ac[8 + 36 + 16], *_Ep;
int _Errno = 0;
const long double _Ans = ::_Stoldx(_Ac, &_Ep,
_Getffld(_Ac, _First, _Last,
_Iosbase.getloc()), &_Errno);	
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = _Ans;	
return (_First);
}
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
ios_base& _Iosbase, ios_base::iostate& _State,
void *& _Val) const
{	
;
char _Ac[32], *_Ep;
int _Errno = 0;
 
int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
_Iosbase.getloc());	
const unsigned __int64 _Ans =
(sizeof (void *) == sizeof (unsigned long))
? (unsigned __int64)::_Stoulx(_Ac, &_Ep, _Base, &_Errno)
: ::_Stoullx(_Ac, &_Ep, _Base, &_Errno);
 
		if (_First == _Last)
_State |= ios_base::eofbit;
if (_Ep == _Ac || _Errno != 0)
_State |= ios_base::failbit;
else
_Val = (void *)((char *)0 + _Ans);	
return (_First);
}
private:
int __cdecl _Getifld([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Ac,
_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
const locale& _Loc) const
{	
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Loc);
const string _Grouping = _Punct_fac.grouping();
const _Elem _Kseparator = _Grouping.size() == 0
? (_Elem)0 : _Punct_fac.thousands_sep();
const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
char *_Ptr = _Ac;
		if (_First == _Last)
;	
else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
*_Ptr++ = '+', ++_First;	
else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
*_Ptr++ = '-', ++_First;	
		_Basefield &= ios_base::basefield;
int _Base = _Basefield == ios_base::oct ? 8
: _Basefield == ios_base::hex ? 16
: _Basefield == ios_base::_Fmtzero ? 0 : 10;
		bool _Seendigit = false;	
bool _Nonzero = false;	
		if (_First != _Last && *_First == _E0)
{	
_Seendigit = true, ++_First;
if (_First != _Last && (*_First == _Maklocchr('x', (_Elem *)0, _Cvt)
|| *_First == _Maklocchr('X', (_Elem *)0, _Cvt))
&& (_Base == 0 || _Base == 16))
_Base = 16, _Seendigit = false, ++_First;
else if (_Base == 0)
_Base = 8;
}
		int _Dlen = _Base == 0 || _Base == 10 ? 10
: _Base == 8 ? 8 : 16 + 6;
string _Groups((size_t)1, (char)_Seendigit);
size_t _Group = 0;
		for (char *const _Pe = &_Ac[32 - 1];
_First != _Last; ++_First)
if (::memchr((const char *)"0123456789abcdefABCDEF",
*_Ptr = _Maklocbyte((_Elem)*_First, _Cvt), _Dlen) != 0)
{	
if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
++_Ptr, _Nonzero = true;
_Seendigit = true;
if (_Groups[_Group] != 127)
++_Groups[_Group];
}
else if (_Groups[_Group] == '\0'
|| _Kseparator == (_Elem)0
|| *_First != _Kseparator)
break;	
else
{	
_Groups.append((string::size_type)1, '\0');
++_Group;
}
		if (_Group == 0)
;	
else if ('\0' < _Groups[_Group])
++_Group;	
else
_Seendigit = false;	
		for (const char *_Pg = _Grouping.c_str(); _Seendigit && 0 < _Group; )
if (*_Pg == 127)
break;	
else if (0 < --_Group && *_Pg != _Groups[_Group]
|| 0 == _Group && *_Pg < _Groups[_Group])
_Seendigit = false;	
else if ('\0' < _Pg[1])
++_Pg;	
		if (_Seendigit && !_Nonzero)
*_Ptr++ = '0';	
else if (!_Seendigit)
_Ptr = _Ac;	
*_Ptr = '\0';
return (_Base);
}
	int __cdecl _Getffld([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Ac,
_InIt& _First, _InIt &_Last, const locale& _Loc) const
{	
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Loc);
const string _Grouping = _Punct_fac.grouping();
const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
char *_Ptr = _Ac;
bool _Bad = false;
		if (_First == _Last)
;	
else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
*_Ptr++ = '+', ++_First;	
else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
*_Ptr++ = '-', ++_First;	
		bool _Seendigit = false;	
int _Significant = 0;	
int _Pten = 0;	
		if (*_Grouping.c_str() == 127 || *_Grouping.c_str() <= '\0')
for (; _First != _Last
&& _E0 <= *_First && *_First <= _E0 + 9;
_Seendigit = true, ++_First)
if (36 <= _Significant)
++_Pten;	
else if (*_First == _E0 && _Significant == 0)
;	
else
{	
*_Ptr++ = (char)((*_First - _E0) + '0');
++_Significant;
}
else
{	
const _Elem _Kseparator = _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
size_t _Group = 0;
			for (; _First != _Last; ++_First)
if (_E0 <= *_First && *_First <= _E0 + 9)
{	
_Seendigit = true;
if (36 <= _Significant)
++_Pten;	
else if (*_First == _E0 && _Significant == 0)
;	
else
{	
*_Ptr++ = (char)((*_First - _E0) + '0');
++_Significant;
}
if (_Groups[_Group] != 127)
++_Groups[_Group];
}
else if (_Groups[_Group] == '\0'
|| _Kseparator == (_Elem)0
|| *_First != _Kseparator)
break;	
else
{	
_Groups.append((size_t)1, '\0');
++_Group;
}
if (_Group == 0)
;	
else if ('\0' < _Groups[_Group])
++_Group;	
else
_Bad = true;	
			for (const char *_Pg = _Grouping.c_str();
!_Bad && 0 < _Group; )
if (*_Pg == 127)
break;	
else if (0 < --_Group && *_Pg != _Groups[_Group]
|| 0 == _Group && *_Pg < _Groups[_Group])
_Bad = true;	
else if ('\0' < _Pg[1])
++_Pg;	
}
		if (_Seendigit && _Significant == 0)
*_Ptr++ = '0';	
		if (_First != _Last && *_First == _Punct_fac.decimal_point())
*_Ptr++ = localeconv()->decimal_point[0], ++_First;	
		if (_Significant == 0)
{	
for (; _First != _Last && *_First == _E0;
_Seendigit = true, ++_First)
--_Pten;	
if (_Pten < 0)
*_Ptr++ = '0', ++_Pten;	
}
		for (; _First != _Last
&& _E0 <= *_First && *_First <= _E0 + 9;
_Seendigit = true, ++_First)
if (_Significant < 36)
{	
*_Ptr++ = (char)((*_First - _E0) + '0');
++_Significant;
}
		if (_Seendigit && _First != _Last
&& (*_First == _Maklocchr('e', (_Elem *)0, _Cvt)
|| *_First == _Maklocchr('E', (_Elem *)0, _Cvt)))
{	
*_Ptr++ = 'e', ++_First;
_Seendigit = false, _Significant = 0;
			if (_First == _Last)
;	
else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
*_Ptr++ = '+', ++_First;	
else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
*_Ptr++ = '-', ++_First;	
for (; _First != _Last && *_First == _E0; )
_Seendigit = true, ++_First;	
if (_Seendigit)
*_Ptr++ = '0';	
for (; _First != _Last
&& _E0 <= *_First && *_First <= _E0 + 9;
_Seendigit = true, ++_First)
if (_Significant < 8)
{	
*_Ptr++ = (char)((*_First - _E0) + '0');
++_Significant;
}
}
		if (_Bad || !_Seendigit)
_Ptr = _Ac;	
*_Ptr = '\0';
return (_Pten);
}
	int _Hexdig(const _Elem _Dig, const _Elem _E0,
const _Elem _Al, const _Elem _Au) const
{	
if (_E0 <= _Dig && _Dig <= _E0 + 9)
return (_Dig - _E0);	
else if (_Al <= _Dig && _Dig <= _Al + 5)
return (_Dig - _Al + 10);	
else if (_Au <= _Dig && _Dig <= _Au + 5)
return (_Dig - _Au + 10);	
else
return (-1);
}
	int __cdecl _Getffldx(char *_Ac,
_InIt& _First, _InIt &_Last,
ios_base& _Iosbase, int *_Phexexp) const
{	
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
const string _Grouping = _Punct_fac.grouping();
const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
const _Elem _Al = _Maklocchr('a', (_Elem *)0, _Cvt);
const _Elem _Au = _Maklocchr('A', (_Elem *)0, _Cvt);
char *_Ptr = _Ac;
bool _Bad = false;
int _Dig;
		if (_First == _Last)
;	
else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
*_Ptr++ = '+', ++_First;	
else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
*_Ptr++ = '-', ++_First;	
		*_Ptr++ = '0';
*_Ptr++ = 'x';
		bool _Seendigit = false;	
int _Significant = 0;	
int _Phex = 0;	
		if (_First == _Last || *_First != _E0)
;
else if (++_First != _Last
&& (*_First == _Maklocchr('x', (_Elem *)0, _Cvt)
|| *_First == _Maklocchr('X', (_Elem *)0, _Cvt)))
++_First;	
else
_Seendigit = true;	
		if (*_Grouping.c_str() == 127 || *_Grouping.c_str() <= '\0')
for (; _First != _Last
&& 0 <= (_Dig = _Hexdig(*_First, _E0, _Al, _Au));
_Seendigit = true, ++_First)
if (36 <= _Significant)
++_Phex;	
else if (*_First == _E0 && _Significant == 0)
;	
else
{	
*_Ptr++ = "0123456789abcdef"[_Dig];
++_Significant;
}
else
{	
const _Elem _Kseparator = _Grouping.size() == 0
? (_Elem)0 : _Punct_fac.thousands_sep();
string _Groups((size_t)1, '\0');
size_t _Group = 0;
			for (; _First != _Last; ++_First)
if (0 <= (_Dig = _Hexdig(*_First, _E0, _Al, _Au)))
{	
_Seendigit = true;
if (36 <= _Significant)
++_Phex;	
else if (*_First == _E0 && _Significant == 0)
;	
else
{	
*_Ptr++ = "0123456789abcdef"[_Dig];
++_Significant;
}
if (_Groups[_Group] != 127)
++_Groups[_Group];
}
else if (_Groups[_Group] == '\0'
|| _Kseparator == (_Elem)0
|| *_First != _Kseparator)
break;	
else
{	
_Groups.append((size_t)1, '\0');
++_Group;
}
if (_Group == 0)
;	
else if ('\0' < _Groups[_Group])
++_Group;	
else
_Bad = true;	
			for (const char *_Pg = _Grouping.c_str();
!_Bad && 0 < _Group; )
if (*_Pg == 127)
break;	
else if (0 < --_Group && *_Pg != _Groups[_Group]
|| 0 == _Group && *_Pg < _Groups[_Group])
_Bad = true;	
else if ('\0' < _Pg[1])
++_Pg;	
}
		if (_Seendigit && _Significant == 0)
*_Ptr++ = '0';	
		if (_First != _Last && *_First == _Punct_fac.decimal_point())
*_Ptr++ = localeconv()->decimal_point[0], ++_First;	
		if (_Significant == 0)
{	
for (; _First != _Last && *_First == _E0;
_Seendigit = true, ++_First)
--_Phex;	
if (_Phex < 0)
*_Ptr++ = '0', ++_Phex;	
}
		for (; _First != _Last
&& 0 <= (_Dig = _Hexdig(*_First, _E0, _Al, _Au));
_Seendigit = true, ++_First)
if (_Significant < 36)
{	
*_Ptr++ = "0123456789abcdef"[_Dig];
++_Significant;
}
		if (_Seendigit && _First != _Last
&& (*_First == _Maklocchr('p', (_Elem *)0, _Cvt)
|| *_First == _Maklocchr('P', (_Elem *)0, _Cvt)))
{	
*_Ptr++ = 'p', ++_First;
_Seendigit = false, _Significant = 0;
			if (_First == _Last)
;	
else if (*_First == _Maklocchr('+', (_Elem *)0, _Cvt))
*_Ptr++ = '+', ++_First;	
else if (*_First == _Maklocchr('-', (_Elem *)0, _Cvt))
*_Ptr++ = '-', ++_First;	
for (; _First != _Last && *_First == _E0; )
_Seendigit = true, ++_First;	
if (_Seendigit)
*_Ptr++ = '0';	
for (; _First != _Last
&& _E0 <= *_First && *_First <= _E0 + 9;
_Seendigit = true, ++_First)
if (_Significant < 8)
{	
*_Ptr++ = (char)((*_First - _E0) + '0');
++_Significant;
}
}
		if (_Bad || !_Seendigit)
_Ptr = _Ac;	
*_Ptr = '\0';
*_Phexexp = _Phex;	
return (0);	
}
};
		
template<class _Elem,
class _InIt>
locale::id num_get<_Elem, _InIt>::id;
		
template<class _Elem,
class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
class num_put
: public locale::facet
{	
public:
typedef numpunct<_Elem> _Mypunct;
typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
_Mystr;
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
const locale *_Ploc = 0)
{	
if (_Ppf != 0 && *_Ppf == 0)
*_Ppf = new num_put<_Elem, _OutIt>(
_Locinfo(_Ploc->name()));
return (4);
}
	 static locale::id id;	
protected:
virtual  ~num_put()
{	
}
protected:
void  _Init(const _Locinfo& _Lobj)
{	
_Cvt = _Lobj._Getcvt();
}
	_Locinfo::_Cvtvec _Cvt;		
public:
explicit  num_put(size_t _Refs = 0)
: locale::facet(_Refs)
{	
{ _Locinfo _Lobj;
_Init(_Lobj);
}
}
	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
: locale::facet(_Refs)
{	
_Init(_Lobj);
}
	typedef _Elem char_type;
typedef _OutIt iter_type;
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, long _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
 
_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, double _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, long double _Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
	_OutIt  put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
{	
return (do_put(_Dest, _Iosbase, _Fill, _Val));
}
protected:
virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
{	
;
if (!(_Iosbase.flags() & ios_base::boolalpha))
return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
else
{	
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
_Mystr _Str;
if (_Val)
_Str.assign(_Punct_fac.truename());
else
_Str.assign(_Punct_fac.falsename());
			size_t _Fillcount = _Iosbase.width() <= 0
|| (size_t)_Iosbase.width() <= _Str.size()
? 0 : (size_t)_Iosbase.width() - _Str.size();
			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
{	
_Dest = _Rep(_Dest, _Fill, _Fillcount);
_Fillcount = 0;
}
_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
_Iosbase.width(0);
return (_Rep(_Dest, _Fill, _Fillcount));	
}
}
	virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, long _Val) const
{	
const size_t _Buf_size = 2 * 32;
char _Buf[_Buf_size], _Fmt[6];
return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld",
_Iosbase.flags()), _Val)));
}
	virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
{	
const size_t _Buf_size = 2 * 32;
char _Buf[_Buf_size], _Fmt[6];
return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu",
_Iosbase.flags()), _Val)));
}
 
virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
{	
const size_t _Buf_size = 2 * 32;
char _Buf[_Buf_size], _Fmt[8];
return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld",
_Iosbase.flags()), _Val)));
}
	virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
{	
const size_t _Buf_size = 2 * 32;
char _Buf[_Buf_size], _Fmt[8];
return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu",
_Iosbase.flags()), _Val)));
}
	virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, double _Val) const
{	
const size_t _Buf_size = 8 + 36 + 64;
char _Buf[_Buf_size], _Fmt[8];
streamsize _Precision = _Iosbase.precision() <= 0
&& !(_Iosbase.flags() & ios_base::fixed)
? 6 : _Iosbase.precision();	
int _Significance = 36 < _Precision
? 36 : (int)_Precision;	
_Precision -= _Significance;
size_t _Beforepoint = 0;	
size_t _Afterpoint = 0;	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed
&& _Val * 0.5 != _Val)	
{	
bool _Signed = _Val < 0;
if (_Signed)
_Val = -_Val;
			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
_Val /= 1e10;	
			if (0 < _Val)
for (; 10 <= _Precision && _Val <= 1e-35
&& _Afterpoint < 5000; _Afterpoint += 10)
{	
_Val *= 1e10;
_Precision -= 10;
}
			if (_Signed)
_Val = -_Val;
}
		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
_Beforepoint, _Afterpoint, _Precision,
::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
_Significance, _Val)));	
}
	virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, long double _Val) const
{	
const size_t _Buf_size = 8 + 36 + 64;
char _Buf[_Buf_size], _Fmt[8];
streamsize _Precision = _Iosbase.precision() <= 0
&& !(_Iosbase.flags() & ios_base::fixed)
? 6 : _Iosbase.precision();	
int _Significance = 36 < _Precision
? 36 : (int)_Precision;	
_Precision -= _Significance;
size_t _Beforepoint = 0;	
size_t _Afterpoint = 0;	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
{	
bool _Signed = _Val < 0;
if (_Signed)
_Val = -_Val;
			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
_Val /= 1e10;	
			if (0 < _Val)
for (; 10 <= _Precision && _Val <= 1e-35
&& _Afterpoint < 5000; _Afterpoint += 10)
{	
_Val *= 1e10;
_Precision -= 10;
}
			if (_Signed)
_Val = -_Val;
}
		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
_Beforepoint, _Afterpoint, _Precision,
::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
_Significance, _Val)));	
}
	virtual _OutIt  do_put(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
{	
const size_t _Buf_size = 2 * 32;
char _Buf[_Buf_size];
return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
::sprintf_s(_Buf, _Buf_size, "%p", _Val)));
}
private:
char *__cdecl _Ffmt([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Fmt,
char _Spec, ios_base::fmtflags _Flags) const
{	
char *_Ptr = _Fmt;
*_Ptr++ = '%';
		if (_Flags & ios_base::showpos)
*_Ptr++ = '+';
if (_Flags & ios_base::showpoint)
*_Ptr++ = '#';
*_Ptr++ = '.';
*_Ptr++ = '*';	
if (_Spec != '\0')
*_Ptr++ = _Spec;	
		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
: _Ffl == ios_base::hexfloat ? 'a'	
: _Ffl == ios_base::scientific ? 'e' : 'g';	
*_Ptr = '\0';
return (_Fmt);
}
	_OutIt __cdecl _Fput(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
size_t _Beforepoint, size_t _Afterpoint,
size_t _Trailing, size_t _Count) const
{	
;
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
const string _Grouping = _Punct_fac.grouping();
const _Elem _Kseparator = _Punct_fac.thousands_sep();
string _Groupstring;
const _Elem _E0 = _Maklocchr('0', (_Elem *)0, _Cvt);
size_t _Prefix = _Buf[0] == '+' || _Buf[0] == '-' ? 1 : 0;
		char _Enders[3];
_Enders[0] = ::localeconv()->decimal_point[0];
_Enders[1] = 'e';
_Enders[2] = '\0';
		const char *_Eptr = (const char *)::memchr(_Buf,
'e', _Count);	
const char *_Pointptr = (const char *)::memchr(_Buf,
_Enders[0], _Count);	
if (_Pointptr == 0)
_Trailing = 0;
		if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
{	
_Groupstring.append(_Buf, _Count);	
if (_Eptr == 0)
_Groupstring.append(_Trailing, '0');
else
{	
if (_Pointptr == 0)
{	
_Groupstring.append(_Beforepoint, '0');
_Beforepoint = 0;
}
_Groupstring.insert(_Eptr - _Buf, _Trailing, '0');
}
_Trailing = 0;
			if (_Pointptr == 0)
_Groupstring.append(_Beforepoint, '0');
else
{	
_Groupstring.insert(_Pointptr - _Buf + 1, _Afterpoint, '0');
_Groupstring.insert(_Pointptr - _Buf, _Beforepoint, '0');
_Afterpoint = 0;
}
_Beforepoint = 0;
			const char *_Pg = _Grouping.c_str();
size_t _Off = ::strcspn(&_Groupstring[0], &_Enders[0]);
while (*_Pg != 127 && '\0' < *_Pg
&& (size_t)*_Pg < _Off - _Prefix)
{	
_Groupstring.insert(_Off -= *_Pg, (size_t)1, '\0');
if ('\0' < _Pg[1])
++_Pg;	
}
			_Buf = &_Groupstring[0];
_Trailing = 0;
_Count = _Groupstring.size();
}
		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;
_Fillcount = _Iosbase.width() <= 0
|| (size_t)_Iosbase.width() <= _Fillcount
? 0 : (size_t)_Iosbase.width() - _Fillcount;
ios_base::fmtflags _Adjustfield =
_Iosbase.flags() & ios_base::adjustfield;
if (_Adjustfield != ios_base::left
&& _Adjustfield != ios_base::internal)
{	
_Dest = _Rep(_Dest, _Fill, _Fillcount);
_Fillcount = 0;
}
else if (_Adjustfield == ios_base::internal)
{	
if (0 < _Prefix)
{	
_Dest = _Putc(_Dest, _Buf, 1);
++_Buf, --_Count;
}
_Dest = _Rep(_Dest, _Fill, _Fillcount);
_Fillcount = 0;
}
		_Pointptr = (const char *)::memchr(_Buf,
_Enders[0], _Count);	
if (_Pointptr != 0)
{	
size_t _Fracoffset = _Pointptr - _Buf + 1;
_Dest = _Putgrouped(_Dest, _Buf, _Fracoffset - 1, _Kseparator);
_Dest = _Rep(_Dest, _E0, _Beforepoint);
_Dest = _Rep(_Dest, _Punct_fac.decimal_point(), 1);
_Dest = _Rep(_Dest, _E0, _Afterpoint);
_Buf += _Fracoffset, _Count -= _Fracoffset;
}
		_Eptr = (const char *)::memchr(_Buf,
'e', _Count);	
if (_Eptr != 0)
{	
size_t _Expoffset = _Eptr - _Buf + 1;
_Dest = _Putgrouped(_Dest, _Buf, _Expoffset - 1, _Kseparator);
_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;
_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
? "E" : "e", 1);
_Buf += _Expoffset, _Count -= _Expoffset;
}
		_Dest = _Putgrouped(_Dest, _Buf, _Count,
_Kseparator);	
_Dest = _Rep(_Dest, _E0, _Trailing);	
_Iosbase.width(0);
return (_Rep(_Dest, _Fill, _Fillcount));	
}
	char *__cdecl _Ifmt([SA_Pre(Null=SA_No)] [SA_Post(NullTerminated=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Fmt,
const char *_Spec, ios_base::fmtflags _Flags) const
{	
char *_Ptr = _Fmt;
*_Ptr++ = '%';
		if (_Flags & ios_base::showpos)
*_Ptr++ = '+';
if (_Flags & ios_base::showbase)
*_Ptr++ = '#';
if (_Spec[0] != 'L')
*_Ptr++ = _Spec[0];	
else
{	
*_Ptr++ = 'I';
*_Ptr++ = '6';
*_Ptr++ = '4';
}
		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
*_Ptr++ = _Basefield == ios_base::oct ? 'o'
: _Basefield != ios_base::hex ? _Spec[1]	
: _Flags & ios_base::uppercase ? 'X' : 'x';
*_Ptr = '\0';
return (_Fmt);
}
	_OutIt __cdecl _Iput(_OutIt _Dest,
ios_base& _Iosbase, _Elem _Fill, [SA_Pre(Null=SA_No,WritableElements="_Count")] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Post(Deref=1,Valid=SA_Yes)] char *_Buf, size_t _Count) const
{	
;
const _Mypunct& _Punct_fac = use_facet<_Mypunct >(_Iosbase.getloc());
const string _Grouping = _Punct_fac.grouping();
const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
: 0;
		if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
{	
const char *_Pg = _Grouping.c_str();
size_t _Off = _Count;
while (*_Pg != 127 && '\0' < *_Pg
&& (size_t)*_Pg < _Off - _Prefix)
{	
_Off -= *_Pg;
::memmove_s((&_Buf[_Off + 1]), (_Count + 1 - _Off), (&_Buf[_Off]), (_Count + 1 - _Off));
_Buf[_Off] = '\0', ++_Count;
if ('\0' < _Pg[1])
++_Pg;	
}
}
		size_t _Fillcount = _Iosbase.width() <= 0
|| (size_t)_Iosbase.width() <= _Count
? 0 : (size_t)_Iosbase.width() - _Count;
		ios_base::fmtflags _Adjustfield =
_Iosbase.flags() & ios_base::adjustfield;
if (_Adjustfield != ios_base::left
&& _Adjustfield != ios_base::internal)
{	
_Dest = _Rep(_Dest, _Fill, _Fillcount);
_Fillcount = 0;
}
else if (_Adjustfield == ios_base::internal)
{	
_Dest = _Putc(_Dest, _Buf, _Prefix);	
_Buf += _Prefix, _Count -= _Prefix;
_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;
}
		_Dest = _Putgrouped(_Dest, _Buf, _Count,
_Punct_fac.thousands_sep());	
_Iosbase.width(0);
return (_Rep(_Dest, _Fill, _Fillcount));	
}
	_OutIt __cdecl _Put(_OutIt _Dest,
const _Elem *_Ptr, size_t _Count) const
{	
for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
*_Dest = *_Ptr;
return (_Dest);
}
	_OutIt __cdecl _Putc(_OutIt _Dest,
const char *_Ptr, size_t _Count) const
{	
for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
*_Dest = _Maklocchr(*_Ptr, (_Elem *)0, _Cvt);
return (_Dest);
}
	_OutIt __cdecl _Putgrouped(_OutIt _Dest,
const char *_Ptr, size_t _Count, _Elem _Kseparator) const
{	
for (; ; ++_Ptr, --_Count)
{	
const char *_Pend =
(const char *)::memchr(_Ptr, '\0', _Count);
size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;
			_Dest = _Putc(_Dest, _Ptr, _Groupsize);
_Ptr += _Groupsize, _Count -= _Groupsize;
if (_Count == 0)
break;
if (_Kseparator != (_Elem)0)
_Dest = _Rep(_Dest, _Kseparator, 1);
}
return (_Dest);
}
	_OutIt __cdecl _Rep(_OutIt _Dest,
_Elem _Ch, size_t _Count) const
{	
for (; 0 < _Count; --_Count, ++_Dest)
*_Dest = _Ch;
return (_Dest);
}
};
		
template<class _Elem,
class _OutIt>
locale::id num_put<_Elem, _OutIt>::id;
 
template class __declspec(dllimport) numpunct<char>;
template class __declspec(dllimport) num_get<char,
istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
ostreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) numpunct<wchar_t>;
template class __declspec(dllimport) num_get<wchar_t,
istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
 
#pragma warning(pop)
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Elem,
class _Traits>
class basic_ios
: public ios_base
{	
public:
typedef basic_ios<_Elem, _Traits> _Myt;
typedef basic_ostream<_Elem, _Traits> _Myos;
typedef basic_streambuf<_Elem, _Traits> _Mysb;
typedef ctype<_Elem> _Ctype;
typedef _Elem char_type;
typedef _Traits traits_type;
typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	explicit  basic_ios(_Mysb *_Strbuf)
{	
init(_Strbuf);
}
	virtual  ~basic_ios()
{	
}
	void  clear(iostate _State = goodbit, bool _Reraise = false)
{	
ios_base::clear((iostate)(_Mystrbuf == 0
? (int)_State | (int)badbit : (int)_State), _Reraise);
}
	void  clear(io_state _State)
{	
clear((iostate)_State);
}
	void  setstate(iostate _State, bool _Reraise = false)
{	
if (_State != goodbit)
clear((iostate)((int)rdstate() | (int)_State), _Reraise);
}
	void  setstate(io_state _State)
{	
setstate((iostate)_State);
}
	_Myt&  copyfmt(const _Myt& _Right)
{	
_Tiestr = _Right.tie();
_Fillch = _Right.fill();
ios_base::copyfmt(_Right);
return (*this);
}
	_Myos * tie() const
{	
return (_Tiestr);
}
	_Myos * tie(_Myos *_Newtie)
{	
_Myos *_Oldtie = _Tiestr;
_Tiestr = _Newtie;
return (_Oldtie);
}
	_Mysb * rdbuf() const
{	
return (_Mystrbuf);
}
	_Mysb * rdbuf(_Mysb *_Strbuf)
{	
_Mysb *_Oldstrbuf = _Mystrbuf;
_Mystrbuf = _Strbuf;
clear();
return (_Oldstrbuf);
}
	locale  imbue(const locale& _Loc)
{	
locale _Oldlocale = ios_base::imbue(_Loc);
if (rdbuf() != 0)
rdbuf()->pubimbue(_Loc);
return (_Oldlocale);
}
	_Elem  fill() const
{	
return (_Fillch);
}
	_Elem  fill(_Elem _Newfill)
{	
_Elem _Oldfill = _Fillch;
_Fillch = _Newfill;
return (_Oldfill);
}
	char  narrow(_Elem _Ch, char _Dflt = '\0') const
{	
const _Ctype& _Ctype_fac = use_facet<_Ctype >(getloc());
return (_Ctype_fac.narrow(_Ch, _Dflt));
}
	_Elem  widen(char _Byte) const
{	
const _Ctype& _Ctype_fac = use_facet<_Ctype >(getloc());
return (_Ctype_fac.widen(_Byte));
}
protected:
void  init(_Mysb *_Strbuf = 0,
bool _Isstd = false)
{	
_Init();	
_Mystrbuf = _Strbuf;
_Tiestr = 0;
_Fillch = widen(' ');
		if (_Mystrbuf == 0)
setstate(badbit);
		if (_Isstd)
_Addstd(this);	
else
_Stdstr = 0;
}
	 basic_ios()
{	
}
private:
basic_ios(const _Myt&);	
_Myt&  operator=(const _Myt&);	
	_Mysb *_Mystrbuf;	
_Myos *_Tiestr;	
_Elem _Fillch;	
};
 
template class __declspec(dllimport) basic_ios<char,
char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
char_traits<wchar_t> >;
 
		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::boolalpha);
return (_Iosbase);
}
inline ios_base& __cdecl dec(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::dec, ios_base::basefield);
return (_Iosbase);
}
inline ios_base& __cdecl fixed(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
return (_Iosbase);
}
inline ios_base& __cdecl hex(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::hex, ios_base::basefield);
return (_Iosbase);
}
	namespace tr1 {	
inline std::ios_base& __cdecl hexfloat(std::ios_base& _Iosbase)
{	
_Iosbase.setf(std::ios_base::hexfloat, std::ios_base::floatfield);
return (_Iosbase);
}
}	
using tr1::hexfloat;
inline ios_base& __cdecl internal(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
return (_Iosbase);
}
inline ios_base& __cdecl left(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::left, ios_base::adjustfield);
return (_Iosbase);
}
inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::boolalpha);
return (_Iosbase);
}
inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::showbase);
return (_Iosbase);
}
inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::showpoint);
return (_Iosbase);
}
inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::showpos);
return (_Iosbase);
}
inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::skipws);
return (_Iosbase);
}
inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::unitbuf);
return (_Iosbase);
}
inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
{	
_Iosbase.unsetf(ios_base::uppercase);
return (_Iosbase);
}
inline ios_base& __cdecl oct(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::oct, ios_base::basefield);
return (_Iosbase);
}
inline ios_base& __cdecl right(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::right, ios_base::adjustfield);
return (_Iosbase);
}
inline ios_base& __cdecl scientific(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
return (_Iosbase);
}
inline ios_base& __cdecl showbase(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::showbase);
return (_Iosbase);
}
inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::showpoint);
return (_Iosbase);
}
inline ios_base& __cdecl showpos(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::showpos);
return (_Iosbase);
}
inline ios_base& __cdecl skipws(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::skipws);
return (_Iosbase);
}
inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::unitbuf);
return (_Iosbase);
}
inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
{	
_Iosbase.setf(ios_base::uppercase);
return (_Iosbase);
}
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4390)
namespace std {
		
 
 
 
 
		
template<class _Elem,
class _Traits>
class basic_ostream
: virtual public basic_ios<_Elem, _Traits>
{	
public:
typedef basic_ostream<_Elem, _Traits> _Myt;
typedef basic_ios<_Elem, _Traits> _Myios;
typedef basic_streambuf<_Elem, _Traits> _Mysb;
typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
typedef num_put<_Elem, _Iter> _Nput;
	explicit  basic_ostream(basic_streambuf<_Elem, _Traits> *_Strbuf,
bool _Isstd = false)
{	
_Myios::init(_Strbuf, _Isstd);
}
	 basic_ostream(_Uninitialized, bool _Addit = true)
{	
if (_Addit)
ios_base::_Addstd(this);	
}
	virtual  ~basic_ostream()
{	
}
	typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	class _Sentry_base
{	
public:
_Sentry_base(_Myt& _Ostr)
: _Myostr(_Ostr)
{	
if (_Myostr.rdbuf() != 0)
_Myostr.rdbuf()->_Lock();
}
		 ~_Sentry_base()
{	
if (_Myostr.rdbuf() != 0)
_Myostr.rdbuf()->_Unlock();
}
		_Myt& _Myostr;	
};
	class sentry
: public _Sentry_base
{	
public:
explicit  sentry(_Myt& _Ostr)
: _Sentry_base(_Ostr)
{	
if (_Ostr.good() && _Ostr.tie() != 0)
_Ostr.tie()->flush();
_Ok = _Ostr.good();	
}
		 ~sentry()
{	
 
if (!std:: uncaught_exception())
this->_Myostr._Osfx();
}
 
		 operator bool() const
{	
return (_Ok);
}
	private:
sentry(const sentry&);	
sentry&  operator=(const sentry&);	
		bool _Ok;	
};
	bool  opfx()
{	
if (ios_base::good() && _Myios::tie() != 0)
_Myios::tie()->flush();
return (ios_base::good());
}
	void  osfx()
{	
_Osfx();
}
	void  _Osfx()
{	
try {
if (ios_base::flags() & ios_base::unitbuf)
flush();	
} catch (...) {
}
}
	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
{	
;
return ((*_Pfn)(*this));
}
	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
{	
;
(*_Pfn)(*(_Myios *)this);
return (*this);
}
	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
{	
;
(*_Pfn)(*(ios_base *)this);
return (*this);
}
	_Myt&  operator<<(_Bool _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(short _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
ios_base::fmtflags _Bfl =
ios_base::flags() & ios_base::basefield;
long _Tmp = (_Bfl == ios_base::oct
|| _Bfl == ios_base::hex)
? (long)(unsigned short)_Val : (long)_Val;
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Tmp).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
        
	_Myt&  operator<<(unsigned short _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), (unsigned long)_Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(int __w64 _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
ios_base::fmtflags _Bfl =
ios_base::flags() & ios_base::basefield;
long _Tmp = (_Bfl == ios_base::oct
|| _Bfl == ios_base::hex)
? (long)(unsigned int)_Val : (long)_Val;
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Tmp).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(unsigned int __w64 _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), (unsigned long)_Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(long _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(unsigned long __w64 _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), (unsigned long)_Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
 
_Myt&  operator<<(__int64 _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(unsigned __int64 _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(float _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), (double)_Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(double _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(long double _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(const void *_Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nput& _Nput_fac = use_facet<_Nput >(ios_base::getloc());
			try {
if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
_Myios::fill(), _Val).failed())
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator<<(_Mysb *_Strbuf)
{	
ios_base::iostate _State = ios_base::goodbit;
bool _Copied = false;
const sentry _Ok(*this);
		if (_Ok && _Strbuf != 0)
for (int_type _Meta = _Traits::eof(); ; _Copied = true)
{	
try {
_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
? _Strbuf->sgetc() : _Strbuf->snextc();
} catch (...) {
_Myios::setstate(ios_base::failbit);
throw;
}
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
break;	
				try {
if (_Traits::eq_int_type(_Traits::eof(),
_Myios::rdbuf()->sputc(
_Traits::to_char_type(_Meta))))
{	
_State |= ios_base::badbit;
break;
}
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		ios_base::width(0);
_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
: !_Copied ? _State | ios_base::failbit : _State);
return (*this);
}
	_Myt&  put(_Elem _Ch)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (!_Ok)
_State |= ios_base::badbit;
else
{	
try {
if (_Traits::eq_int_type(_Traits::eof(),
_Myios::rdbuf()->sputc(_Ch)))
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  write(const _Elem *_Str,
streamsize _Count)
{	
if (0 < _Count)
;
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (!_Ok)
_State |= ios_base::badbit;
else
{	
try {
if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  flush()
{	
ios_base::iostate _State = ios_base::goodbit;
if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)
_State |= ios_base::badbit;	
_Myios::setstate(_State);
return (*this);
}
	_Myt&  seekp(pos_type _Pos)
{	
if (!ios_base::fail()
&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
ios_base::out) == _BADOFF)
_Myios::setstate(ios_base::failbit);
return (*this);
}
	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
{	
if (!ios_base::fail()
&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
ios_base::out) == _BADOFF)
_Myios::setstate(ios_base::failbit);
return (*this);
}
	pos_type  tellp()
{	
if (!ios_base::fail())
return (_Myios::rdbuf()->pubseekoff(0,
ios_base::cur, ios_base::out));
else
return (pos_type(_BADOFF));
}
};
 
template class __declspec(dllimport) basic_ostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t> >;
 
		
 template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>& __cdecl operator<<(
basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
{	
ios_base::iostate _State = ios_base::goodbit;
streamsize _Count = (streamsize)::strlen(_Val);	
streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
? 0 : _Ostr.width() - _Count;
const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
	if (!_Ok)
_State |= ios_base::badbit;
else
{	
try {
const ctype<_Elem>& _Ctype_fac = use_facet<ctype<_Elem> >(_Ostr.getloc());
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
_State |= ios_base::badbit;
		if (_State == ios_base::goodbit)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
_Ostr.width(0);
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.setstate(_State);
return (_Ostr);
}
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>& __cdecl operator<<(
basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
{	
ios_base::iostate _State = ios_base::goodbit;
const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
	if (_Ok)
{	
const ctype<_Elem>& _Ctype_fac = use_facet<ctype<_Elem> >(_Ostr.getloc());
streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;
		try {
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; _State == ios_base::goodbit && 0 < _Pad;
--_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
_State |= ios_base::badbit;
		if (_State == ios_base::goodbit
&& _Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
_State |= ios_base::badbit;
		for (; _State == ios_base::goodbit && 0 < _Pad;
--_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
_State |= ios_base::badbit;
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.width(0);
_Ostr.setstate(_State);
return (_Ostr);
}
template<class _Traits> inline
basic_ostream<char, _Traits>& __cdecl operator<<(
basic_ostream<char, _Traits>& _Ostr,
const char *_Val)
{	
typedef char _Elem;
typedef basic_ostream<_Elem, _Traits> _Myos;
ios_base::iostate _State = ios_base::goodbit;
streamsize _Count = (streamsize)_Traits::length(_Val);	
streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
? 0 : _Ostr.width() - _Count;
const typename _Myos::sentry _Ok(_Ostr);
	if (!_Ok)
_State |= ios_base::badbit;
else
{	
try {
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
		if (_State == ios_base::goodbit
&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
_State |= ios_base::badbit;
		if (_State == ios_base::goodbit)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
_Ostr.width(0);
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.setstate(_State);
return (_Ostr);
}
template<class _Traits> inline
basic_ostream<char, _Traits>& __cdecl operator<<(
basic_ostream<char, _Traits>& _Ostr, char _Ch)
{	
typedef char _Elem;
typedef basic_ostream<_Elem, _Traits> _Myos;
ios_base::iostate _State = ios_base::goodbit;
const typename _Myos::sentry _Ok(_Ostr);
	if (_Ok)
{	
streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;
		try {
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; _State == ios_base::goodbit && 0 < _Pad;
--_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
_State |= ios_base::badbit;
		if (_State == ios_base::goodbit
&& _Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ch)))
_State |= ios_base::badbit;
		for (; _State == ios_base::goodbit && 0 < _Pad;
--_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
_State |= ios_base::badbit;
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.width(0);
_Ostr.setstate(_State);
return (_Ostr);
}
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>& __cdecl operator<<(
basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
{	
typedef basic_ostream<_Elem, _Traits> _Myos;
ios_base::iostate _State = ios_base::goodbit;
streamsize _Count = (streamsize)_Traits::length(_Val);	
streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
? 0 : _Ostr.width() - _Count;
const typename _Myos::sentry _Ok(_Ostr);
	if (!_Ok)
_State |= ios_base::badbit;
else
{	
try {
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
		if (_State == ios_base::goodbit
&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
_State |= ios_base::badbit;
		if (_State == ios_base::goodbit)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
_Ostr.width(0);
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.setstate(_State);
return (_Ostr);
}
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>& __cdecl operator<<(
basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
{	
typedef basic_ostream<_Elem, _Traits> _Myos;
ios_base::iostate _State = ios_base::goodbit;
const typename _Myos::sentry _Ok(_Ostr);
	if (_Ok)
{	
streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;
		try {
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; _State == ios_base::goodbit && 0 < _Pad;
--_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
_State |= ios_base::badbit;
		if (_State == ios_base::goodbit
&& _Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ch)))
_State |= ios_base::badbit;
		for (; _State == ios_base::goodbit && 0 < _Pad;
--_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
_State |= ios_base::badbit;
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.width(0);
_Ostr.setstate(_State);
return (_Ostr);
}
template<class _Traits> inline
basic_ostream<char, _Traits>& __cdecl operator<<(
basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
{	
return (_Ostr << (const char *)_Val);
}
template<class _Traits> inline
basic_ostream<char, _Traits>& __cdecl operator<<(
basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
{	
return (_Ostr << (char)_Ch);
}
template<class _Traits> inline
basic_ostream<char, _Traits>& __cdecl operator<<(
basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
{	
return (_Ostr << (const char *)_Val);
}
template<class _Traits> inline
basic_ostream<char, _Traits>& __cdecl operator<<(
basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
{	
return (_Ostr << (char)_Ch);
}
		
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>&
__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
{	
_Ostr.put(_Ostr.widen('\n'));
_Ostr.flush();
return (_Ostr);
}
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>&
__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
{	
_Ostr.put(_Elem());
return (_Ostr);
}
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>&
__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
{	
_Ostr.flush();
return (_Ostr);
}
__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
__cdecl endl(basic_ostream<char, char_traits<char> >& _Ostr)
{	
_Ostr.put('\n');
_Ostr.flush();
return (_Ostr);
}
__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
__cdecl endl(basic_ostream<wchar_t,
char_traits<wchar_t> >& _Ostr)
{	
_Ostr.put('\n');
_Ostr.flush();
return (_Ostr);
}
__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
__cdecl ends(basic_ostream<char, char_traits<char> >& _Ostr)
{	
_Ostr.put('\0');
return (_Ostr);
}
__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
__cdecl ends(basic_ostream<wchar_t,
char_traits<wchar_t> >& _Ostr)
{	
_Ostr.put('\0');
return (_Ostr);
}
__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
__cdecl flush(basic_ostream<char, char_traits<char> >& _Ostr)
{	
_Ostr.flush();
return (_Ostr);
}
__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
__cdecl flush(basic_ostream<wchar_t,
char_traits<wchar_t> >& _Ostr)
{	
_Ostr.flush();
return (_Ostr);
}
 
 
}
 #pragma warning(default: 4390)
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Elem,
class _Traits>
class basic_istream
: virtual public basic_ios<_Elem, _Traits>
{	
public:
typedef basic_istream<_Elem, _Traits> _Myt;
typedef basic_ios<_Elem, _Traits> _Myios;
typedef basic_streambuf<_Elem, _Traits> _Mysb;
typedef istreambuf_iterator<_Elem, _Traits> _Iter;
typedef ctype<_Elem> _Ctype;
typedef num_get<_Elem, _Iter> _Nget;
	explicit  basic_istream(_Mysb *_Strbuf, bool _Isstd = false)
: _Chcount(0)
{	
_Myios::init(_Strbuf, _Isstd);
}
	 basic_istream(_Uninitialized)
{	
ios_base::_Addstd(this);
}
	virtual  ~basic_istream()
{	
}
	typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
		
class _Sentry_base
{	
public:
_Sentry_base(_Myt& _Istr)
: _Myistr(_Istr)
{	
if (_Myistr.rdbuf() != 0)
_Myistr.rdbuf()->_Lock();
}
		 ~_Sentry_base()
{	
if (_Myistr.rdbuf() != 0)
_Myistr.rdbuf()->_Unlock();
}
		_Myt& _Myistr;	
};
	class sentry
: public _Sentry_base
{	
public:
explicit  sentry(_Myt& _Istr, bool _Noskip = false)
: _Sentry_base(_Istr)
{	
_Ok = this->_Myistr._Ipfx(_Noskip);
}
		 operator bool() const
{	
return (_Ok);
}
	private:
sentry(const sentry&);	
sentry&  operator=(const sentry&);	
		bool _Ok;	
};
	bool  _Ipfx(bool _Noskip = false)
{	
if (ios_base::good())
{	
if (_Myios::tie() != 0)
_Myios::tie()->flush();
			if (!_Noskip && ios_base::flags() & ios_base::skipws)
{	
const _Ctype& _Ctype_fac = use_facet<_Ctype >(ios_base::getloc());
				try {
int_type _Meta = _Myios::rdbuf()->sgetc();
				for (; ; _Meta = _Myios::rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_Myios::setstate(ios_base::eofbit);
break;
}
else if (!_Ctype_fac.is(_Ctype::space,
_Traits::to_char_type(_Meta)))
break;	
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
			if (ios_base::good())
return (true);
}
_Myios::setstate(ios_base::failbit);
return (false);
}
	bool  ipfx(bool _Noskip = false)
{	
return _Ipfx(_Noskip);
}
	void  isfx()
{	
}
	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
{	
;
return ((*_Pfn)(*this));
}
	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
{	
;
(*_Pfn)(*(_Myios *)this);
return (*this);
}
	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
{	
;
(*_Pfn)(*(ios_base *)this);
return (*this);
}
	_Myt&  operator>>(_Bool& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(short& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
long _Tmp = 0;
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Tmp);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			if (_State & ios_base::failbit
|| _Tmp < (-32768) || 32767 < _Tmp)
_State |= ios_base::failbit;
else
_Val = (short)_Tmp;
}
		_Myios::setstate(_State);
return (*this);
}
        
	_Myt&  operator>>(unsigned short& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(int& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
long _Tmp = 0;
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Tmp);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			if (_State & ios_base::failbit
|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
_State |= ios_base::failbit;
else
_Val = _Tmp;
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(unsigned int& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(long& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(unsigned long __w64& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
 
_Myt&  operator>>(__int64& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(unsigned __int64& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(float& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(double& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(long double& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(void *& _Val)
{	
ios_base::iostate _State = ios_base::goodbit;
const sentry _Ok(*this);
		if (_Ok)
{	
const _Nget& _Nget_fac = use_facet<_Nget >(ios_base::getloc());
			try {
_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
*this, _State, _Val);
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  operator>>(_Mysb *_Strbuf)
{	
ios_base::iostate _State = ios_base::goodbit;
bool _Copied = false;
const sentry _Ok(*this);
		if (_Ok && _Strbuf != 0)
{	
try {
int_type _Meta = _Myios::rdbuf()->sgetc();
			for (; ; _Meta = _Myios::rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else
{	
try {
if (_Traits::eq_int_type(_Traits::eof(),
_Strbuf->sputc(_Traits::to_char_type(_Meta))))
break;
} catch (...) {
break;
}
_Copied = true;
}
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
return (*this);
}
	int_type  get()
{	
int_type _Meta = 0;
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (!_Ok)
_Meta = _Traits::eof();	
else
{	
try {
_Meta = _Myios::rdbuf()->sbumpc();
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
_State |= ios_base::eofbit | ios_base::failbit;	
else
++_Chcount;	
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (_Meta);
}
	_Myt&  get(_Elem *_Str, streamsize _Count)
{	
return (get(_Str, _Count, _Myios::widen('\n')));
}
	_Myt&  get(_Elem *_Str,
streamsize _Count, _Elem _Delim)
{	
;
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok && 0 < _Count)
{	
try {
int_type _Meta = _Myios::rdbuf()->sgetc();
			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (_Traits::to_char_type(_Meta) == _Delim)
break;	
else
{	
*_Str++ = _Traits::to_char_type(_Meta);
++_Chcount;
}
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_Chcount == 0
? _State | ios_base::failbit : _State);
*_Str = _Elem();	
return (*this);
}
	_Myt&  get(_Elem& _Ch)
{	
int_type _Meta = get();
if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
_Ch = _Traits::to_char_type(_Meta);
return (*this);
}
	_Myt&  get(_Mysb& _Strbuf)
{	
return (get(_Strbuf, _Myios::widen('\n')));
}
	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
{	
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok)
{	
try {
int_type _Meta = _Myios::rdbuf()->sgetc();
			for (; ; _Meta = _Myios::rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else
{	
try {
_Elem _Ch = _Traits::to_char_type(_Meta);
if (_Ch == _Delim
|| _Traits::eq_int_type(_Traits::eof(),
_Strbuf.sputc(_Ch)))
break;
} catch (...) {
break;
}
++_Chcount;
}
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		if (_Chcount == 0)
_State |= ios_base::failbit;
_Myios::setstate(_State);
return (*this);
}
	_Myt&  getline(_Elem *_Str, streamsize _Count)
{	
return (getline(_Str, _Count, _Myios::widen('\n')));
}
	_Myt&  getline(_Elem *_Str,
streamsize _Count, _Elem _Delim)
{	
;
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok && 0 < _Count)
{	
int_type _Metadelim = _Traits::to_int_type(_Delim);
			try {
int_type _Meta = _Myios::rdbuf()->sgetc();
			for (; ; _Meta = _Myios::rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (_Meta == _Metadelim)
{	
++_Chcount;
_Myios::rdbuf()->sbumpc();
break;
}
else if (--_Count <= 0)
{	
_State |= ios_base::failbit;
break;
}
else
{	
++_Chcount;
*_Str++ = _Traits::to_char_type(_Meta);
}
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		*_Str = _Elem();	
_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
return (*this);
}
	_Myt&  ignore(streamsize _Count = 1,
int_type _Metadelim = _Traits::eof())
{	
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok && 0 < _Count)
{	
try {
for (; ; )
{	
int_type _Meta;
if (_Count != 2147483647 && --_Count < 0)
break;	
else if (_Traits::eq_int_type(_Traits::eof(),
_Meta = _Myios::rdbuf()->sbumpc()))
{	
_State |= ios_base::eofbit;
break;
}
else
{	
++_Chcount;
if (_Meta == _Metadelim)
break;	
}
}
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  _Read_s(_Elem *_Str, size_t _Str_size, streamsize _Count)
{	
;
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok)
{	
try {
const streamsize _Num = _Myios::rdbuf()->_Sgetn_s(_Str, _Str_size, _Count);
_Chcount += _Num;
if (_Num != _Count)
_State |= ios_base::eofbit | ios_base::failbit;	
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  read(_Elem *_Str, streamsize _Count)
{
return _Read_s(_Str, (size_t)-1, _Count);
}
	streamsize  _Readsome_s(_Elem *_Str, size_t _Str_size, streamsize _Count)
{	
;
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
streamsize _Num;
		if (!_Ok)
_State |= ios_base::failbit;	
else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
_State |= ios_base::eofbit;	
else if (0 < _Num)
_Read_s(_Str, _Str_size, _Num < _Count ? _Num : _Count);	
		_Myios::setstate(_State);
return (gcount());
}
	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
streamsize  readsome(_Elem *_Str, streamsize _Count)
{
return _Readsome_s(_Str, (size_t)-1, _Count);
}
	int_type  peek()
{	
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
int_type _Meta = 0;
const sentry _Ok(*this, true);
		if (!_Ok)
_Meta = _Traits::eof();	
else
{	
try {
if (_Traits::eq_int_type(_Traits::eof(),
_Meta = _Myios::rdbuf()->sgetc()))
_State |= ios_base::eofbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (_Meta);
}
	_Myt&  putback(_Elem _Ch)
{	
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok)
{	
try {
if (_Traits::eq_int_type(_Traits::eof(),
_Myios::rdbuf()->sputbackc(_Ch)))
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	_Myt&  unget()
{	
ios_base::iostate _State = ios_base::goodbit;
_Chcount = 0;
const sentry _Ok(*this, true);
		if (_Ok)
{	
try {
if (_Traits::eq_int_type(_Traits::eof(),
_Myios::rdbuf()->sungetc()))
_State |= ios_base::badbit;
} catch (...) { _Myios::setstate(ios_base::badbit, true); }
}
		_Myios::setstate(_State);
return (*this);
}
	streamsize  gcount() const
{	
return (_Chcount);
}
	int  sync()
{	
ios_base::iostate _State = ios_base::goodbit;
int _Ans;
		if (_Myios::rdbuf() == 0)
_Ans = -1;	
else if (_Myios::rdbuf()->pubsync() == -1)
{	
_State |= ios_base::badbit;
_Ans = -1;
}
else
_Ans = 0;	
		_Myios::setstate(_State);
return (_Ans);
}
	_Myt&  seekg(pos_type _Pos)
{	
if (!ios_base::fail()
&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
ios_base::in) == _BADOFF)
_Myios::setstate(ios_base::failbit);
else
_Myios::clear();	
return (*this);
}
	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
{	
if (!ios_base::fail()
&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
ios_base::in) == _BADOFF)
_Myios::setstate(ios_base::failbit);
else
_Myios::clear();	
return (*this);
}
	pos_type  tellg()
{	
if (!ios_base::fail())
return (_Myios::rdbuf()->pubseekoff(0,
ios_base::cur, ios_base::in));
else
return (pos_type(_BADOFF));
}
private:
streamsize _Chcount;	
};
 
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
 
		
template<class _Elem,
class _Traits>
class basic_iostream
: public basic_istream<_Elem, _Traits>,
public basic_ostream<_Elem, _Traits>
{	
public:
typedef _Elem char_type;
typedef _Traits traits_type;
typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
: basic_istream<_Elem, _Traits>(_Strbuf, false),
basic_ostream<_Elem, _Traits>(_Noinit, false)
{	
}
	virtual  ~basic_iostream()
{	
}
};
 
template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
 
		
template<class _Elem,
class _Traits> inline
basic_istream<_Elem, _Traits>& __cdecl operator>>(
basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
{	
;
typedef basic_istream<_Elem, _Traits> _Myis;
typedef ctype<_Elem> _Ctype;
ios_base::iostate _State = ios_base::goodbit;
_Elem *_Str0 = _Str;
const typename _Myis::sentry _Ok(_Istr);
	if (_Ok)
{	
const _Ctype& _Ctype_fac = use_facet<_Ctype >(_Istr.getloc());
		try {
streamsize _Count = 0 < _Istr.width() ? _Istr.width() : 2147483647;
typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
_Elem _Ch;
for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (_Ctype_fac.is(_Ctype::space,
_Ch = _Traits::to_char_type(_Meta))
|| _Ch == _Elem())
break;	
else
*_Str++ = _Traits::to_char_type(_Meta);	
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
	*_Str = _Elem();	
_Istr.width(0);
_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
return (_Istr);
}
template<class _Elem,
class _Traits> inline
basic_istream<_Elem, _Traits>& __cdecl  operator>>(
basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
{	
typedef basic_istream<_Elem, _Traits> _Myis;
typename _Myis::int_type _Meta;
ios_base::iostate _State = ios_base::goodbit;
const typename _Myis::sentry _Ok(_Istr);
	if (_Ok)
{	
try {
_Meta = _Istr.rdbuf()->sbumpc();
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
_State |= ios_base::eofbit | ios_base::failbit;	
else
_Ch = _Traits::to_char_type(_Meta);	
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
	_Istr.setstate(_State);
return (_Istr);
}
template<class _Traits> inline
basic_istream<char, _Traits>& __cdecl  operator>>(
basic_istream<char, _Traits>& _Istr, signed char *_Str)
{	
return (_Istr >> (char *)_Str);
}
template<class _Traits> inline
basic_istream<char, _Traits>& __cdecl  operator>>(
basic_istream<char, _Traits>& _Istr, signed char& _Ch)
{	
return (_Istr >> (char&)_Ch);
}
template<class _Traits> inline
basic_istream<char, _Traits>& __cdecl  operator>>(
basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
{	
return (_Istr >> (char *)_Str);
}
template<class _Traits> inline
basic_istream<char, _Traits>& __cdecl  operator>>(
basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
{	
return (_Istr >> (char&)_Ch);
}
		
template<class _Elem,
class _Traits> inline
basic_istream<_Elem, _Traits>&
__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
{	
typedef basic_istream<_Elem, _Traits> _Myis;
typedef ctype<_Elem> _Ctype;
	if (!_Istr.eof())
{	
ios_base::iostate _State = ios_base::goodbit;
const typename _Myis::sentry _Ok(_Istr, true);
		if (_Ok)
{	
const _Ctype& _Ctype_fac = use_facet<_Ctype >(_Istr.getloc());
			try {
for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
_Meta = _Istr.rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (!_Ctype_fac.is(_Ctype::space,
_Traits::to_char_type(_Meta)))
break;	
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
		_Istr.setstate(_State);
}
return (_Istr);
}
__declspec(dllimport) inline basic_istream<char, char_traits<char> >&
__cdecl ws(basic_istream<char, char_traits<char> >& _Istr)
{	
typedef char _Elem;
typedef char_traits<_Elem> _Traits;
	if (!_Istr.eof())
{	
ios_base::iostate _State = ios_base::goodbit;
const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
		if (_Ok)
{	
const ctype<_Elem>& _Ctype_fac =
use_facet<ctype<_Elem> >(_Istr.getloc());
			try {
for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
_Meta = _Istr.rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (!_Ctype_fac.is(ctype<_Elem>::space,
_Traits::to_char_type(_Meta)))
break;	
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
		_Istr.setstate(_State);
}
return (_Istr);
}
__declspec(dllimport) inline basic_istream<wchar_t, char_traits<wchar_t> >&
__cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _Istr)
{	
typedef wchar_t _Elem;
typedef char_traits<_Elem> _Traits;
	if (!_Istr.eof())
{	
ios_base::iostate _State = ios_base::goodbit;
const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
		if (_Ok)
{	
const ctype<_Elem>& _Ctype_fac =
use_facet<ctype<_Elem> >(_Istr.getloc());
			try {
for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
_Meta = _Istr.rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (!_Ctype_fac.is(ctype<_Elem>::space,
_Traits::to_char_type(_Meta)))
break;	
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
		_Istr.setstate(_State);
}
return (_Istr);
}
 
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
operator>>(basic_istream<char, char_traits<char> >&, char *);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
operator>>(basic_istream<char, char_traits<char> >&, char&);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
operator>>(basic_istream<char, char_traits<char> >&, signed char *);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
operator>>(basic_istream<char, char_traits<char> >&, signed char&);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
operator>>(basic_istream<char, char_traits<char> >&, unsigned char *);
template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl
operator>>(basic_istream<char, char_traits<char> >&, unsigned char&);
template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl
operator>>(basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl
operator>>(basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);
 
}
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4189)
namespace std {
		
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
const _Elem *_Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
const _Elem _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_string<_Elem, _Traits, _Alloc> __cdecl operator+(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem _Right)
{	
return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator==(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (_Left.compare(_Right) == 0);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator==(
const _Elem * _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (_Right.compare(_Left) == 0);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator==(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (_Left.compare(_Right) == 0);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator!=(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator!=(
const _Elem *_Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator!=(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (!(_Left == _Right));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator<(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (_Left.compare(_Right) < 0);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator<(
const _Elem * _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (_Right.compare(_Left) > 0);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator<(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (_Left.compare(_Right) < 0);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator>(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (_Right < _Left);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator>(
const _Elem * _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (_Right < _Left);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator>(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (_Right < _Left);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator<=(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator<=(
const _Elem * _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator<=(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (!(_Right < _Left));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator>=(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (!(_Left < _Right));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator>=(
const _Elem * _Left,
const basic_string<_Elem, _Traits, _Alloc>& _Right)
{	
return (!(_Left < _Right));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
bool __cdecl operator>=(
const basic_string<_Elem, _Traits, _Alloc>& _Left,
const _Elem *_Right)
{	
return (!(_Left < _Right));
}
 
template __declspec(dllimport) basic_string<char,
char_traits<char>, allocator<char> > __cdecl operator+(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_string<char,
char_traits<char>, allocator<char> > __cdecl operator+(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_string<char,
char_traits<char>, allocator<char> > __cdecl operator+(
const char,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_string<char,
char_traits<char>, allocator<char> > __cdecl operator+(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) basic_string<char,
char_traits<char>, allocator<char> > __cdecl operator+(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char);
template __declspec(dllimport) bool __cdecl operator==(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator==(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator==(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) bool __cdecl operator!=(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator!=(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator!=(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) bool __cdecl operator<(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) bool __cdecl operator>(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) bool __cdecl operator<=(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<=(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator<=(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) bool __cdecl operator>=(
const basic_string<char, char_traits<char>, allocator<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>=(
const char *,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) bool __cdecl operator>=(
const basic_string<char, char_traits<char>, allocator<char> >&,
const char *);
template __declspec(dllimport) basic_string<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&);
template __declspec(dllimport) basic_string<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&);
template __declspec(dllimport) basic_string<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
const wchar_t,
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&);
template __declspec(dllimport) basic_string<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&,
const wchar_t *);
template __declspec(dllimport) basic_string<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&,
const wchar_t);
template __declspec(dllimport) bool __cdecl operator==(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator==(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator==(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t *);
template __declspec(dllimport) bool __cdecl operator!=(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator!=(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator!=(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t *);
template __declspec(dllimport) bool __cdecl operator<(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t *);
template __declspec(dllimport) bool __cdecl operator>(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t *);
template __declspec(dllimport) bool __cdecl operator<=(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<=(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator<=(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t *);
template __declspec(dllimport) bool __cdecl operator>=(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>=(
const wchar_t *,
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) bool __cdecl operator>=(
const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t *);
 
		
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_istream<_Elem, _Traits>& __cdecl operator>>(
basic_istream<_Elem, _Traits>& _Istr,
basic_string<_Elem, _Traits, _Alloc>& _Str)
{	
typedef ctype<_Elem> _Ctype;
typedef basic_istream<_Elem, _Traits> _Myis;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
typedef typename _Mystr::size_type _Mysizt;
	ios_base::iostate _State = ios_base::goodbit;
bool _Changed = false;
const typename _Myis::sentry _Ok(_Istr);
	if (_Ok)
{	
const _Ctype& _Ctype_fac = use_facet<_Ctype >(_Istr.getloc());
_Str.erase();
		try {
_Mysizt _Size = 0 < _Istr.width()
&& (_Mysizt)_Istr.width() < _Str.max_size()
? (_Mysizt)_Istr.width() : _Str.max_size();
typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();
		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
if(_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (_Ctype_fac.is(_Ctype::space,
_Traits::to_char_type(_Meta)))
break;	
else
{	
_Str.append(1, _Traits::to_char_type(_Meta));
_Changed = true;
}
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
	_Istr.width(0);
if (!_Changed)
_State |= ios_base::failbit;
_Istr.setstate(_State);
return (_Istr);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_istream<_Elem, _Traits>& __cdecl getline(
basic_istream<_Elem, _Traits>& _Istr,
basic_string<_Elem, _Traits, _Alloc>& _Str,
const _Elem _Delim)
{	
typedef basic_istream<_Elem, _Traits> _Myis;
ios_base::iostate _State = ios_base::goodbit;
bool _Changed = false;
const typename _Myis::sentry _Ok(_Istr, true);
	if (_Ok)
{	
try {
_Str.erase();
const typename _Traits::int_type _Metadelim =
_Traits::to_int_type(_Delim);
typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();
		for (; ; _Meta = _Istr.rdbuf()->snextc())
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if (_Traits::eq_int_type(_Meta, _Metadelim))
{	
_Changed = true;
_Istr.rdbuf()->sbumpc();
break;
}
else if (_Str.max_size() <= _Str.size())
{	
_State |= ios_base::failbit;
break;
}
else
{	
_Str += _Traits::to_char_type(_Meta);
_Changed = true;
}
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
	if (!_Changed)
_State |= ios_base::failbit;
_Istr.setstate(_State);
return (_Istr);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_istream<_Elem, _Traits>& __cdecl getline(
basic_istream<_Elem, _Traits>& _Istr,
basic_string<_Elem, _Traits, _Alloc>& _Str)
{	
return (getline(_Istr, _Str, _Istr.widen('\n')));
}
template<class _Elem,
class _Traits,
class _Alloc> inline
basic_ostream<_Elem, _Traits>& __cdecl operator<<(
basic_ostream<_Elem, _Traits>& _Ostr,
const basic_string<_Elem, _Traits, _Alloc>& _Str)
{	
typedef basic_ostream<_Elem, _Traits> _Myos;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
typedef typename _Mystr::size_type _Mysizt;
	ios_base::iostate _State = ios_base::goodbit;
_Mysizt _Size = _Str.size();
_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
? 0 : (_Mysizt)_Ostr.width() - _Size;
const typename _Myos::sentry _Ok(_Ostr);
	if (!_Ok)
_State |= ios_base::badbit;
else
{	
try {
if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
		if (_State == ios_base::goodbit)
for (_Mysizt _Count = 0; _Count < _Size; ++_Count)
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Str[_Count])))
{	
_State |= ios_base::badbit;
break;
}
		if (_State == ios_base::goodbit)
for (; 0 < _Pad; --_Pad)	
if (_Traits::eq_int_type(_Traits::eof(),
_Ostr.rdbuf()->sputc(_Ostr.fill())))
{	
_State |= ios_base::badbit;
break;
}
_Ostr.width(0);
} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
}
	_Ostr.setstate(_State);
return (_Ostr);
}
 
template __declspec(dllimport) basic_istream<char,
char_traits<char> >& __cdecl operator>>(
basic_istream<char, char_traits<char> >&,
basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_istream<char,
char_traits<char> >& __cdecl getline(
basic_istream<char, char_traits<char> >&,
basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_istream<char,
char_traits<char> >& __cdecl getline(
basic_istream<char, char_traits<char> >&,
basic_string<char, char_traits<char>, allocator<char> >&,
const char);
template __declspec(dllimport) basic_ostream<char,
char_traits<char> >& __cdecl operator<<(
basic_ostream<char, char_traits<char> >&,
const basic_string<char, char_traits<char>, allocator<char> >&);
template __declspec(dllimport) basic_istream<wchar_t,
char_traits<wchar_t> >& __cdecl operator>>(
basic_istream<wchar_t, char_traits<wchar_t> >&,
basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) basic_istream<wchar_t,
char_traits<wchar_t> >& __cdecl getline(
basic_istream<wchar_t, char_traits<wchar_t> >&,
basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template __declspec(dllimport) basic_istream<wchar_t,
char_traits<wchar_t> >& __cdecl getline(
basic_istream<wchar_t, char_traits<wchar_t> >&,
basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
const wchar_t);
template __declspec(dllimport) basic_ostream<wchar_t,
char_traits<wchar_t> >& __cdecl operator<<(
basic_ostream<wchar_t, char_traits<wchar_t> >&,
const basic_string<wchar_t, char_traits<wchar_t>,
allocator<wchar_t> >&);
 
}
 #pragma warning(default: 4189)
#pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Kty,	
class _Pr,	
class _Alloc,	
bool _Mfl>	
class _Tset_traits
: public _Container_base_aux_alloc_real<_Alloc>
{	
public:
typedef _Kty key_type;
typedef _Kty value_type;
typedef _Pr key_compare;
typedef typename _Alloc::template rebind<value_type>::other
allocator_type;
	typedef typename allocator_type::const_pointer _ITptr;
typedef typename allocator_type::const_reference _IReft;
	enum
{	
_Multi = _Mfl};
	_Tset_traits(_Pr _Parg, _Alloc _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), comp(_Parg)
{	
}
	typedef key_compare value_compare;
	static const _Kty& _Kfn(const value_type& _Val)
{	
return (_Val);
}
	_Pr comp;	
};
		
template<class _Kty,
class _Pr = less<_Kty>,
class _Alloc = allocator<_Kty> >
class set
: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> >
{	
public:
typedef set<_Kty, _Pr, _Alloc> _Myt;
typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false> > _Mybase;
typedef _Kty key_type;
typedef _Pr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	set()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit set(const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
}
	set(const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
}
	template<class _Iter>
set(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
set(_Iter _First, _Iter _Last,
const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
set(_Iter _First, _Iter _Last,
const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
 
	};
	
template<class _Kty, class _Pr, class _Alloc>
class _Move_operation_category<set<_Kty, _Pr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
template<class _Kty,
class _Pr,
class _Alloc> inline
void swap(set<_Kty, _Pr, _Alloc>& _Left,
set<_Kty, _Pr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
		
template<class _Kty,
class _Pr = less<_Kty>,
class _Alloc = allocator<_Kty> >
class multiset
: public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> >
{	
public:
typedef multiset<_Kty, _Pr, _Alloc> _Myt;
typedef _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true> > _Mybase;
typedef _Kty key_type;
typedef _Pr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	multiset()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit multiset(const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
}
	multiset(const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
}
	template<class _Iter>
multiset(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
multiset(_Iter _First, _Iter _Last,
const key_compare& _Pred)
: _Mybase(_Pred, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
multiset(_Iter _First, _Iter _Last,
const key_compare& _Pred, const allocator_type& _Al)
: _Mybase(_Pred, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
 
	iterator insert(const value_type& _Val)
{	
return (_Mybase::insert(_Val).first);
}
	iterator insert(const_iterator _Where, const value_type& _Val)
{	
return (_Mybase::insert(_Where, _Val));
}
	template<class _Iter>
void insert(_Iter _First, _Iter _Last)
{	
 
		for (; _First != _Last; ++_First)
this->insert(*_First);
}
};
	
template<class _Kty, class _Pr, class _Alloc>
class _Move_operation_category<multiset<_Kty, _Pr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
template<class _Kty,
class _Pr,
class _Alloc> inline
void swap(multiset<_Kty, _Pr, _Alloc>& _Left,
multiset<_Kty, _Pr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
 
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
namespace std {
		
template<class _Ty,
class _Alloc>
class _List_nod
: public _Container_base_aux_alloc_real<_Alloc>
{	
protected:
struct _Node;
friend struct _Node;
typedef _Node *_Nodeptr;	
    
    
#pragma warning(push)
#pragma warning(disable:4512)
struct _Node
{	
_Node()
{	
}
		_Nodeptr _Next;	
_Nodeptr _Prev;	
_Ty _Myval;	
};
#pragma warning(pop)
	_List_nod(_Alloc _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), _Alnod(_Al)
{	
}
	typename _Alloc::template rebind<_Node>::other
_Alnod;	
};
		
template<class _Ty,
class _Alloc>
class _List_ptr
: public _List_nod<_Ty, _Alloc>
{	
protected:
typedef _List_nod<_Ty, _Alloc> _Mybase;
typedef typename _Mybase::_Node _Node;
typedef typename _Mybase::_Nodeptr _Nodeptr;
	_List_ptr(_Alloc _Al)
: _List_nod<_Ty, _Alloc>(_Al), _Alptr(_Al)
{	
}
	typename _Alloc::template rebind<_Nodeptr>::other
_Alptr;	
};
		
template<class _Ty,
class _Alloc>
class _List_val
: public _List_ptr<_Ty, _Alloc>
{	
public:
typedef typename _Alloc::template rebind<_Ty>::other _Alty;
	_List_val(_Alloc _Al = _Alloc())
: _List_ptr<_Ty, _Alloc>(_Al), _Alval(_Al)
{	
}
	_Alty _Alval;	
};
		
template<class _Ty,
class _Ax = allocator<_Ty> >
class list
: public _List_val<_Ty, _Ax>
{	
public:
typedef list<_Ty, _Ax> _Myt;
typedef _List_val<_Ty, _Ax> _Mybase;
typedef typename _Mybase::_Alty _Alloc;
protected:
typedef typename _Mybase::_Node _Node;
typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename _Alloc::template rebind<_Nodeptr>::other
_Nodeptr_alloc;
typedef typename _Nodeptr_alloc::reference _Nodepref;
	typedef typename _Alloc::reference _Vref;
	static _Nodepref _Nextnode(_Nodeptr _Pnode)
{	
return ((_Nodepref)(*_Pnode)._Next);
}
	static _Nodepref _Prevnode(_Nodeptr _Pnode)
{	
return ((_Nodepref)(*_Pnode)._Prev);
}
	static _Vref _Myval(_Nodeptr _Pnode)
{	
return ((_Vref)(*_Pnode)._Myval);
}
public:
typedef _Alloc allocator_type;
typedef typename _Alloc::size_type size_type;
typedef typename _Alloc::difference_type _Dift;
typedef _Dift difference_type;
typedef typename _Alloc::pointer _Tptr;
typedef typename _Alloc::const_pointer _Ctptr;
typedef _Tptr pointer;
typedef _Ctptr const_pointer;
typedef typename _Alloc::reference _Reft;
typedef _Reft reference;
typedef typename _Alloc::const_reference const_reference;
typedef typename _Alloc::value_type value_type;
		
template <bool _Secure_validation> class _Const_iterator;
friend class _Const_iterator<true>;
	friend class _Const_iterator<false>;
	template <bool _Secure_validation>
class _Const_iterator
: public _Bidit<_Ty, _Dift, _Ctptr, const_reference>
{	
public:
typedef _Const_iterator<_Secure_validation> _Myt_iter;
typedef bidirectional_iterator_tag iterator_category;
typedef _Ty value_type;
typedef _Dift difference_type;
typedef _Ctptr pointer;
typedef const_reference reference;
		_Const_iterator()
: _Ptr(0)
{	
}
 
		_Const_iterator(_Nodeptr _Pnode, const _Myt *_Plist)
: _Ptr(_Pnode)
{	
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Plist != 0)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
this->_Set_container(_Plist);
}
 
 
typedef typename _Secure_validation_helper<_Secure_validation>::_Checked_iterator_category _Checked_iterator_category;
typedef typename _If<_Secure_validation,
_Const_iterator<false>,
_Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
	friend _Const_iterator<false>;
friend _Const_iterator<true>;
	_Const_iterator<false> _Checked_iterator_base() const
{
_Const_iterator<false> _Base(this->_Ptr, ((_Myt *)this->_Getmycont()));
return _Base;
}
	void _Checked_iterator_assign_from_base(_Const_iterator<false> _Base)
{
{ if (!(this->_Same_container(_Base))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Ptr = _Base._Ptr;
}
		const_reference operator*() const
{	
 
			{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
			return (_Myval(_Ptr));
}
		_Ctptr operator->() const
{	
return (&**this);
}
		_Myt_iter& operator++()
{	
 
			{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
			_Ptr = _Nextnode(_Ptr);
return (*this);
}
		_Myt_iter operator++(int)
{	
_Myt_iter _Tmp = *this;
++*this;
return (_Tmp);
}
		_Myt_iter& operator--()
{	
 
			{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
_Ptr = _Prevnode(_Ptr);
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
			return (*this);
}
		_Myt_iter operator--(int)
{	
_Myt_iter _Tmp = *this;
--*this;
return (_Tmp);
}
		bool operator==(const _Myt_iter& _Right) const
{	
 
			{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
			return (_Ptr == _Right._Ptr);
}
		bool operator!=(const _Myt_iter& _Right) const
{	
return (!(*this == _Right));
}
		_Nodeptr _Mynode() const
{	
return (_Ptr);
}
 
		_Nodeptr _Ptr;	
};
	typedef _Const_iterator<true> const_iterator;
		
template <bool _Secure_validation> class _Iterator;
friend class _Iterator<true>;
	friend class _Iterator<false>;
	template <bool _Secure_validation>
class _Iterator
: public _Const_iterator<_Secure_validation>
{	
public:
friend class list<_Ty, _Ax>;
typedef _Iterator<_Secure_validation> _Myt_iter;
typedef _Const_iterator<_Secure_validation> _Mybase_iter;
typedef bidirectional_iterator_tag iterator_category;
typedef _Ty value_type;
typedef _Dift difference_type;
typedef _Tptr pointer;
typedef _Reft reference;
		_Iterator()
{	
}
 
		_Iterator(_Nodeptr _Pnode, const _Myt *_Plist)
: _Mybase_iter(_Pnode, _Plist)
{	
}
 
 
typedef typename _If<_Secure_validation,
_Iterator<false>,
_Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
	friend _Iterator<false>;
friend _Iterator<true>;
	_Iterator<false> _Checked_iterator_base() const
{
_Iterator<false> _Base(this->_Ptr, ((_Myt *)this->_Getmycont()));
return _Base;
}
	void _Checked_iterator_assign_from_base(_Iterator<false> _Base)
{
{ if (!(this->_Same_container(_Base))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Ptr = _Base._Ptr;
}
		reference operator*() const
{	
return ((reference)**(_Mybase_iter *)this);
}
		_Tptr operator->() const
{	
return (&**this);
}
		_Myt_iter& operator++()
{	
++(*(_Mybase_iter *)this);
return (*this);
}
		_Myt_iter operator++(int)
{	
_Myt_iter _Tmp = *this;
++*this;
return (_Tmp);
}
		_Myt_iter& operator--()
{	
--(*(_Mybase_iter *)this);
return (*this);
}
		_Myt_iter operator--(int)
{	
_Myt_iter _Tmp = *this;
--*this;
return (_Tmp);
}
};
	typedef _Iterator<true> iterator;
	typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	list()
: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
{	
}
	explicit list(const _Alloc& _Al)
: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
{	
}
	explicit list(size_type _Count)
: _Mybase(), _Mysize(0)
{	
_Ty _Val = _Ty();
_Myhead = _Buynode();
_Construct_n(_Count, _Val);
}
	list(size_type _Count, const _Ty& _Val)
: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
{	
_Construct_n(_Count, _Val);
}
	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
{	
_Construct_n(_Count, _Val);
}
	list(const _Myt& _Right)
: _Mybase(_Right._Alval),
_Myhead(_Buynode()), _Mysize(0)
{	
try {
insert(begin(), _Right.begin(), _Right.end());
} catch (...) {
_Tidy();
throw;
}
}
	template<class _Iter>
list(_Iter _First, _Iter _Last)
: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
{	
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
list(_Iter _First, _Iter _Last, const _Alloc& _Al)
: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
{	
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
{	
_Construct_n((size_type)_Count, (_Ty)_Val);
}
	template<class _Iter>
void _Construct(_Iter _First,
_Iter _Last, input_iterator_tag)
{	
try {
insert(begin(), _First, _Last);
} catch (...) {
_Tidy();
throw;
}
}
	void _Construct_n(size_type _Count,
const _Ty& _Val)
{	
try {
_Insert_n(begin(), _Count, _Val);
} catch (...) {
_Tidy();
throw;
}
}
	~list()
{	
_Tidy();
}
	_Myt& operator=(const _Myt& _Right)
{	
if (this != &_Right)
assign(_Right.begin(), _Right.end());
return (*this);
}
 
iterator begin()
{	
return (iterator(_Nextnode(_Myhead), this));
}
	const_iterator begin() const
{	
return (const_iterator(_Nextnode(_Myhead), this));
}
	iterator end()
{	
return (iterator(_Myhead, this));
}
	const_iterator end() const
{	
return (const_iterator(_Myhead, this));
}
	iterator _Make_iter(const_iterator _Where) const
{	
return (iterator(_Where._Ptr, this));
}
 
	reverse_iterator rbegin()
{	
return (reverse_iterator(end()));
}
	const_reverse_iterator rbegin() const
{	
return (const_reverse_iterator(end()));
}
	reverse_iterator rend()
{	
return (reverse_iterator(begin()));
}
	const_reverse_iterator rend() const
{	
return (const_reverse_iterator(begin()));
}
	void resize(size_type _Newsize)
{	
resize(_Newsize, _Ty());
}
	void resize(size_type _Newsize, _Ty _Val)
{	
if (_Mysize < _Newsize)
_Insert_n(end(), _Newsize - _Mysize, _Val);
else
while (_Newsize < _Mysize)
pop_back();
}
	size_type size() const
{	
return (_Mysize);
}
	size_type max_size() const
{	
return (this->_Alval.max_size());
}
	bool empty() const
{	
return (_Mysize == 0);
}
	allocator_type get_allocator() const
{	
return (this->_Alval);
}
	reference front()
{	
return (*begin());
}
	const_reference front() const
{	
return (*begin());
}
	reference back()
{	
return (*(--end()));
}
	const_reference back() const
{	
return (*(--end()));
}
	void push_front(const _Ty& _Val)
{	
_Insert(begin(), _Val);
}
	void pop_front()
{	
erase(begin());
}
	void push_back(const _Ty& _Val)
{	
_Insert(end(), _Val);
}
	void pop_back()
{	
erase(--end());
}
	template<class _Iter>
void assign(_Iter _First, _Iter _Last)
{	
_Assign(_First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
{	
_Assign_n((size_type)_Count, (_Ty)_Val);
}
	template<class _Iter>
void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
{	
clear();
insert(begin(), _First, _Last);
}
	void assign(size_type _Count, const _Ty& _Val)
{	
_Assign_n(_Count, _Val);
}
	iterator insert(const_iterator _Where, const _Ty& _Val)
{	
_Insert(_Where, _Val);
return (_Make_iter(--_Where));
}
	void _Insert(const_iterator _Where,
const _Ty& _Val)
{	
 
		_Nodeptr _Pnode = _Where._Mynode();
_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);
_Incsize(1);
_Prevnode(_Pnode) = _Newnode;
_Nextnode(_Prevnode(_Newnode)) = _Newnode;
}
	void insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
{	
_Insert_n(_Where, _Count, _Val);
}
	template<class _Iter>
void insert(const_iterator _Where, _Iter _First, _Iter _Last)
{	
_Insert(_Where, _First, _Last, _Iter_cat(_First));
}
	template<class _Iter>
void _Insert(const_iterator _Where, _Iter _Count, _Iter _Val,
_Int_iterator_tag)
{	
_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
}
	template<class _Iter>
void _Insert(const_iterator _Where,
_Iter _First, _Iter _Last, input_iterator_tag)
{	
size_type _Num = 0;
		try {
for (; _First != _Last; ++_First, ++_Num)
_Insert(_Where, *_First);
} catch (...) {
for (; 0 < _Num; --_Num)
{	
const_iterator _Before = _Where;
erase(--_Before);
}
throw;
}
}
	template<class _Iter>
void _Insert(const_iterator _Where,
_Iter _First, _Iter _Last, forward_iterator_tag)
{	
 
		_Iter _Next = _First;
		try {
for (; _First != _Last; ++_First)
_Insert(_Where, *_First);
} catch (...) {
for (; _Next != _First; ++_Next)
{	
const_iterator _Before = _Where;
erase(--_Before);
}
throw;
}
}
	iterator erase(const_iterator _Where)
{	
 
		_Nodeptr _Pnode = (_Where++)._Mynode();
		if (_Pnode != _Myhead)
{	
_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);
_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);
this->_Alnod.destroy(_Pnode);
this->_Alnod.deallocate(_Pnode, 1);
--_Mysize;
}
return (_Make_iter(_Where));
}
	iterator erase(const_iterator _First, const_iterator _Last)
{	
if (_First == begin() && _Last == end())
{	
clear();
return (end());
}
else
{	
while (_First != _Last)
_First = erase(_First);
return (_Make_iter(_Last));
}
}
	void clear()
{	
 
		_Nodeptr _Pnext;
_Nodeptr _Pnode = _Nextnode(_Myhead);
_Nextnode(_Myhead) = _Myhead;
_Prevnode(_Myhead) = _Myhead;
_Mysize = 0;
		for (; _Pnode != _Myhead; _Pnode = _Pnext)
{	
_Pnext = _Nextnode(_Pnode);
this->_Alnod.destroy(_Pnode);
this->_Alnod.deallocate(_Pnode, 1);
}
}
	void swap(_Myt& _Right)
{	
if (this == &_Right)
;	
else if (this->_Alval == _Right._Alval)
{	
 
			this->_Swap_aux(_Right);
			std::swap(_Myhead, _Right._Myhead);
std::swap(_Mysize, _Right._Mysize);
}
else
{	
this->_Swap_aux(_Right);
			iterator _Where = begin();
splice(_Where, _Right);
_Right.splice(_Right.begin(), *this, _Where, end());
}
}
	void splice(const_iterator _Where, _Myt& _Right)
{	
if (this != &_Right && !_Right.empty())
{	
_Splice(_Where, _Right, _Right.begin(), _Right.end(),
_Right._Mysize);
}
}
	void splice(const_iterator _Where, _Myt& _Right, const_iterator _First)
{	
 
		if (_First != _Right.end())
			{	
const_iterator _Last = _First;
++_Last;
if (this != &_Right
|| (_Where != _First && _Where != _Last))
_Splice(_Where, _Right, _First, _Last, 1);
}
}
	void splice(const_iterator _Where,
_Myt& _Right, const_iterator _First, const_iterator _Last)
{	
if (_First != _Last && (this != &_Right || _Where != _Last))
{	
size_type _Count = 0;
if (this == &_Right)
;	
else if (_First == _Right.begin() && _Last == _Right.end())
_Count = _Right._Mysize;	
else
{	
const_iterator _Next = _First;
				for (; _Next != _Last; ++_Next, ++_Count)
if (_Next == _Right.end())
if (_First == _Right.end())
throw length_error("list<T> bad splice");
}
_Splice(_Where, _Right, _First, _Last, _Count);
}
}
	void remove(const _Ty& _Val_arg)
{	
		const _Ty _Val = _Val_arg;	
iterator _Last = end();
for (iterator _First = begin(); _First != _Last; )
if (*_First == _Val)
_First = erase(_First);
else
++_First;
}
	template<class _Pr1>
void remove_if(_Pr1 _Pred)
{	
iterator _Last = end();
for (iterator _First = begin(); _First != _Last; )
if (_Pred(*_First))
_First = erase(_First);
else
++_First;
}
	void unique()
{	
if (2 <= _Mysize)
{	
iterator _First = begin();
iterator _After = _First;
for (++_After; _After != end(); )
if (*_First == *_After)
_After = erase(_After);
else
_First = _After++;
}
}
	template<class _Pr2>
void unique(_Pr2 _Pred)
{	
if (2 <= _Mysize)
{	
iterator _First = begin();
iterator _After = _First;
for (++_After; _After != end(); )
if (_Pred(*_First, *_After))
_After = erase(_After);
else
_First = _After++;
}
}
	void merge(_Myt& _Right)
{	
if (&_Right != this)
{	
iterator _First1 = begin(), _Last1 = end();
iterator _First2 = _Right.begin(), _Last2 = _Right.end();
;
;
			while (_First1 != _Last1 && _First2 != _Last2)
if (((*_First2) < (*_First1)))
{	
iterator _Mid2 = _First2;
_Splice(_First1, _Right, _First2, ++_Mid2, 1);
_First2 = _Mid2;
}
else
++_First1;
			if (_First2 != _Last2)
_Splice(_Last1, _Right, _First2, _Last2,
_Right._Mysize);	
}
}
	template<class _Pr3>
void merge(_Myt& _Right, _Pr3 _Pred)
{	
if (&_Right != this)
{	
iterator _First1 = begin(), _Last1 = end();
iterator _First2 = _Right.begin(), _Last2 = _Right.end();
;
;
			while (_First1 != _Last1 && _First2 != _Last2)
if (_Pred(*_First2, *_First1))
{	
iterator _Mid2 = _First2;
_Splice(_First1, _Right, _First2, ++_Mid2, 1);
_First2 = _Mid2;
}
else
++_First1;
			if (_First2 != _Last2)
_Splice(_Last1, _Right, _First2, _Last2,
_Right._Mysize);	
}
}
	void sort()
{	
if (2 <= _Mysize)
{	
const size_t _MAXBINS = 25;
_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
size_t _Maxbin = 0;
			while (!empty())
{	
_Templist._Splice(_Templist.begin(), *this, begin(),
++begin(), 1, true);	
				size_t _Bin;
for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
++_Bin)
{	
_Binlist[_Bin].merge(_Templist);
_Binlist[_Bin].swap(_Templist);
}
				if (_Bin == _MAXBINS)
_Binlist[_Bin - 1].merge(_Templist);
else
{	
_Binlist[_Bin].swap(_Templist);
if (_Bin == _Maxbin)
++_Maxbin;
}
}
			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	
splice(begin(), _Binlist[_Maxbin - 1]);	
}
}
	template<class _Pr3>
void sort(_Pr3 _Pred)
{	
if (2 <= _Mysize)
{	
const size_t _MAXBINS = 25;
_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
size_t _Maxbin = 0;
			while (!empty())
{	
_Templist._Splice(_Templist.begin(), *this, begin(),
++begin(), 1, true);	
				size_t _Bin;
for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
++_Bin)
{	
_Binlist[_Bin].merge(_Templist, _Pred);
_Binlist[_Bin].swap(_Templist);
}
				if (_Bin == _MAXBINS)
_Binlist[_Bin - 1].merge(_Templist, _Pred);
else
{	
_Binlist[_Bin].swap(_Templist);
if (_Bin == _Maxbin)
++_Maxbin;
}
}
			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
_Binlist[_Bin].merge(_Binlist[_Bin - 1],
_Pred);	
splice(begin(), _Binlist[_Maxbin - 1]);	
}
}
	void reverse()
{	
if (2 <= _Mysize)
{	
iterator _Last = end();
for (iterator _Next = ++begin(); _Next != _Last; )
{	
iterator _Before = _Next;
_Splice(begin(), *this, _Before, ++_Next, 1);
}
}
}
	void _Splice(const_iterator _Where,
_Myt& _Right, const_iterator _First, const_iterator _Last,
size_type _Count, bool _Keep = false)
{	
        _Keep;                  
if (this->_Alval == _Right._Alval)
{	
			if (this != &_Right)
{	
_Incsize(_Count);
_Right._Mysize -= _Count;
}
_Nextnode(_Prevnode(_First._Mynode())) = _Last._Mynode();
_Nextnode(_Prevnode(_Last._Mynode())) = _Where._Mynode();
_Nextnode(_Prevnode(_Where._Mynode())) = _First._Mynode();
_Nodeptr _Pnode = _Prevnode(_Where._Mynode());
_Prevnode(_Where._Mynode()) = _Prevnode(_Last._Mynode());
_Prevnode(_Last._Mynode()) = _Prevnode(_First._Mynode());
_Prevnode(_First._Mynode()) = _Pnode;
}
else
{	
insert(_Where, _First, _Last);
_Right.erase(_First, _Last);
}
}
protected:
void _Assign_n(size_type _Count, const _Ty& _Val)
{	
_Ty _Tmp = _Val;	
clear();
_Insert_n(begin(), _Count, _Tmp);
}
	_Nodeptr _Buynode()
{	
_Nodeptr _Pnode = this->_Alnod.allocate(1);
int _Linkcnt = 0;
		try {
this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);
++_Linkcnt;
this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);
} catch (...) {
if (0 < _Linkcnt)
this->_Alptr.destroy(&_Nextnode(_Pnode));
this->_Alnod.deallocate(_Pnode, 1);
throw;
}
return (_Pnode);
}
	_Nodeptr _Buynode(_Nodeptr _Next,
_Nodeptr _Prev, const _Ty& _Val)
{	
_Nodeptr _Pnode = this->_Alnod.allocate(1);
int _Linkcnt = 0;
		try {
this->_Alptr.construct(&_Nextnode(_Pnode), _Next);
++_Linkcnt;
this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);
++_Linkcnt;
this->_Alval.construct(&_Myval(_Pnode), _Val);
} catch (...) {
if (1 < _Linkcnt)
this->_Alptr.destroy(&_Prevnode(_Pnode));
if (0 < _Linkcnt)
this->_Alptr.destroy(&_Nextnode(_Pnode));
this->_Alnod.deallocate(_Pnode, 1);
throw;
}
return (_Pnode);
}
	void _Tidy()
{	
clear();
this->_Alptr.destroy(&_Nextnode(_Myhead));
this->_Alptr.destroy(&_Prevnode(_Myhead));
this->_Alnod.deallocate(_Myhead, 1);
_Myhead = 0;
}
	void _Insert_n(const_iterator _Where,
size_type _Count, const _Ty& _Val)
{	
size_type _Countsave = _Count;
		try {
for (; 0 < _Count; --_Count)
_Insert(_Where, _Val);
} catch (...) {
for (; _Count < _Countsave; ++_Count)
{	
const_iterator _Before = _Where;
erase(--_Before);
}
throw;
}
}
	void _Incsize(size_type _Count)
{	
if (max_size() - _Mysize < _Count)
throw length_error("list<T> too long");
_Mysize += _Count;
}
	static void _Xran()
{	
throw out_of_range("invalid list<T> subscript");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid list<T> argument");
}
 
	_Nodeptr _Myhead;	
size_type _Mysize;	
};
	
template <class _Ty, class _Ax>
class _Move_operation_category<list<_Ty, _Ax> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
template<class _Ty,
class _Alloc> inline
void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
template<class _Ty,
class _Alloc> inline
bool operator==(const list<_Ty, _Alloc>& _Left,
const list<_Ty, _Alloc>& _Right)
{	
return (_Left.size() == _Right.size()
&& equal(_Left.begin(), _Left.end(), _Right.begin()));
}
template<class _Ty,
class _Alloc> inline
bool operator!=(const list<_Ty, _Alloc>& _Left,
const list<_Ty, _Alloc>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty,
class _Alloc> inline
bool operator<(const list<_Ty, _Alloc>& _Left,
const list<_Ty, _Alloc>& _Right)
{	
return (lexicographical_compare(_Left.begin(), _Left.end(),
_Right.begin(), _Right.end()));
}
template<class _Ty,
class _Alloc> inline
bool operator>(const list<_Ty, _Alloc>& _Left,
const list<_Ty, _Alloc>& _Right)
{	
return (_Right < _Left);
}
template<class _Ty,
class _Alloc> inline
bool operator<=(const list<_Ty, _Alloc>& _Left,
const list<_Ty, _Alloc>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty,
class _Alloc> inline
bool operator>=(const list<_Ty, _Alloc>& _Left,
const list<_Ty, _Alloc>& _Right)
{	
return (!(_Left < _Right));
}
  #pragma warning(default:4284)
 
}
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
template<class _Ty,
class _Ax = allocator<_Ty> >
class deque;
		
template<class _Ty, class _Alloc, bool _Secure_validation>
class _Deque_const_iterator
		: public _Ranit<_Ty, typename _Alloc::difference_type,
typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{	
public:
	enum { _EEN_HID = 0 };
	typedef _Deque_const_iterator<_Ty, _Alloc, _Secure_validation> _Myt;
typedef deque<_Ty, _Alloc> _Mydeque;
	typedef _Container_base _Mydequebase;
	typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef typename _Alloc::difference_type difference_type;
typedef typename _Alloc::const_pointer pointer;
typedef typename _Alloc::const_reference reference;
	typedef typename _Alloc::size_type size_type;
 
typedef typename _Secure_validation_helper<_Secure_validation>::_Checked_iterator_category _Checked_iterator_category;
typedef typename _If<_Secure_validation,
_Deque_const_iterator<_Ty, _Alloc, false>,
_Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
	friend _Deque_const_iterator<_Ty, _Alloc, false>;
friend _Deque_const_iterator<_Ty, _Alloc, true>;
	_Deque_const_iterator<_Ty, _Alloc, false> _Checked_iterator_base() const
{
_Deque_const_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());
return _Base;
}
	void _Checked_iterator_assign_from_base(_Deque_const_iterator<_Ty, _Alloc, false> _Base)
{
{ if (!(this->_Same_container(_Base))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Myoff = _Base._Myoff;
}
 
		_Deque_const_iterator()
{	
_Myoff = 0;
}
		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)
{	
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Pdeque != 0 && ((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize))) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
			this->_Set_container(_Pdeque);
_Myoff = _Off;
}
		reference operator*() const
{	
size_type _Block = _Myoff / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
size_type _Off = _Myoff & ((sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) - 1);	
{ if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
{ if (!(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)
_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;
return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);
}
	pointer operator->() const
{	
return (&**this);
}
	_Myt& operator++()
{	
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
 
		++_Myoff;
return (*this);
}
	_Myt operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt& operator--()
{	
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Myoff > ((_Mydeque *)(this->_Getmycont()))->_Myoff)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
 
		--_Myoff;
return (*this);
}
	_Myt operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt& operator+=(difference_type _Off)
{	
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container())) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(_Myoff + _Off <= ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize && _Myoff + _Off >= ((_Mydeque *)(this->_Getmycont()))->_Myoff)) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
_Myoff += _Off;
return (*this);
}
	_Myt operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Myt operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const _Myt& _Right) const
{	
 
		{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
: -(difference_type)(_Right._Myoff - _Myoff));
}
	reference operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
	bool operator==(const _Myt& _Right) const
{	
 
		{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
return (_Myoff == _Right._Myoff);
}
 
	bool operator!=(const _Myt& _Right) const
{	
return (!(*this == _Right));
}
	bool operator<(const _Myt& _Right) const
{	
 
		{ __pragma(warning(push)); __pragma(warning(disable: 4127)); if (_Secure_validation) { { if (!(this->_Has_container() && this->_Same_container(_Right))) { ((void)0); ::_invalid_parameter_noinfo(); } ; } } __pragma(warning(pop)); };
return (_Myoff < _Right._Myoff);
}
 
	bool operator>(const _Myt& _Right) const
{	
return (_Right < *this);
}
	bool operator<=(const _Myt& _Right) const
{	
return (!(_Right < *this));
}
	bool operator>=(const _Myt& _Right) const
{	
return (!(*this < _Right));
}
	static void _Xlen()
{	
throw length_error("deque<T> too long");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid deque <T> argument");
}
	static void _Xran()
{	
throw out_of_range("invalid deque <T> subscript");
}
 
	size_type _Myoff;	
};
template<class _Ty, class _Alloc, bool _Secure_validation>
inline
_Deque_const_iterator<_Ty, _Alloc, _Secure_validation> operator+(
typename _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>::difference_type _Off,
_Deque_const_iterator<_Ty, _Alloc, _Secure_validation> _Next)
{	
return (_Next += _Off);
}
		
template<class _Ty, class _Alloc, bool _Secure_validation>
class _Deque_iterator
: public _Deque_const_iterator<_Ty, _Alloc, _Secure_validation>
{	
public:
typedef _Deque_iterator<_Ty, _Alloc, _Secure_validation> _Myt;
typedef _Deque_const_iterator<_Ty, _Alloc, _Secure_validation> _Mybase;
typedef deque<_Ty, _Alloc> _Mydeque;
	typedef random_access_iterator_tag iterator_category;
typedef _Ty value_type;
typedef typename _Alloc::difference_type difference_type;
typedef typename _Alloc::pointer pointer;
typedef typename _Alloc::reference reference;
	typedef typename _Alloc::size_type size_type;
 
typedef typename _If<_Secure_validation,
_Deque_iterator<_Ty, _Alloc, false>,
_Unchanged_checked_iterator_base_type_tag>::_Result _Checked_iterator_base_type;
	friend _Deque_iterator<_Ty, _Alloc, false>;
friend _Deque_iterator<_Ty, _Alloc, true>;
	_Deque_iterator<_Ty, _Alloc, false> _Checked_iterator_base() const
{
_Deque_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());
return _Base;
}
	void _Checked_iterator_assign_from_base(_Deque_iterator<_Ty, _Alloc, false> _Base)
{
{ if (!(this->_Same_container(_Base))) { ((void)0); ::_invalid_parameter_noinfo(); } ; };
this->_Myoff = _Base._Myoff;
}
	_Deque_iterator()
{	
}
	_Deque_iterator(size_type _Off, const _Mybase::_Mydequebase *_Pdeque)
: _Mybase(_Off, _Pdeque)
{	
}
	reference operator*() const
{	
return ((reference)**(_Mybase *)this);
}
	pointer operator->() const
{	
return (&**this);
}
	_Myt& operator++()
{	
++*(_Mybase *)this;
return (*this);
}
	_Myt operator++(int)
{	
_Myt _Tmp = *this;
++*this;
return (_Tmp);
}
	_Myt& operator--()
{	
--*(_Mybase *)this;
return (*this);
}
	_Myt operator--(int)
{	
_Myt _Tmp = *this;
--*this;
return (_Tmp);
}
	_Myt& operator+=(difference_type _Off)
{	
*(_Mybase *)this += _Off;
return (*this);
}
	_Myt operator+(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp += _Off);
}
	_Myt& operator-=(difference_type _Off)
{	
return (*this += -_Off);
}
	_Myt operator-(difference_type _Off) const
{	
_Myt _Tmp = *this;
return (_Tmp -= _Off);
}
	difference_type operator-(const _Mybase& _Right) const
{	
return (*(_Mybase *)this - _Right);
}
	reference operator[](difference_type _Off) const
{	
return (*(*this + _Off));
}
};
template<class _Ty, class _Alloc, bool _Secure_validation>
inline
_Deque_iterator<_Ty, _Alloc, _Secure_validation> operator+(
typename _Deque_iterator<_Ty, _Alloc, _Secure_validation>::difference_type _Off,
_Deque_iterator<_Ty, _Alloc, _Secure_validation> _Next)
{	
return (_Next += _Off);
}
	
		
template<class _Ty,
class _Alloc>
class _Deque_map
: public _Container_base_aux_alloc_real<_Alloc>
{	
protected:
_Deque_map(_Alloc _Al)
: _Container_base_aux_alloc_real<_Alloc>(_Al), _Almap(_Al)
{	
}
	typedef typename _Alloc::template rebind<_Ty>::other _Ty_alloc;
typedef typename _Ty_alloc::pointer _Tptr;
	typedef typename _Alloc::template rebind<_Tptr>::other
_Tptr_alloc;
typedef typename _Tptr_alloc::pointer _Mptr;
	_Tptr_alloc _Almap;	
};
		
template<class _Ty,
class _Alloc>
class _Deque_val
: public _Deque_map<_Ty, _Alloc>
{	
protected:
_Deque_val(_Alloc _Al = _Alloc())
: _Deque_map<_Ty, _Alloc>(_Al), _Alval(_Al)
{	
}
	typedef _Deque_map<_Ty, _Alloc> _Mybase;
typedef typename _Alloc::template rebind<_Ty>::other _Alty;
	_Alty _Alval;	
};
		
template<class _Ty,
class _Ax>
class deque
: public _Deque_val<_Ty, _Ax>
{	
public:
	
static const int _EEM_DS = (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
enum { _EEN_DS = (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) };
	typedef deque<_Ty, _Ax> _Myt;
typedef _Deque_val<_Ty, _Ax> _Mybase;
typedef typename _Mybase::_Alty _Alloc;
typedef _Alloc allocator_type;
typedef typename _Mybase::_Tptr_alloc _Tptr_alloc;
typedef typename _Alloc::size_type size_type;
typedef typename _Alloc::difference_type _Dift;
typedef _Dift difference_type;
typedef typename _Alloc::pointer _Tptr;
typedef typename _Alloc::const_pointer _Ctptr;
typedef _Tptr pointer;
typedef _Ctptr const_pointer;
typedef typename _Mybase::_Mptr _Mapptr;
typedef typename _Alloc::reference _Reft;
typedef _Reft reference;
typedef typename _Alloc::const_reference const_reference;
typedef typename _Alloc::value_type value_type;
	typedef _Deque_iterator<_Ty, _Alloc, true> iterator;
typedef _Deque_const_iterator<_Ty, _Alloc, true> const_iterator;
	friend class _Deque_const_iterator<_Ty, _Alloc, false>;
	friend class _Deque_const_iterator<_Ty, _Alloc, true>;
	typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	deque()
: _Mybase(), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
}
	explicit deque(const _Alloc& _Al)
: _Mybase(_Al), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
}
	explicit deque(size_type _Count)
: _Mybase(), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
_Construct_n(_Count, _Ty());
}
	deque(size_type _Count, const _Ty& _Val)
: _Mybase(), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
_Construct_n(_Count, _Val);
}
	deque(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
: _Mybase(_Al), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
_Construct_n(_Count, _Val);
}
	deque(const _Myt& _Right)
: _Mybase(_Right._Alval), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
try {
insert(begin(), _Right.begin(), _Right.end());
} catch (...) {
_Tidy();
throw;
}
}
	template<class _It>
deque(_It _First, _It _Last)
: _Mybase(), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _It>
deque(_It _First, _It _Last, const _Alloc& _Al)
: _Mybase(_Al), _Map(0),
_Mapsize(0), _Myoff(0), _Mysize(0)
{	
_Construct(_First, _Last, _Iter_cat(_First));
}
	template<class _It>
void _Construct(_It _Count, _It _Val, _Int_iterator_tag)
{	
_Construct_n((size_type)_Count, (_Ty)_Val);
}
	template<class _It>
void _Construct(_It _First, _It _Last, input_iterator_tag)
{	
try {
insert(begin(), _First, _Last);
} catch (...) {
_Tidy();
throw;
}
}
	void _Construct_n(size_type _Count, const _Ty& _Val)
{	
try {
_Insert_n(begin(), _Count, _Val);
} catch (...) {
_Tidy();
throw;
}
}
	~deque()
{	
_Tidy();
}
	_Myt& operator=(const _Myt& _Right)
{	
if (this == &_Right)
;
else if (_Right._Mysize == 0)
clear();
else if (_Right._Mysize <= _Mysize)
{	
iterator _Mid = std::copy(_Right.begin(), _Right.end(), begin());
erase(_Mid, end());
}
else
{	
const_iterator _Mid = _Right.begin() + _Mysize;
std::copy(_Right.begin(), _Mid, begin());
insert(end(), _Mid, _Right.end());
}
return (*this);
}
	iterator begin()
{	
return (iterator(_Myoff, this));
}
	const_iterator begin() const
{	
return (const_iterator(_Myoff, this));
}
	iterator end()
{	
return (iterator(_Myoff + _Mysize, this));
}
	const_iterator end() const
{	
return (const_iterator(_Myoff + _Mysize, this));
}
	iterator _Make_iter(const_iterator _Where) const
{	
return (iterator(_Where._Myoff, this));
}
	reverse_iterator rbegin()
{	
return (reverse_iterator(end()));
}
	const_reverse_iterator rbegin() const
{	
return (const_reverse_iterator(end()));
}
	reverse_iterator rend()
{	
return (reverse_iterator(begin()));
}
	const_reverse_iterator rend() const
{	
return (const_reverse_iterator(begin()));
}
	void resize(size_type _Newsize)
{	
resize(_Newsize, _Ty());
}
	void resize(size_type _Newsize, _Ty _Val)
{	
if (_Mysize < _Newsize)
_Insert_n(end(), _Newsize - _Mysize, _Val);
else if (_Newsize < _Mysize)
erase(begin() + _Newsize, end());
}
	size_type size() const
{	
return (_Mysize);
}
	size_type max_size() const
{	
return (this->_Alval.max_size());
}
	bool empty() const
{	
return (_Mysize == 0);
}
	allocator_type get_allocator() const
{	
return (this->_Alval);
}
	const_reference at(size_type _Pos) const
{	
if (_Mysize <= _Pos)
_Xran();
return (*(begin() + _Pos));
}
	reference at(size_type _Pos)
{	
if (_Mysize <= _Pos)
_Xran();
return (*(begin() + _Pos));
}
	const_reference operator[](size_type _Pos) const
{	
 
		return (*(begin() + _Pos));
}
	reference operator[](size_type _Pos)
{	
 
		return (*(begin() + _Pos));
}
	reference front()
{	
return (*begin());
}
	const_reference front() const
{	
return (*begin());
}
	reference back()
{	
return (*(end() - 1));
}
	const_reference back() const
{	
return (*(end() - 1));
}
	void push_front(const _Ty& _Val)
{	
 
		if (_Myoff % (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) == 0
&& _Mapsize <= (_Mysize + (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1)) / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1))
_Growmap(1);
size_type _Newoff = _Myoff != 0 ? _Myoff
: _Mapsize * (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
size_type _Block = --_Newoff / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
if (_Map[_Block] == 0)
_Map[_Block] = this->_Alval.allocate((sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1));
this->_Alval.construct(_Map[_Block] + _Newoff % (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1), _Val);
_Myoff = _Newoff;
++_Mysize;
}
	void pop_front()
{	
 
		if (!empty())
{	
			size_type _Block = _Myoff / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
this->_Alval.destroy(_Map[_Block] + _Myoff % (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1));
if (_Mapsize * (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) <= ++_Myoff)
_Myoff = 0;
if (--_Mysize == 0)
_Myoff = 0;
}
}
	void push_back(const _Ty& _Val)
{	
 
		if ((_Myoff + _Mysize) % (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) == 0
&& _Mapsize <= (_Mysize + (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1)) / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1))
_Growmap(1);
size_type _Newoff = _Myoff + _Mysize;
size_type _Block = _Newoff / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
if (_Mapsize <= _Block)
_Block -= _Mapsize;
if (_Map[_Block] == 0)
_Map[_Block] = this->_Alval.allocate((sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1));
this->_Alval.construct(_Map[_Block] + _Newoff % (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1), _Val);
++_Mysize;
}
	void pop_back()
{	
 
		if (!empty())
{	
			size_type _Newoff = _Mysize + _Myoff - 1;
size_type _Block = _Newoff / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
if (_Mapsize <= _Block)
_Block -= _Mapsize;
this->_Alval.destroy(_Map[_Block] + _Newoff % (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1));
if (--_Mysize == 0)
_Myoff = 0;
}
}
	template<class _It>
void assign(_It _First, _It _Last)
{	
_Assign(_First, _Last, _Iter_cat(_First));
}
	template<class _It>
void _Assign(_It _Count, _It _Val, _Int_iterator_tag)
{	
_Assign_n((size_type)_Count, (_Ty)_Val);
}
	template<class _It>
void _Assign(_It _First, _It _Last, input_iterator_tag)
{	
erase(begin(), end());
insert(begin(), _First, _Last);
}
	void assign(size_type _Count, const _Ty& _Val)
{	
_Assign_n(_Count, _Val);
}
	iterator insert(const_iterator _Where, const _Ty& _Val)
{	
if (_Where == begin())
{	
push_front(_Val);
return (begin());
}
else if (_Where == end())
{	
push_back(_Val);
return (end() - 1);
}
else
{	
iterator _Mid;
size_type _Off = _Where - begin();
_Ty _Tmp = _Val;	
 
			if (_Off < _Mysize / 2)
{	
push_front(front());
_Mid = begin() + _Off;
std::copy(begin() + 2, _Mid + 1, begin() + 1);
}
else
{	
push_back(back());
_Mid = begin() + _Off;
std::copy_backward(_Mid, end() - 2, end() - 1);
}
			*_Mid = _Tmp;	
return (_Make_iter(_Mid));
}
}
	void insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
{	
_Insert_n(_Where, _Count, _Val);
}
	template<class _It>
void insert(const_iterator _Where, _It _First, _It _Last)
{	
_Insert(_Where, _First, _Last, _Iter_cat(_First));
}
	template<class _It>
void _Insert(const_iterator _Where, _It _Count, _It _Val,
_Int_iterator_tag)
{	
_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
}
	template<class _It>
void _Insert(const_iterator _Where,
_It _First, _It _Last, input_iterator_tag)
{	
size_type _Off = _Where - begin();
 
		size_type _Rem = _Mysize - _Off;
size_type _Oldsize = _Mysize;
		if (_First == _Last)
;
else if (_Off < _Rem)
{	
try {
for (; _First != _Last; ++_First)
push_front((value_type)*_First);	
			} catch (...) {
for (; _Oldsize < _Mysize; )
pop_front();	
throw;
}
			size_type _Num = _Mysize - _Oldsize;
			if (0 < _Off)
{	
_Reverse(_Num, _Num + _Off);
_Reverse(0, _Num + _Off);
}
else
_Reverse(0, _Num);	
}
else
{	
try {
for (; _First != _Last; ++_First)
push_back((value_type)*_First);	
			} catch (...) {
for (; _Oldsize < _Mysize; )
pop_back();	
throw;
}
			if (_Off < _Oldsize)
{	
_Reverse(_Off, _Oldsize);
_Reverse(_Oldsize, _Mysize);
_Reverse(_Off, _Mysize);
}
}
}
	void _Reverse(size_type _First, size_type _Last)
{	
for (; _First != _Last && _First != --_Last; ++_First)
{	
iterator _Start = begin();
value_type _Temp = _Start[_First];
			_Start[_First] = _Start[_Last];
_Start[_Last] = _Temp;
}
}
	iterator erase(const_iterator _Where)
{	
return (erase(_Where, _Where + 1));
}
	iterator erase(const_iterator _First_arg,
const_iterator _Last_arg)
{	
iterator _First = _Make_iter(_First_arg);
iterator _Last = _Make_iter(_Last_arg);
 
		size_type _Off = _First - begin();
size_type _Count = _Last - _First;
		if (_Off < (size_type)(end() - _Last))
{	
std::copy_backward(begin(), _First, _Last);	
for (; 0 < _Count; --_Count)
pop_front();	
}
else
{	
std::copy(_Last, end(), _First);	
for (; 0 < _Count; --_Count)
pop_back();	
}
 
		return (begin() + _Off);
}
	void clear()
{	
_Tidy();
}
	void swap(_Myt& _Right)
{	
if (this == &_Right)
;	
else if (this->_Alval == _Right._Alval)
{	
 
			this->_Swap_aux(_Right);
			std::swap(_Map, _Right._Map);
std::swap(_Mapsize, _Right._Mapsize);
std::swap(_Myoff, _Right._Myoff);
std::swap(_Mysize, _Right._Mysize);
}
else
{	
this->_Swap_aux(_Right);
			_Myt _Ts = *this;
			*this = _Right;
_Right = _Ts;
}
}
protected:
void _Assign_n(size_type _Count, const _Ty& _Val)
{	
_Ty _Tmp = _Val;	
erase(begin(), end());
_Insert_n(begin(), _Count, _Tmp);
}
	void _Insert_n(const_iterator _Where,
size_type _Count, const _Ty& _Val)
{	
iterator _Mid;
size_type _Num;
size_type _Off = _Where - begin();
size_type _Rem = _Mysize - _Off;
size_type _Oldsize = _Mysize;
 
		if (_Off < _Rem)
{	
try {
if (_Off < _Count)
{	
for (_Num = _Count - _Off; 0 < _Num; --_Num)
push_front(_Val);	
for (_Num = _Off; 0 < _Num; --_Num)
push_front(begin()[_Count - 1]);	
				_Mid = begin() + _Count;
std::fill(_Mid, _Mid + _Off,
_Val);	
}
else
{	
for (_Num = _Count; 0 < _Num; --_Num)
push_front(begin()[_Count - 1]);	
				_Mid = begin() + _Count;
_Ty _Tmp = _Val;	
std::copy(_Mid + _Count, _Mid + _Off,
_Mid);	
std::fill(begin() + _Off, _Mid + _Off,
_Tmp);	
}
} catch (...) {
for (; _Oldsize < _Mysize; )
pop_front();	
throw;
}
}
else
{		
try {
if (_Rem < _Count)
{	
for (_Num = _Count - _Rem; 0 < _Num; --_Num)
push_back(_Val);	
for (_Num = 0; _Num < _Rem; ++_Num)
push_back(begin()[_Off + _Num]);	
				_Mid = begin() + _Off;
std::fill(_Mid, _Mid + _Rem,
_Val);	
}
else
{	
for (_Num = 0; _Num < _Count; ++_Num)
push_back(begin()[_Off + _Rem
- _Count + _Num]);	
				_Mid = begin() + _Off;
_Ty _Tmp = _Val;	
std::copy_backward(_Mid, _Mid + _Rem - _Count,
_Mid + _Rem);	
std::fill(_Mid, _Mid + _Count,
_Tmp);	
}
} catch (...) {
for (; _Oldsize < _Mysize; )
pop_back();	
throw;
}
}
}
	static void _Xlen()
{	
throw length_error("deque<T> too long");
}
	static void _Xinvarg()
{	
throw invalid_argument("invalid deque <T> argument");
}
	static void _Xran()
{	
throw out_of_range("invalid deque <T> subscript");
}
	void _Growmap(size_type _Count)
{	
if (max_size() / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) - _Mapsize < _Count)
_Xlen();	
		size_type _Inc = _Mapsize / 2;	
if (_Inc < 8)
_Inc = 8;
if (_Count < _Inc && _Mapsize <= max_size() / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1) - _Inc)
_Count = _Inc;
size_type _Myboff = _Myoff / (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1);
_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);
_Mapptr _Myptr = _Newmap + _Myboff;
		_Myptr = ::stdext:: unchecked_uninitialized_copy(_Map + _Myboff,
_Map + _Mapsize, _Myptr, this->_Almap);	
if (_Myboff <= _Count)
{	
_Myptr = ::stdext:: unchecked_uninitialized_copy(_Map,
_Map + _Myboff, _Myptr, this->_Almap);	
::stdext:: unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
(_Tptr)0, this->_Almap);	
::stdext:: unchecked_uninitialized_fill_n(_Newmap, _Myboff,
(_Tptr)0, this->_Almap);	
}
else
{	
::stdext:: unchecked_uninitialized_copy(_Map,
_Map + _Count, _Myptr, this->_Almap);	
_Myptr = ::stdext:: unchecked_uninitialized_copy(_Map + _Count,
_Map + _Myboff, _Newmap, this->_Almap);	
::stdext:: unchecked_uninitialized_fill_n(_Myptr, _Count,
(_Tptr)0, this->_Almap);	
}
		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
if (_Map)
this->_Almap.deallocate(_Map, _Mapsize);	
		_Map = _Newmap;	
_Mapsize += _Count;
}
	void _Tidy()
{	
while (!empty())
pop_back();
for (size_type _Count = _Mapsize; 0 < _Count; )
{	
if (*(_Map + --_Count) != 0)
this->_Alval.deallocate(*(_Map + _Count), (sizeof (_Ty) <= 1 ? 16 : sizeof (_Ty) <= 2 ? 8 : sizeof (_Ty) <= 4 ? 4 : sizeof (_Ty) <= 8 ? 2 : 1));
this->_Almap.destroy(_Map + _Count);
}
		if (_Map)
this->_Almap.deallocate(_Map, _Mapsize);	
_Mapsize = 0;
_Map = 0;
}
 
	_Mapptr _Map;	
size_type _Mapsize;	
size_type _Myoff;	
size_type _Mysize;	
};
	
template <class _Ty, class _Ax>
class _Move_operation_category<deque<_Ty, _Ax> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
	
template<class _Ty,
class _Alloc> inline
void swap(deque<_Ty, _Alloc>& _Left, deque<_Ty, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
template<class _Ty,
class _Alloc> inline
bool operator==(const deque<_Ty, _Alloc>& _Left,
const deque<_Ty, _Alloc>& _Right)
{	
return (_Left.size() == _Right.size()
&& equal(_Left.begin(), _Left.end(), _Right.begin()));
}
template<class _Ty,
class _Alloc> inline
bool operator!=(const deque<_Ty, _Alloc>& _Left,
const deque<_Ty, _Alloc>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty,
class _Alloc> inline
bool operator<(const deque<_Ty, _Alloc>& _Left,
const deque<_Ty, _Alloc>& _Right)
{	
return (lexicographical_compare(_Left.begin(), _Left.end(),
_Right.begin(), _Right.end()));
}
template<class _Ty,
class _Alloc> inline
bool operator<=(const deque<_Ty, _Alloc>& _Left,
const deque<_Ty, _Alloc>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty,
class _Alloc> inline
bool operator>(const deque<_Ty, _Alloc>& _Left,
const deque<_Ty, _Alloc>& _Right)
{	
return (_Right < _Left);
}
template<class _Ty,
class _Alloc> inline
bool operator>=(const deque<_Ty, _Alloc>& _Left,
const deque<_Ty, _Alloc>& _Right)
{	
return (!(_Left < _Right));
}
}
  #pragma warning(default:4284)
 
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4244)
namespace std {
		
const int _ISORT_MAX = 32;	
		
template<class _InIt,
class _Fn1> inline
_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
{	
;
;
typename ::std:: _Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkFirst(::std:: _Checked_base(_First));
typename ::std:: _Checked_iterator_base_helper<_InIt>::_Checked_iterator_base_type _ChkLast(::std:: _Checked_base(_Last));
for (; _ChkFirst != _ChkLast; ++_ChkFirst)
_Func(*_ChkFirst);
return (_Func);
}
		
template<class _InIt, class _Ty>
inline
_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
{	
;
for (; _First != _Last; ++_First)
if (*_First == _Val)
break;
return (_First);
}
inline const char *_Find(const char *_First, const char *_Last, int _Val)
{	
;
_First = (const char *)::memchr(_First, _Val, _Last - _First);
return (_First == 0 ? _Last : _First);
}
inline const signed char *_Find(const signed char *_First,
const signed char *_Last, int _Val)
{	
;
_First = (const signed char *)::memchr(_First, _Val,
_Last - _First);
return (_First == 0 ? _Last : _First);
}
inline const unsigned char *_Find(const unsigned char *_First,
const unsigned char *_Last, int _Val)
{	
;
_First = (const unsigned char *)::memchr(_First, _Val,
_Last - _First);
return (_First == 0 ? _Last : _First);
}
template<class _InIt, class _Ty>
inline
_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
{	
::std:: _Checked_assign_from_base(_First, _Find(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val));
return (_First);
}
		
template<class _InIt,
class _Pr> inline
_InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
{	
;
;
for (; _First != _Last; ++_First)
if (_Pred(*_First))
break;
return (_First);
}
template<class _InIt,
class _Pr> inline
_InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Find_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
return (_First);
}
		
template<class _FwdIt> inline
_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last)
{	
;
for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
if (*_Firstb == *_First)
return (_Firstb);
return (_Last);
}
template<class _FwdIt> inline
_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
{	
::std:: _Checked_assign_from_base(_First, _Adjacent_find(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
return (_First);
}
		
template<class _FwdIt,
class _Pr> inline
_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
;
;
for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
if (_Pred(*_Firstb, *_First))
return (_Firstb);
return (_Last);
}
template<class _FwdIt,
class _Pr> inline
_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Adjacent_find(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
return (_First);
}
		
template<class _InIt,
class _Ty> inline
typename iterator_traits<_InIt>::difference_type
_Count(_InIt _First, _InIt _Last, const _Ty& _Val)
{	
;
typename iterator_traits<_InIt>::difference_type _Cnt = 0;
	for (; _First != _Last; ++_First)
if (*_First == _Val)
++_Cnt;
return (_Cnt);
}
template<class _InIt,
class _Ty> inline
typename iterator_traits<_InIt>::difference_type
count(_InIt _First, _InIt _Last, const _Ty& _Val)
{	
return _Count(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val);
}
		
template<class _InIt,
class _Pr> inline
typename iterator_traits<_InIt>::difference_type
_Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
{	
;
;
typename iterator_traits<_InIt>::difference_type _Count = 0;
	for (; _First != _Last; ++_First)
if (_Pred(*_First))
++_Count;
return (_Count);
}
template<class _InIt,
class _Pr> inline
typename iterator_traits<_InIt>::difference_type
count_if(_InIt _First, _InIt _Last, _Pr _Pred)
{	
return _Count_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
}
		
template<class _FwdIt1,
class _FwdIt2,
class _Diff1,
class _Diff2> inline
_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
{	
;
;
_Diff1 _Count1 = 0;
_Distance(_First1, _Last1, _Count1);
_Diff2 _Count2 = 0;
_Distance(_First2, _Last2, _Count2);
	for (; _Count2 <= _Count1; ++_First1, --_Count1)
{	
_FwdIt1 _Mid1 = _First1;
for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
if (_Mid2 == _Last2)
return (_First1);
else if (!(*_Mid1 == *_Mid2))
break;
}
return (_Last1);
}
template<class _FwdIt1,
class _FwdIt2> inline
_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2)
{	
::std:: _Checked_assign_from_base(_First1, _Search(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
return _First1;
}
		
template<class _FwdIt1,
class _FwdIt2,
class _Diff1,
class _Diff2,
class _Pr> inline
_FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
{	
;
;
;
_Diff1 _Count1 = 0;
_Distance(_First1, _Last1, _Count1);
_Diff2 _Count2 = 0;
_Distance(_First2, _Last2, _Count2);
	for (; _Count2 <= _Count1; ++_First1, --_Count1)
{	
_FwdIt1 _Mid1 = _First1;
for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
if (_Mid2 == _Last2)
return (_First1);
else if (!_Pred(*_Mid1, *_Mid2))
break;
}
return (_Last1);
}
template<class _FwdIt1,
class _FwdIt2,
class _Pr> inline
_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First1, _Search(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
return _First1;
}
		
template<class _FwdIt1,
class _Diff2,
class _Ty> inline
_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
_Diff2 _Count, const _Ty& _Val, forward_iterator_tag)
{	
;
	if (_Count <= 0)
return (_First1);
	for (; _First1 != _Last1; ++_First1)
if (*_First1 == _Val)
{	
_FwdIt1 _Mid1  = _First1;
			for (_Diff2 _Count1 = _Count; ; )
if (--_Count1 == 0)
return (_First1);	
else if (++_Mid1 == _Last1)
return (_Last1);	
else if (!(*_Mid1 == _Val))
break;	
			_First1 = _Mid1;	
}
return (_Last1);
}
template<class _FwdIt1,
class _Diff2,
class _Ty> inline
_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
_Diff2 _Count, const _Ty& _Val, random_access_iterator_tag)
{	
;
	if (_Count <= 0)
return (_First1);
	_FwdIt1 _Oldfirst1 = _First1;
for (; _Count <= _Last1 - _Oldfirst1; )
{	
if (*_First1 == _Val)
{	
_Diff2 _Count1 = _Count;
_FwdIt1 _Mid1  = _First1;
			for (; _Oldfirst1 != _First1 && _First1[-1] == _Val; --_First1)
--_Count1;	
			if (_Count1 <= _Last1 - _Mid1)
for (; ; )	
if (--_Count1 == 0)
return (_First1);	
else if (!(*++_Mid1 == _Val))
break;	
			_Oldfirst1 = ++_Mid1;	
_First1 = _Oldfirst1;
}
else
{	
_Oldfirst1 = _First1 + 1;
_First1 += _Count;
}
}
return (_Last1);
}
template<class _FwdIt1,
class _Diff2,
class _Ty> inline
_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
_Diff2 _Count, const _Ty& _Val)
{	
::std:: _Checked_assign_from_base(_First1, _Search_n(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _Count, _Val, _Iter_cat(_First1)));
return _First1;
}
		
template<class _FwdIt1,
class _Diff2,
class _Ty,
class _Pr> inline
_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
_Diff2 _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
{	
;
;
	if (_Count <= 0)
return (_First1);
	for (; _First1 != _Last1; ++_First1)
if (_Pred(*_First1, _Val))
{	
_FwdIt1 _Mid1  = _First1;
			for (_Diff2 _Count1 = _Count; ; )
if (--_Count1 == 0)
return (_First1);	
else if (++_Mid1 == _Last1)
return (_Last1);	
else if (!_Pred(*_Mid1, _Val))
break;	
			_First1 = _Mid1;	
}
return (_Last1);
}
template<class _FwdIt1,
class _Diff2,
class _Ty,
class _Pr> inline
_FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
_Diff2 _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
{	
;
;
	if (_Count <= 0)
return (_First1);
	_FwdIt1 _Oldfirst1 = _First1;
for (; _Count <= _Last1 - _Oldfirst1; )
{	
if (_Pred(*_First1, _Val))
{	
_Diff2 _Count1 = _Count;
_FwdIt1 _Mid1  = _First1;
			for (; _Oldfirst1 != _First1 && _First1[-1] == _Val; --_First1)
--_Count1;	
			if (_Count1 <= _Last1 - _Mid1)
for (; ; )	
if (--_Count1 == 0)
return (_First1);	
else if (!_Pred(*++_Mid1, _Val))
break;	
			_Oldfirst1 = ++_Mid1;	
_First1 = _Oldfirst1;
}
else
{	
_Oldfirst1 = _First1 + 1;
_First1 += _Count;
}
}
return (_Last1);
}
template<class _FwdIt1,
class _Diff2,
class _Ty,
class _Pr> inline
_FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
_Diff2 _Count, const _Ty& _Val, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First1, _Search_n(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _Count, _Val, _Pred, _Iter_cat(_First1)));
return _First1;
}
		
template<class _FwdIt1,
class _FwdIt2,
class _Diff1,
class _Diff2> inline
_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Diff1 *, _Diff2 *)
{	
;
;
_Diff1 _Count1 = 0;
_Distance(_First1, _Last1, _Count1);
_Diff2 _Count2 = 0;
_Distance(_First2, _Last2, _Count2);
_FwdIt1 _Ans = _Last1;
	if (0 < _Count2)
for (; _Count2 <= _Count1; ++_First1, --_Count1)
{	
_FwdIt1 _Mid1 = _First1;
for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
if (!(*_Mid1 == *_Mid2))
break;
else if (++_Mid2 == _Last2)
{	
_Ans = _First1;
break;
}
}
return (_Ans);
}
template<class _FwdIt1,
class _FwdIt2> inline
_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2)
{	
::std:: _Checked_assign_from_base(_First1, _Find_end(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dist_type(_First1), _Dist_type(_First2)));
return _First1;
}
		
template<class _FwdIt1,
class _FwdIt2,
class _Diff1,
class _Diff2,
class _Pr> inline
_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
{	
;
;
;
_Diff1 _Count1 = 0;
_Distance(_First1, _Last1, _Count1);
_Diff2 _Count2 = 0;
_Distance(_First2, _Last2, _Count2);
_FwdIt1 _Ans = _Last1;
	if (0 < _Count2)
for (; _Count2 <= _Count1; ++_First1, --_Count1)
{	
_FwdIt1 _Mid1 = _First1;
for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
if (!_Pred(*_Mid1, *_Mid2))
break;
else if (++_Mid2 == _Last2)
{	
_Ans = _First1;
break;
}
}
return (_Ans);
}
template<class _FwdIt1,
class _FwdIt2,
class _Pr> inline
_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First1, _Find_end(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred, _Dist_type(_First1), _Dist_type(_First2)));
return _First1;
}
		
template<class _FwdIt1,
class _FwdIt2> inline
_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2)
{	
;
;
for (; _First1 != _Last1; ++_First1)
for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
if (*_First1 == *_Mid2)
return (_First1);
return (_First1);
}
template<class _FwdIt1,
class _FwdIt2> inline
_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2)
{	
;
;
::std:: _Checked_assign_from_base(_First1, _Find_first_of(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2)));
return _First1;
}
		
template<class _FwdIt1,
class _FwdIt2,
class _Pr> inline
_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
{	
;
for (; _First1 != _Last1; ++_First1)
for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
if (_Pred(*_First1, *_Mid2))
return (_First1);
return (_First1);
}
template<class _FwdIt1,
class _FwdIt2,
class _Pr> inline
_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First1, _Find_first_of(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred));
return (_First1);
}
		
template<class _FwdIt1,
class _FwdIt2> inline
void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
{	
std::swap(*_Left, *_Right);
}
		
template<class _FwdIt1, class _FwdIt2, class _FwdItCats>
inline
_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
_FwdItCats, _Range_checked_iterator_tag)
{	
;
for (; _First1 != _Last1; ++_First1, ++_First2)
std::iter_swap(_First1, _First2);
return (_First2);
}
template<class _FwdIt1, class _FwdIt2>
inline
_FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_FwdIt2 _Result = _First2 + (_Last1 - _First1);
_Swap_ranges(_First1, _Last1, ::std:: _Checked_base(_First2),
forward_iterator_tag(), _Range_checked_iterator_tag());
return (_Result);
}
template<class _FwdIt1, class _FwdIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
{
return _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt1, class _FwdElem2, size_t _Size>
inline
_FwdElem2* swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdElem2 (&_First2)[_Size])
{
return (swap_ranges(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size)).base());
}
template<class _FwdIt1, class _FwdIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
{
return _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
_Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt, class _OutIt, class _Fn1, class _InOutItCat>
inline
_OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func,
_InOutItCat, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Func(*_First);
return (_Dest);
}
template<class _InIt, class _OutIt, class _Fn1>
inline
_OutIt _Transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last - _First);
_Transform(_First, _Last, ::std:: _Checked_base(_Dest), _Func,
forward_iterator_tag(), _Range_checked_iterator_tag());
return (_Result);
}
template<class _InIt, class _OutIt, class _Fn1>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
{
return _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Fn1, size_t _Size>
inline
_OutElem* transform(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Fn1 _Func)
{
return (transform(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Func).base());
}
template<class _InIt, class _OutIt, class _Fn1>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
{
return _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats, class _InOutItCat>
inline
_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func,
_InItCats, _InOutItCat,
_Range_checked_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
*_Dest = _Func(*_First1, *_First2);
return (_Dest);
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func,
random_access_iterator_tag, random_access_iterator_tag,
_Range_checked_iterator_tag, _Range_checked_iterator_tag)
{	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
_OutIt _Result = _Dest + (_Last1 - _First1);
_Transform(_First1, _Last1, ::std:: _Checked_base(_First2),
::std:: _Checked_base(_Dest), _Func,
forward_iterator_tag(), forward_iterator_tag(),
_Range_checked_iterator_tag(), _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InOutItCat>
inline
_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func,
random_access_iterator_tag, _InOutItCat,
_Range_checked_iterator_tag, _Range_checked_iterator_tag)
{	
	_InIt2 _Last2 = _First2 + (_Last1 - _First1); (_Last2);
return _Transform(_First1, _Last1, ::std:: _Checked_base(_First2),
_Dest, _Func,
forward_iterator_tag(), forward_iterator_tag(),
_Range_checked_iterator_tag(), _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2, class _InItCats>
inline
_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func,
_InItCats, random_access_iterator_tag,
_Range_checked_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last1 - _First1);
_Transform(_First1, _Last1, _First2,
::std:: _Checked_base(_Dest), _Func,
forward_iterator_tag(), forward_iterator_tag(),
_Range_checked_iterator_tag(), _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result && ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func)
{
return _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
_Iter_random(_First1, _First2), _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InElem2, class _OutElem, class _Fn2, size_t _SizeFirst2, size_t _SizeDest>
inline
_OutElem* transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
{
return (transform(_First1, _Last1,
::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
::stdext:: make_checked_array_iterator(_Dest, _SizeDest),
_Func).base());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
{
return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
_Iter_random(_First1, _First2), _Iter_cat(_First1),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
{
return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
_Iter_random(_First1, _First2), _Iter_cat(_First1),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
}
template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
_OutIt _Dest, _Fn2 _Func)
{
return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
_Dest, _Func,
_Iter_cat(_First1), _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
_OutIt _Dest, _Fn2 _Func)
{
return (_Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
_Dest, _Func,
_Iter_cat(_First1), _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result || !::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func)
{
return _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
_Iter_random(_First1, _First2), _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt,
class _Ty> inline
void _Replace(_FwdIt _First, _FwdIt _Last,
const _Ty& _Oldval, const _Ty& _Newval)
{	
;
for (; _First != _Last; ++_First)
if (*_First == _Oldval)
*_First = _Newval;
}
template<class _FwdIt,
class _Ty> inline
void replace(_FwdIt _First, _FwdIt _Last,
const _Ty& _Oldval, const _Ty& _Newval)
{	
_Replace(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Oldval, _Newval);
}
		
template<class _FwdIt,
class _Pr,
class _Ty> inline
void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
{	
;
;
for (; _First != _Last; ++_First)
if (_Pred(*_First))
*_First = _Val;
}
template<class _FwdIt,
class _Pr,
class _Ty> inline
void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
{	
_Replace_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred, _Val);
}
		
template<class _InIt, class _OutIt, class _Ty, class _InOutItCat>
inline
_OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval,
_InOutItCat, _Range_checked_iterator_tag)
{	
;
;
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = *_First == _Oldval ? _Newval : *_First;
return (_Dest);
}
template<class _InIt, class _OutIt, class _Ty>
inline
_OutIt _Replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last - _First);
_Replace_copy(_First, _Last, ::std:: _Checked_base(_Dest),
_Oldval, _Newval,
forward_iterator_tag(), _Range_checked_iterator_tag());
return (_Result);
}
template<class _InIt,
class _OutIt,
class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval)
{	
return _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* replace_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
const _Ty& _Oldval, const _Ty& _Newval)
{	
return (replace_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size),
_Oldval, _Newval).base());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval)
{	
return _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt, class _OutIt, class _Pr, class _Ty, class _InOutItCat>
inline
_OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val, _InOutItCat, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First != _Last; ++_First, ++_Dest)
*_Dest = _Pred(*_First) ? _Val : *_First;
return (_Dest);
}
template<class _InIt, class _OutIt, class _Pr, class _Ty>
inline
_OutIt _Replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last - _First);
_Replace_copy_if(_First, _Last, ::std:: _Checked_base(_Dest),
_Pred, _Val,
forward_iterator_tag(), _Range_checked_iterator_tag());
return (_Result);
}
template<class _InIt,
class _OutIt,
class _Pr,
class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val)
{	
return _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Pr, class _Ty, size_t _Size>
inline
_OutElem* replace_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
_Pr _Pred, const _Ty& _Val)
{	
return (replace_copy_if(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size),
_Pred, _Val).base());
}
template<class _InIt,
class _OutIt,
class _Pr,
class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val)
{	
return _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
_Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt,
class _Fn0> inline
void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
{	
;
;
for (; _First != _Last; ++_First)
*_First = _Func();
}
template<class _FwdIt,
class _Fn0> inline
void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
{	
_Generate(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Func);
}
		
template<class _OutIt, class _Diff, class _Fn0, class _OutItCat>
inline
void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
_OutItCat, _Range_checked_iterator_tag)
{	
;
;
for (; 0 < _Count; --_Count, ++_Dest)
*_Dest = _Func();
}
template<class _OutIt, class _Diff, class _Fn0>
inline
void _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + _Count;
_Generate_n(::std:: _Checked_base(_Dest), _Count, _Func,
forward_iterator_tag(), _Range_checked_iterator_tag());
}
template<class _OutIt,
class _Diff,
class _Fn0> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
{	
_Generate_n(_Dest, _Count, _Func,
_Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _OutElem, class _Diff, class _Fn0, size_t _Size>
inline
void generate_n(_OutElem (&_Dest)[_Size], _Diff _Count, _Fn0 _Func)
{	
generate_n(::stdext:: make_checked_array_iterator(_Dest, _Size), _Count, _Func);
}
template<class _OutIt,
class _Diff,
class _Fn0> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
{	
_Generate_n(_Dest, _Count, _Func,
_Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt,
class _OutIt,
class _Ty> inline
_OutIt _Remove_copy(_InIt _First, _InIt _Last,
_OutIt _Dest, const _Ty& _Val, _Range_checked_iterator_tag)
{	
;
;
for (; _First != _Last; ++_First)
if (!(*_First == _Val))
*_Dest++ = *_First;
return (_Dest);
}
template<class _InIt,
class _OutIt,
class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy(_InIt _First, _InIt _Last,
_OutIt _Dest, const _Ty& _Val)
{	
return _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* remove_copy(_InIt _First, _InIt _Last,
_OutElem (&_Dest)[_Size], const _Ty& _Val)
{	
return (remove_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size),
_Val).base());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy(_InIt _First, _InIt _Last,
_OutIt _Dest, const _Ty& _Val)
{	
return _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt,
class _OutIt,
class _Pr> inline
_OutIt _Remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First != _Last; ++_First)
if (!_Pred(*_First))
*_Dest++ = *_First;
return (_Dest);
}
template<class _InIt,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* remove_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (remove_copy_if(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt,
class _Ty> inline
_FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{	
_First = find(_First, _Last, _Val);
if (_First == _Last)
return (_First);	
else
{	
_FwdIt _First1 = _First;
return (::stdext:: unchecked_remove_copy(++_First1, _Last, _First, _Val));
}
}
		
template<class _FwdIt,
class _Pr> inline
_FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
_First = std::find_if(_First, _Last, _Pred);
if (_First == _Last)
return (_First);	
else
{	
_FwdIt _First1 = _First;
return (::stdext:: unchecked_remove_copy_if(++_First1, _Last, _First, _Pred));
}
}
		
template<class _FwdIt> inline
_FwdIt _Unique(_FwdIt _First, _FwdIt _Last)
{	
;
for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
if (*_Firstb == *_First)
{	
for (; ++_First != _Last; )
if (!(*_Firstb == *_First))
*++_Firstb = *_First;
return (++_Firstb);
}
return (_Last);
}
template<class _FwdIt> inline
_FwdIt unique(_FwdIt _First, _FwdIt _Last)
{	
::std:: _Checked_assign_from_base(_Last, _Unique(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
return (_Last);
}
		
template<class _FwdIt,
class _Pr> inline
_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
;
;
for (_FwdIt _Firstb; (_Firstb = _First) != _Last && ++_First != _Last; )
if (_Pred(*_Firstb, *_First))
{	
for (; ++_First != _Last; )
if (!_Pred(*_Firstb, *_First))
*++_Firstb = *_First;
return (++_Firstb);
}
return (_Last);
}
template<class _FwdIt,
class _Pr> inline
_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_Last, _Unique(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
return (_Last);
}
		
template<class _InIt,
class _OutIt,
class _Ty> inline
_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Ty *, _Range_checked_iterator_tag)
{	
;
_Ty _Val = *_First;
	for (*_Dest++ = _Val; ++_First != _Last; )
if (!(_Val == *_First))
_Val = *_First, *_Dest++ = _Val;
return (_Dest);
}
template<class _InIt,
class _OutIt> inline
_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
input_iterator_tag, _Range_checked_iterator_tag)
{	
return (_Unique_copy(_First, _Last, _Dest, _Val_type(_First), _Range_checked_iterator_tag()));
}
template<class _FwdIt,
class _OutIt> inline
_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest,
forward_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
_FwdIt _Firstb = _First;
for (*_Dest++ = *_Firstb; ++_First != _Last; )
if (!(*_Firstb == *_First))
_Firstb = _First, *_Dest++ = *_Firstb;
return (_Dest);
}
template<class _BidIt,
class _OutIt> inline
_OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
bidirectional_iterator_tag, _Range_checked_iterator_tag)
{	
return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
}
template<class _RanIt,
class _OutIt> inline
_OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
return (_Unique_copy(_First, _Last, _Dest, forward_iterator_tag(), _Range_checked_iterator_tag()));
}
template<class _InIt,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_First == _Last ? _Dest :
_Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
{	
return (_First == _Last ? _Dest :
(unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base()));
}
template<class _InIt,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_First == _Last ? _Dest :
_Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
		
template<class _InIt,
class _OutIt,
class _Ty,
class _Pr> inline
_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
_Ty *, _Range_checked_iterator_tag)
{	
;
;
_Ty _Val = *_First;
	for (*_Dest++ = _Val; ++_First != _Last; )
if (!_Pred(_Val, *_First))
_Val = *_First, *_Dest++ = _Val;
return (_Dest);
}
template<class _InIt,
class _OutIt,
class _Pr> inline
_OutIt _Unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
input_iterator_tag, _Range_checked_iterator_tag)
{	
return (_Unique_copy(_First, _Last, _Dest, _Pred, _Val_type(_First), _Range_checked_iterator_tag()));
}
template<class _FwdIt,
class _OutIt,
class _Pr> inline
_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred,
forward_iterator_tag, _Range_checked_iterator_tag)
{	
;
;
;
_FwdIt _Firstb = _First;
	for (*_Dest++ = *_Firstb; ++_First != _Last; )
if (!_Pred(*_Firstb, *_First))
_Firstb = _First, *_Dest++ = *_Firstb;
return (_Dest);
}
template<class _BidIt,
class _OutIt,
class _Pr> inline
_OutIt _Unique_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest, _Pr _Pred,
bidirectional_iterator_tag, _Range_checked_iterator_tag)
{	
return (_Unique_copy(_First, _Last, _Dest, _Pred,
forward_iterator_tag(), _Range_checked_iterator_tag()));
}
template<class _RanIt,
class _OutIt,
class _Pr> inline
_OutIt _Unique_copy(_RanIt _First, _RanIt _Last, _OutIt _Dest, _Pr _Pred,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
return (_Unique_copy(_First, _Last, _Dest, _Pred,
forward_iterator_tag(), _Range_checked_iterator_tag()));
}
template<class _InIt,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return (_First == _Last ? _Dest
: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (_First == _Last ? _Dest
: (unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base()));
}
template<class _InIt,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return (_First == _Last ? _Dest
: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
		
template<class _BidIt> inline
void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
{	
for (; _First != _Last && _First != --_Last; ++_First)
std::iter_swap(_First, _Last);
}
template<class _RanIt> inline
void _Reverse(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
{	
;
for (; _First < _Last; ++_First)
std::iter_swap(_First, --_Last);
}
template<class _BidIt> inline
void reverse(_BidIt _First, _BidIt _Last)
{	
_Reverse(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Iter_cat(_First));
}
		
template<class _BidIt, class _OutIt, class _InOutItCat>
inline
_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_InOutItCat, _Range_checked_iterator_tag)
{	
;
;
for (; _First != _Last; ++_Dest)
*_Dest = *--_Last;
return (_Dest);
}
template<class _BidIt, class _OutIt>
inline
_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last - _First);
_Reverse_copy(_First, _Last, ::std:: _Checked_base(_Dest),
forward_iterator_tag(), _Range_checked_iterator_tag());
return (_Result);
}
template<class _BidIt,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
{	
return _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutElem, size_t _Size>
inline
_OutElem* reverse_copy(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size])
{	
return (reverse_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _BidIt,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
{	
return _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt> inline
void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
forward_iterator_tag)
{	
for (_FwdIt _Next = _Mid; ; )
{	
std::iter_swap(_First, _Next);
if (++_First == _Mid)
if (++_Next == _Last)
break;	
else
_Mid = _Next;	
else if (++_Next == _Last)
_Next = _Mid;	
}
}
template<class _BidIt> inline
void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
bidirectional_iterator_tag)
{	
std::reverse(_First, _Mid);
std::reverse(_Mid, _Last);
std::reverse(_First, _Last);
}
template<class _RanIt,
class _Diff,
class _Ty> inline
void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
{	
;
;
_Diff _Shift = _Mid - _First;
_Diff _Count = _Last - _First;
	for (_Diff _Factor = _Shift; _Factor != 0; )
{	
_Diff _Tmp = _Count % _Factor;
_Count = _Factor, _Factor = _Tmp;
}
	if (_Count < _Last - _First)
for (; 0 < _Count; --_Count)
{	
_RanIt _Hole = _First + _Count;
_RanIt _Next = _Hole;
_Ty _Holeval = *_Hole;
_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
while (_Next1 != _Hole)
{	
*_Next = *_Next1;
_Next = _Next1;
_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
: _First + (_Shift - (_Last - _Next1));
}
*_Next = _Holeval;
}
}
template<class _RanIt> inline
void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
random_access_iterator_tag)
{	
_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
}
template<class _FwdIt> inline
void rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
{	
if (_First != _Mid && _Mid != _Last)
_Rotate(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Iter_cat(_First));
}
		
template<class _FwdIt,
class _OutIt> inline
_OutIt _Rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest, _Range_checked_iterator_tag)
{	
_Dest = ::stdext:: unchecked_copy(_Mid, _Last, _Dest);
return (::stdext:: unchecked_copy(_First, _Mid, _Dest));
}
template<class _FwdIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
{
return _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt, class _OutElem, size_t _Size>
inline
_OutElem* rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutElem (&_Dest)[_Size])
{
return (rotate_copy(_First, _Mid, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _FwdIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
{
return _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
}
		
template<class _RanIt,
class _Diff> inline
void _Random_shuffle(_RanIt _First, _RanIt _Last, _Diff *)
{	
;
const int _RANDOM_BITS = 15;	
const int _RANDOM_MAX = (1U << _RANDOM_BITS) - 1;
	_RanIt _Next = _First;
for (unsigned long _Index = 2; ++_Next != _Last; ++_Index)
{	
unsigned long _Rm = _RANDOM_MAX;
unsigned long _Rn = ::rand() & _RANDOM_MAX;
for (; _Rm < _Index && _Rm != ~0UL;
_Rm = _Rm << _RANDOM_BITS | _RANDOM_MAX)
_Rn = _Rn << _RANDOM_BITS
| (::rand() & _RANDOM_MAX);	
		std::iter_swap(_Next, _First + _Diff(_Rn % _Index));	
}
}
template<class _RanIt> inline
void random_shuffle(_RanIt _First, _RanIt _Last)
{	
if (_First != _Last)
_Random_shuffle(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dist_type(_First));
}
		
template<class _RanIt,
class _Fn1,
class _Diff> inline
void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
{	
;
;
_RanIt _Next = _First;
	for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
std::iter_swap(_Next, _First + _Diff(_Func(_Index) % _Index));
}
template<class _RanIt,
class _Fn1> inline
void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func)
{	
if (_First != _Last)
_Random_shuffle(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Func, _Dist_type(_First));
}
		
template<class _BidIt,
class _Pr> inline
_BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
;
;
for (; ; ++_First)
{	
for (; _First != _Last && _Pred(*_First); ++_First)
;	
if (_First == _Last)
break;	
		for (; _First != --_Last && !_Pred(*_Last); )
;	
if (_First == _Last)
break;	
		std::iter_swap(_First, _Last);	
}
return (_First);
}
template<class _BidIt,
class _Pr> inline
_BidIt partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Partition(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
return (_First);
}
		
template<class _BidIt,
class _Pr,
class _Diff,
class _Ty> inline
_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
{	
if (_Count == 0)
return (_First);
else if (_Count == 1)
return (_Pred(*_First) ? _Last : _First);
else if (_Count <= _Tempbuf._Maxlen())
{	
_BidIt _Next = _First;
for (_Tempbuf._Init(); _First != _Last; ++_First)
if (_Pred(*_First))
*_Next++ = *_First;
else
*_Tempbuf++ = *_First;
		::stdext:: unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _Next);	
return (_Next);
}
else
{	
_BidIt _Mid = _First;
std::advance(_Mid, _Count / 2);
		_BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
_Count / 2, _Tempbuf);	
_BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
_Count - _Count / 2, _Tempbuf);	
		_Diff _Count1 = 0;
_Distance(_Left, _Mid, _Count1);
_Diff _Count2 = 0;
_Distance(_Mid, _Right, _Count2);
		return (_Buffered_rotate(_Left, _Mid, _Right,
_Count1, _Count2, _Tempbuf));	
}
}
template<class _BidIt,
class _Pr,
class _Diff,
class _Ty> inline
_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
_Diff *, _Ty *)
{	
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
_Temp_iterator<_Ty> _Tempbuf(_Count);
return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
}
template<class _BidIt,
class _Pr> inline
_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
if (_First != _Last)
{
::std:: _Checked_assign_from_base(_First, _Stable_partition(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred, _Dist_type(_First), _Val_type(_First)));
}
return _First;
}
 
 
 
 
		
template<class _RanIt,
class _Diff,
class _Ty> inline
void _Push_heap(_RanIt _First, _Diff _Hole,
_Diff _Top, _Ty _Val)
{	
for (_Diff _Idx = (_Hole - 1) / 2;
_Top < _Hole && ((*(_First + _Idx)) < (_Val));
_Idx = (_Hole - 1) / 2)
{	
*(_First + _Hole) = *(_First + _Idx);
_Hole = _Idx;
}
	*(_First + _Hole) = _Val;	
}
template<class _RanIt,
class _Diff,
class _Ty> inline
void _Push_heap_0(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
{	
_Diff _Count = _Last - _First;
if (0 < _Count)
std::_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last));
}
template<class _RanIt> inline
void push_heap(_RanIt _First, _RanIt _Last)
{	
;
if (_First != _Last)
{	
;
std::_Push_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(--_Last),
_Dist_type(_First), _Val_type(_First));
}
}
		
template<class _RanIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Push_heap(_RanIt _First, _Diff _Hole,
_Diff _Top, _Ty _Val, _Pr _Pred)
{	
for (_Diff _Idx = (_Hole - 1) / 2;
_Top < _Hole && _Pred(*(_First + _Idx), _Val);
_Idx = (_Hole - 1) / 2)
{	
*(_First + _Hole) = *(_First + _Idx);
_Hole = _Idx;
}
	*(_First + _Hole) = _Val;	
}
template<class _RanIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
{	
_Diff _Count = _Last - _First;
if (0 < _Count)
std::_Push_heap(_First, _Count, _Diff(0), _Ty(*_Last), _Pred);
}
template<class _RanIt,
class _Pr> inline
void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
{	
;
;
if (_First != _Last)
{	
;
std::_Push_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(--_Last), _Pred,
_Dist_type(_First), _Val_type(_First));
}
}
		
template<class _RanIt,
class _Diff,
class _Ty> inline
void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom, _Ty _Val)
{	
_Diff _Top = _Hole;
_Diff _Idx = 2 * _Hole + 2;
	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
{	
if (((*(_First + _Idx)) < (*(_First + (_Idx - 1)))))
--_Idx;
*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;
}
	if (_Idx == _Bottom)
{	
*(_First + _Hole) = *(_First + (_Bottom - 1));
_Hole = _Bottom - 1;
}
std::_Push_heap(_First, _Hole, _Top, _Val);
}
template<class _RanIt,
class _Diff,
class _Ty> inline
void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
_Ty _Val, _Diff *)
{	
*_Dest = *_First;
std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);
}
template<class _RanIt,
class _Ty> inline
void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Ty *)
{	
_Pop_heap(_First, _Last - 1, _Last - 1,
_Ty(*(_Last - 1)), _Dist_type(_First));
}
template<class _RanIt> inline
void pop_heap(_RanIt _First, _RanIt _Last)
{	
;
;
if (1 < _Last - _First)
_Pop_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val_type(_First));
}
		
template<class _RanIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
_Ty _Val, _Pr _Pred)
{	
_Diff _Top = _Hole;
_Diff _Idx = 2 * _Hole + 2;
	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
{	
if (_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))
--_Idx;
*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;
}
	if (_Idx == _Bottom)
{	
*(_First + _Hole) = *(_First + (_Bottom - 1));
_Hole = _Bottom - 1;
}
std::_Push_heap(_First, _Hole, _Top, _Val, _Pred);
}
template<class _RanIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
_Ty _Val, _Pr _Pred, _Diff *)
{	
*_Dest = *_First;
std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
_Val, _Pred);
}
template<class _RanIt,
class _Ty,
class _Pr> inline
void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
{	
_Pop_heap(_First, _Last - 1, _Last - 1,
_Ty(*(_Last - 1)), _Pred, _Dist_type(_First));
}
template<class _RanIt,
class _Pr> inline
void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
{	
;
;
;
if (1 < _Last - _First)
_Pop_heap_0(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred, _Val_type(_First));
}
		
template<class _RanIt,
class _Diff,
class _Ty> inline
void _Make_heap(_RanIt _First, _RanIt _Last, _Diff *, _Ty *)
{	
_Diff _Bottom = _Last - _First;
	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
{	
--_Hole;
std::_Adjust_heap(_First, _Hole, _Bottom,
_Ty(*(_First + _Hole)));
}
}
template<class _RanIt> inline
void make_heap(_RanIt _First, _RanIt _Last)
{	
;
if (1 < _Last - _First)
_Make_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
_Dist_type(_First), _Val_type(_First));
}
		
template<class _RanIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
{	
_Diff _Bottom = _Last - _First;
for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
{	
--_Hole;
std::_Adjust_heap(_First, _Hole, _Bottom,
_Ty(*(_First + _Hole)), _Pred);
}
}
template<class _RanIt,
class _Pr> inline
void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
{	
;
;
if (1 < _Last - _First)
_Make_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred,
_Dist_type(_First), _Val_type(_First));
}
		
template<class _RanIt> inline
void _Sort_heap(_RanIt _First, _RanIt _Last)
{	
;
;
for (; 1 < _Last - _First; --_Last)
std::pop_heap(_First, _Last);
}
template<class _RanIt> inline
void sort_heap(_RanIt _First, _RanIt _Last)
{	
;
_Sort_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last));
}
		
template<class _RanIt,
class _Pr> inline
void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
{	
for (; 1 < _Last - _First; --_Last)
std::pop_heap(_First, _Last, _Pred);
}
template<class _RanIt,
class _Pr> inline
void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
{	
;
;
;
_Sort_heap(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
}
		
template<class _FwdIt,
class _Ty,
class _Diff> inline
_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *)
{	
;
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
	for (; 0 < _Count; )
{	
_Diff _Count2 = _Count / 2;
_FwdIt _Mid = _First;
std::advance(_Mid, _Count2);
;
		if (((*_Mid) < (_Val)))
_First = ++_Mid, _Count -= _Count2 + 1;
else
_Count = _Count2;
}
return (_First);
}
template<class _FwdIt,
class _Ty> inline
_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{	
::std:: _Checked_assign_from_base(_First, _Lower_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Dist_type(_First)));
return _First;
}
		
template<class _FwdIt,
class _Ty,
class _Diff,
class _Pr> inline
_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred, _Diff *)
{	
;
;
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
for (; 0 < _Count; )
{	
_Diff _Count2 = _Count / 2;
_FwdIt _Mid = _First;
std::advance(_Mid, _Count2);
;
		if (_Pred(*_Mid, _Val))
_First = ++_Mid, _Count -= _Count2 + 1;
else
_Count = _Count2;
}
return (_First);
}
template<class _FwdIt,
class _Ty,
class _Pr> inline
_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Lower_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
return _First;
}
		
template<class _FwdIt,
class _Ty,
class _Diff> inline
_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Diff *)
{	
;
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
for (; 0 < _Count; )
{	
_Diff _Count2 = _Count / 2;
_FwdIt _Mid = _First;
std::advance(_Mid, _Count2);
;
		if (!((_Val) < (*_Mid)))
_First = ++_Mid, _Count -= _Count2 + 1;
else
_Count = _Count2;
}
return (_First);
}
template<class _FwdIt,
class _Ty> inline
_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{	
::std:: _Checked_assign_from_base(_First, _Upper_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Dist_type(_First)));
return _First;
}
		
template<class _FwdIt,
class _Ty,
class _Diff,
class _Pr> inline
_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred, _Diff *)
{	
;
;
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
for (; 0 < _Count; )
{	
_Diff _Count2 = _Count / 2;
_FwdIt _Mid = _First;
std::advance(_Mid, _Count2);
;
		if (!_Pred(_Val, *_Mid))
_First = ++_Mid, _Count -= _Count2 + 1;
else
_Count = _Count2;
}
return (_First);
}
template<class _FwdIt,
class _Ty,
class _Pr> inline
_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Upper_bound(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Val, _Pred, _Dist_type(_First)));
return _First;
}
		
template<class _FwdIt,
class _Ty,
class _Diff> inline
pair<_FwdIt, _FwdIt> _Equal_range(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Diff *)
{	
;
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
	for (; 0 < _Count; )
{	
_Diff _Count2 = _Count / 2;
_FwdIt _Mid = _First;
std::advance(_Mid, _Count2);
;
		if (((*_Mid) < (_Val)))
{	
_First = ++_Mid;
_Count -= _Count2 + 1;
}
else if (_Val < *_Mid)
_Count = _Count2;	
else
{	
_FwdIt _First2 = lower_bound(_First, _Mid, _Val);
std::advance(_First, _Count);
_FwdIt _Last2 = upper_bound(++_Mid, _First, _Val);
return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
}
}
	return (pair<_FwdIt, _FwdIt>(_First, _First));	
}
template<class _FwdIt,
class _Ty> inline
pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val)
{	
return (_Equal_range(_First, _Last, _Val, _Dist_type(_First)));
}
		
template<class _FwdIt,
class _Ty,
class _Diff,
class _Pr> inline
pair<_FwdIt, _FwdIt> _Equal_range(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred, _Diff *)
{	
;
;
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
	for (; 0 < _Count; )
{	
_Diff _Count2 = _Count / 2;
_FwdIt _Mid = _First;
std::advance(_Mid, _Count2);
;
		if (_Pred(*_Mid, _Val))
{	
_First = ++_Mid;
_Count -= _Count2 + 1;
}
else if (_Pred(_Val, *_Mid))
_Count = _Count2;	
else
{	
_FwdIt _First2 = lower_bound(_First, _Mid, _Val, _Pred);
std::advance(_First, _Count);
_FwdIt _Last2 = upper_bound(++_Mid, _First, _Val, _Pred);
return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
}
}
	return (pair<_FwdIt, _FwdIt>(_First, _First));	
}
template<class _FwdIt,
class _Ty,
class _Pr> inline
pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred)
{	
return (_Equal_range(_First, _Last, _Val, _Pred, _Dist_type(_First)));
}
		
template<class _FwdIt,
class _Ty> inline
bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
{	
_First = std::lower_bound(_First, _Last, _Val);
return (_First != _Last && !(_Val < *_First));
}
		
template<class _FwdIt,
class _Ty,
class _Pr> inline
bool binary_search(_FwdIt _First, _FwdIt _Last,
const _Ty& _Val, _Pr _Pred)
{	
_First = std::lower_bound(_First, _Last, _Val, _Pred);
return (_First != _Last && !_Pred(_Val, *_First));
}
		
template<class _InIt1, class _InIt2, class _OutIt, class _InOutItCat>
inline
_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
_InOutItCat, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
if (((*_First2) < (*_First1)))
*_Dest = *_First2, ++_First2;
else
*_Dest = *_First1, ++_First1;
	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);	
return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
}
template<class _InIt1, class _InIt2, class _OutIt>
inline
_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last1 - _First1) + (_Last2 - _First2);
_Merge(_First1, _Last1, _First2, _Last2, ::std:: _Checked_base(_Dest),
forward_iterator_tag(), _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (merge(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1, class _InIt2, class _OutIt, class _Pr, class _InOutItCat>
inline
_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred,
_InOutItCat, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)
if (_Pred(*_First2, *_First1))
*_Dest = *_First2, ++_First2;
else
*_Dest = *_First1, ++_First1;
	_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);	
return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
}
template<class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline
_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred,
random_access_iterator_tag, _Range_checked_iterator_tag)
{	
	_OutIt _Result = _Dest + (_Last1 - _First1) + (_Last2 - _First2);
_Merge(_First1, _Last1, _First2, _Last2, ::std:: _Checked_base(_Dest), _Pred, 
forward_iterator_tag(), _Range_checked_iterator_tag());
return _Result;
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred,
_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (merge(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred,
_Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
		
template<class _BidIt,
class _Diff,
class _Ty> inline
_BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
{	
if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
{	
::stdext:: unchecked_copy(_First, _Mid, _Tempbuf._Init());
::stdext:: unchecked_copy(_Mid, _Last, _First);
return (::stdext:: unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
_Last));
}
else if (_Count2 <= _Tempbuf._Maxlen())
{	
::stdext:: unchecked_copy(_Mid, _Last, _Tempbuf._Init());
::stdext:: unchecked_copy_backward(_First, _Mid, _Last);
return (::stdext:: unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));
}
else
{	
std::rotate(_First, _Mid, _Last);
std::advance(_First, _Count2);
return (_First);
}
}
template<class _BidIt1,
class _BidIt2,
class _BidIt3> inline
_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Range_checked_iterator_tag)
{	
for (; ; )
if (_First1 == _Last1)
return (::stdext:: unchecked_copy_backward(_First2, _Last2, _Dest));
else if (_First2 == _Last2)
return (::stdext:: unchecked_copy_backward(_First1, _Last1, _Dest));
else if (((*--_Last2) < (*--_Last1)))
*--_Dest = *_Last1, ++_Last2;
else
*--_Dest = *_Last2, ++_Last1;
}
template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
{
return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
{
return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt,
class _Diff,
class _Ty> inline
void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
_Diff _Count1, _Diff _Count2,
_Temp_iterator<_Ty>& _Tempbuf)
{	
if (_Count1 + _Count2 == 2)
{	
if (((*_Mid) < (*_First)))
std::iter_swap(_First, _Mid);
}
else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
{	
::stdext:: unchecked_copy(_First, _Mid, _Tempbuf._Init());
::stdext:: unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);
}
else if (_Count2 <= _Tempbuf._Maxlen())
{	
::stdext:: unchecked_copy(_Mid, _Last, _Tempbuf._Init());
::stdext:: _Unchecked_merge_backward(_First, _Mid,
_Tempbuf._First(), _Tempbuf._Last(), _Last);
}
else
{	
_BidIt _Firstn, _Lastn;
_Diff _Count1n, _Count2n;
		if (_Count2 < _Count1)
{	
_Count1n = _Count1 / 2, _Count2n = 0;
_Firstn = _First;
std::advance(_Firstn, _Count1n);
_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);
_Distance(_Mid, _Lastn, _Count2n);
}
else
{	
_Count1n = 0, _Count2n = _Count2 / 2;
_Lastn = _Mid;
std::advance(_Lastn, _Count2n);
_Firstn = std::upper_bound(_First, _Mid, *_Lastn);
_Distance(_First, _Firstn, _Count1n);
}
		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
_Count1 - _Count1n, _Count2n, _Tempbuf);	
_Buffered_merge(_First, _Firstn, _Midn,
_Count1n, _Count2n, _Tempbuf);	
_Buffered_merge(_Midn, _Lastn, _Last,
_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);
}
}
template<class _BidIt,
class _Diff,
class _Ty> inline
void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
_Diff *, _Ty *)
{	
;
;
_Diff _Count1 = 0;
_Distance(_First, _Mid, _Count1);
_Diff _Count2 = 0;
_Distance(_Mid, _Last, _Count2);
_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
_Buffered_merge(_First, _Mid, _Last,
_Count1, _Count2, _Tempbuf);
}
template<class _BidIt> inline
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
{	
if (_First != _Mid && _Mid != _Last)
_Inplace_merge(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last),
_Dist_type(_First), _Val_type(_First));
}
		
template<class _BidIt1,
class _BidIt2,
class _BidIt3,
class _Pr> inline
_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred, _Range_checked_iterator_tag)
{	
for (; ; )
if (_First1 == _Last1)
return (::stdext:: unchecked_copy_backward(_First2, _Last2, _Dest));
else if (_First2 == _Last2)
return (::stdext:: unchecked_copy_backward(_First1, _Last1, _Dest));
else if (_Pred(*--_Last2, *--_Last1))
*--_Dest = *_Last1, ++_Last2;
else
*--_Dest = *_Last2, ++_Last1;
}
template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
{
return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
{
return _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
_Diff _Count1, _Diff _Count2,
_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
{	
if (_Count1 + _Count2 == 2)
{	
if (_Pred(*_Mid, *_First))
std::iter_swap(_First, _Mid);
}
else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
{	
::stdext:: unchecked_copy(_First, _Mid, _Tempbuf._Init());
::stdext:: unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
_Mid, _Last, _First, _Pred);
}
else if (_Count2 <= _Tempbuf._Maxlen())
{	
::stdext:: unchecked_copy(_Mid, _Last, _Tempbuf._Init());
::stdext:: _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
_Last, _Pred);
}
else
{	
_BidIt _Firstn, _Lastn;
_Diff _Count1n, _Count2n;
if (_Count2 < _Count1)
{	
_Count1n = _Count1 / 2, _Count2n = 0;
_Firstn = _First;
std::advance(_Firstn, _Count1n);
_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);
_Distance(_Mid, _Lastn, _Count2n);
}
else
{	
_Count1n = 0, _Count2n = _Count2 / 2;
_Lastn = _Mid;
std::advance(_Lastn, _Count2n);
_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);
_Distance(_First, _Firstn, _Count1n);
}
_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
_Count1 - _Count1n, _Count2n, _Tempbuf);	
_Buffered_merge(_First, _Firstn, _Midn,
_Count1n, _Count2n, _Tempbuf, _Pred);	
_Buffered_merge(_Midn, _Lastn, _Last,
_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
}
}
template<class _BidIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
_Diff *, _Ty *)
{	
;
;
_Diff _Count1 = 0;
_Distance(_First, _Mid, _Count1);
_Diff _Count2 = 0;
_Distance(_Mid, _Last, _Count2);
_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
_Buffered_merge(_First, _Mid, _Last,
_Count1, _Count2, _Tempbuf, _Pred);
}
template<class _BidIt,
class _Pr> inline
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
{	
if (_First != _Mid && _Mid != _Last)
_Inplace_merge(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Pred,
_Dist_type(_First), _Val_type(_First));
}
		
template<class _BidIt,
class _Ty> inline
void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Ty *)
{	
if (_First != _Last)
for (_BidIt _Next = _First; ++_Next != _Last; )
{	
_BidIt _Next1 = _Next;
_Ty _Val = *_Next;
			if (((_Val) < (*_First)))
{	
::stdext:: unchecked_copy_backward(_First, _Next, ++_Next1);
*_First = _Val;
}
else
{	
for (_BidIt _First1 = _Next1;
((_Val) < (*--_First1));
_Next1 = _First1)
*_Next1 = *_First1;	
*_Next1 = _Val;	
}
}
}
template<class _BidIt> inline
void _Insertion_sort(_BidIt _First, _BidIt _Last)
{	
std::_Insertion_sort1(_First, _Last, _Val_type(_First));
}
template<class _RanIt> inline
void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last)
{	
if (((*_Mid) < (*_First)))
std::iter_swap(_Mid, _First);
if (((*_Last) < (*_Mid)))
std::iter_swap(_Last, _Mid);
if (((*_Mid) < (*_First)))
std::iter_swap(_Mid, _First);
}
template<class _RanIt> inline
void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last)
{	
if (40 < _Last - _First)
{	
size_t _Step = (_Last - _First + 1) / 8;
std::_Med3(_First, _First + _Step, _First + 2 * _Step);
std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);
std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);
std::_Med3(_First + _Step, _Mid, _Last - _Step);
}
else
std::_Med3(_First, _Mid, _Last);
}
template<class _RanIt> inline
pair<_RanIt, _RanIt> _Unguarded_partition(_RanIt _First, _RanIt _Last)
{	
_RanIt _Mid = _First + (_Last - _First) / 2;	
std::_Median(_First, _Mid, _Last - 1);
_RanIt _Pfirst = _Mid;
_RanIt _Plast = _Pfirst + 1;
	while (_First < _Pfirst
&& !((*(_Pfirst - 1)) < (*_Pfirst))
&& !(*_Pfirst < *(_Pfirst - 1)))
--_Pfirst;
while (_Plast < _Last
&& !((*_Plast) < (*_Pfirst))
&& !(*_Pfirst < *_Plast))
++_Plast;
	_RanIt _Gfirst = _Plast;
_RanIt _Glast = _Pfirst;
	for (; ; )
{	
for (; _Gfirst < _Last; ++_Gfirst)
if (((*_Pfirst) < (*_Gfirst)))
;
else if (*_Gfirst < *_Pfirst)
break;
else
std::iter_swap(_Plast++, _Gfirst);
for (; _First < _Glast; --_Glast)
if (((*(_Glast - 1)) < (*_Pfirst)))
;
else if (*_Pfirst < *(_Glast - 1))
break;
else
std::iter_swap(--_Pfirst, _Glast - 1);
if (_Glast == _First && _Gfirst == _Last)
return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
		if (_Glast == _First)
{	
if (_Plast != _Gfirst)
std::iter_swap(_Pfirst, _Plast);
++_Plast;
std::iter_swap(_Pfirst++, _Gfirst++);
}
else if (_Gfirst == _Last)
{	
if (--_Glast != --_Pfirst)
std::iter_swap(_Glast, _Pfirst);
std::iter_swap(_Pfirst, --_Plast);
}
else
std::iter_swap(_Gfirst++, --_Glast);
}
}
template<class _RanIt,
class _Diff> inline
void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal)
{	
_Diff _Count;
for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
{	
pair<_RanIt, _RanIt> _Mid =
std::_Unguarded_partition(_First, _Last);
_Ideal /= 2, _Ideal += _Ideal / 2;	
		if (_Mid.first - _First < _Last - _Mid.second)
{	
std::_Sort(_First, _Mid.first, _Ideal);
_First = _Mid.second;
}
else
{	
std::_Sort(_Mid.second, _Last, _Ideal);
_Last = _Mid.first;
}
}
	if (_ISORT_MAX < _Count)
{	
std::make_heap(_First, _Last);
std::sort_heap(_First, _Last);
}
else if (1 < _Count)
std::_Insertion_sort(_First, _Last);	
}
template<class _RanIt> inline
void sort(_RanIt _First, _RanIt _Last)
{	
;
std::_Sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Last - _First);
}
		
template<class _BidIt,
class _Pr,
class _Ty> inline
void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
{	
if (_First != _Last)
for (_BidIt _Next = _First; ++_Next != _Last; )
{	
_BidIt _Next1 = _Next;
_Ty _Val = *_Next;
			if (_Pred(_Val, *_First))
{	
::stdext:: unchecked_copy_backward(_First, _Next, ++_Next1);
*_First = _Val;
}
else
{	
for (_BidIt _First1 = _Next1;
_Pred(_Val, *--_First1);
_Next1 = _First1)
*_Next1 = *_First1;	
*_Next1 = _Val;	
}
}
}
template<class _BidIt,
class _Pr> inline
void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
std::_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));
}
template<class _RanIt,
class _Pr> inline
void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
{	
if (_Pred(*_Mid, *_First))
std::iter_swap(_Mid, _First);
if (_Pred(*_Last, *_Mid))
std::iter_swap(_Last, _Mid);
if (_Pred(*_Mid, *_First))
std::iter_swap(_Mid, _First);
}
template<class _RanIt,
class _Pr> inline
void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
{	
if (40 < _Last - _First)
{	
size_t _Step = (_Last - _First + 1) / 8;
std::_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
std::_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
std::_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
}
else
std::_Med3(_First, _Mid, _Last, _Pred);
}
template<class _RanIt,
class _Pr> inline
pair<_RanIt, _RanIt> _Unguarded_partition(_RanIt _First, _RanIt _Last,
_Pr _Pred)
{	
_RanIt _Mid = _First + (_Last - _First) / 2;
std::_Median(_First, _Mid, _Last - 1, _Pred);
_RanIt _Pfirst = _Mid;
_RanIt _Plast = _Pfirst + 1;
	while (_First < _Pfirst
&& !_Pred(*(_Pfirst - 1), *_Pfirst)
&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
--_Pfirst;
while (_Plast < _Last
&& !_Pred(*_Plast, *_Pfirst)
&& !_Pred(*_Pfirst, *_Plast))
++_Plast;
	_RanIt _Gfirst = _Plast;
_RanIt _Glast = _Pfirst;
	for (; ; )
{	
for (; _Gfirst < _Last; ++_Gfirst)
if (_Pred(*_Pfirst, *_Gfirst))
;
else if (_Pred(*_Gfirst, *_Pfirst))
break;
else
std::iter_swap(_Plast++, _Gfirst);
for (; _First < _Glast; --_Glast)
if (_Pred(*(_Glast - 1), *_Pfirst))
;
else if (_Pred(*_Pfirst, *(_Glast - 1)))
break;
else
std::iter_swap(--_Pfirst, _Glast - 1);
if (_Glast == _First && _Gfirst == _Last)
return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));
		if (_Glast == _First)
{	
if (_Plast != _Gfirst)
std::iter_swap(_Pfirst, _Plast);
++_Plast;
std::iter_swap(_Pfirst++, _Gfirst++);
}
else if (_Gfirst == _Last)
{	
if (--_Glast != --_Pfirst)
std::iter_swap(_Glast, _Pfirst);
std::iter_swap(_Pfirst, --_Plast);
}
else
std::iter_swap(_Gfirst++, --_Glast);
}
}
template<class _RanIt,
class _Diff,
class _Pr> inline
void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
{	
_Diff _Count;
for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
{	
pair<_RanIt, _RanIt> _Mid =
std::_Unguarded_partition(_First, _Last, _Pred);
_Ideal /= 2, _Ideal += _Ideal / 2;	
		if (_Mid.first - _First < _Last - _Mid.second)
{	
std::_Sort(_First, _Mid.first, _Ideal, _Pred);
_First = _Mid.second;
}
else
{	
std::_Sort(_Mid.second, _Last, _Ideal, _Pred);
_Last = _Mid.first;
}
}
	if (_ISORT_MAX < _Count)
{	
std::make_heap(_First, _Last, _Pred);
std::sort_heap(_First, _Last, _Pred);
}
else if (1 < _Count)
std::_Insertion_sort(_First, _Last, _Pred);	
}
template<class _RanIt,
class _Pr> inline
void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
{	
;
;
std::_Sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Last - _First, _Pred);
}
		
template<class _BidIt,
class _OutIt,
class _Diff> inline
void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Range_checked_iterator_tag)
{	
for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
{	
_BidIt _Mid1 = _First;
std::advance(_Mid1, _Chunk);
_BidIt _Mid2 = _Mid1;
std::advance(_Mid2, _Chunk);
		_Dest = ::stdext:: unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);
_First = _Mid2;
}
	if (_Count <= _Chunk)
::stdext:: unchecked_copy(_First, _Last, _Dest);	
else
{	
_BidIt _Mid = _First;
std::advance(_Mid, _Chunk);
		::stdext:: unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);
}
}
template<class _BidIt, class _OutIt, class _Diff>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count)
{
_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutElem, class _Diff, size_t _Size>
inline
void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
_Diff _Chunk, _Diff _Count)
{
_Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count)
{
_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt,
class _Diff,
class _Ty> inline
void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
_Temp_iterator<_Ty>& _Tempbuf)
{	
_BidIt _Mid = _First;
for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
{	
_BidIt _Midend = _Mid;
std::advance(_Midend, (int)_ISORT_MAX);
		std::_Insertion_sort(_Mid, _Midend);
_Mid = _Midend;
}
std::_Insertion_sort(_Mid, _Last);	
	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
{	
::stdext:: _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
_Chunk, _Count);
::stdext:: _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
_Chunk *= 2, _Count);
}
}
template<class _BidIt,
class _Diff,
class _Ty> inline
void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
_Temp_iterator<_Ty>& _Tempbuf)
{	
if (_Count <= _ISORT_MAX)
std::_Insertion_sort(_First, _Last);	
else
{	
_Diff _Count2 = (_Count + 1) / 2;
_BidIt _Mid = _First;
std::advance(_Mid, _Count2);
		if (_Count2 <= _Tempbuf._Maxlen())
{	
_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);
_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
}
else
{	
_Stable_sort(_First, _Mid, _Count2, _Tempbuf);
_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);
}
		_Buffered_merge(_First, _Mid, _Last,
_Count2, _Count - _Count2, _Tempbuf);	
}
}
template<class _BidIt,
class _Diff,
class _Ty> inline
void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *)
{	
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
_Stable_sort(_First, _Last, _Count, _Tempbuf);
}
template<class _BidIt> inline
void stable_sort(_BidIt _First, _BidIt _Last)
{	
;
if (_First != _Last)
{
_Stable_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dist_type(_First), _Val_type(_First));
}
}
		
template<class _BidIt,
class _OutIt,
class _Diff,
class _Pr> inline
void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Pr _Pred, _Range_checked_iterator_tag)
{	
for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
{	
_BidIt _Mid1 = _First;
std::advance(_Mid1, _Chunk);
_BidIt _Mid2 = _Mid1;
std::advance(_Mid2, _Chunk);
		_Dest = ::stdext:: unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
_First = _Mid2;
}
	if (_Count <= _Chunk)
::stdext:: unchecked_copy(_First, _Last, _Dest);	
else
{	
_BidIt _Mid1 = _First;
std::advance(_Mid1, _Chunk);
		::stdext:: unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
}
}
template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutElem, class _Diff, class _Pr, size_t _Size>
inline
void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
_Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
_Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
{	
_BidIt _Mid = _First;
for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
{	
_BidIt _Midn = _Mid;
std::advance(_Midn, (int)_ISORT_MAX);
		std::_Insertion_sort(_Mid, _Midn, _Pred);
_Mid = _Midn;
}
std::_Insertion_sort(_Mid, _Last, _Pred);	
	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
{	
::stdext:: _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
_Chunk, _Count, _Pred);
::stdext:: _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
_Chunk *= 2, _Count, _Pred);
}
}
template<class _BidIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
{	
if (_Count <= _ISORT_MAX)
std::_Insertion_sort(_First, _Last, _Pred);	
else
{	
_Diff _Count2 = (_Count + 1) / 2;
_BidIt _Mid = _First;
std::advance(_Mid, _Count2);
		if (_Count2 <= _Tempbuf._Maxlen())
{	
_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
_Tempbuf, _Pred);
}
else
{	
_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
}
		_Buffered_merge(_First, _Mid, _Last,
_Count2, _Count - _Count2, _Tempbuf, _Pred);	
}
}
template<class _BidIt,
class _Diff,
class _Ty,
class _Pr> inline
void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
{	
_Diff _Count = 0;
_Distance(_First, _Last, _Count);
_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
}
template<class _BidIt,
class _Pr> inline
void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
;
;
if (_First != _Last)
{
_Stable_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last),
_Dist_type(_First), _Val_type(_First), _Pred);
}
}
		
template<class _RanIt,
class _Ty> inline
void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Ty *)
{	
;
;
std::make_heap(_First, _Mid);
	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
if (((*_Next) < (*_First)))
_Pop_heap(_First, _Mid, _Next, _Ty(*_Next),
_Dist_type(_First));	
std::sort_heap(_First, _Mid);
}
template<class _RanIt> inline
void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
{	
_Partial_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Val_type(_First));
}
		
template<class _RanIt,
class _Ty,
class _Pr> inline
void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
_Pr _Pred, _Ty *)
{	
;
;
;
std::make_heap(_First, _Mid, _Pred);
	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
if (_Pred(*_Next, *_First))
_Pop_heap(_First, _Mid, _Next, _Ty(*_Next), _Pred,
_Dist_type(_First));	
std::sort_heap(_First, _Mid, _Pred);
}
template<class _RanIt,
class _Pr> inline
void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
{	
_Partial_sort(::std:: _Checked_base(_First), ::std:: _Checked_base(_Mid), ::std:: _Checked_base(_Last), _Pred, _Val_type(_First));
}
		
template<class _InIt,
class _RanIt,
class _Diff,
class _Ty> inline
_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
_RanIt _First2, _RanIt _Last2, _Diff *, _Ty *)
{	
;
;
_RanIt _Mid2 = _First2;
for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
*_Mid2 = *_First1;	
std::make_heap(_First2, _Mid2);
	for (; _First1 != _Last1; ++_First1)
if (((*_First1) < (*_First2)))
std::_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
_Ty(*_First1));	
	std::sort_heap(_First2, _Mid2);
return (_Mid2);
}
template<class _InIt,
class _RanIt> inline
_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
_RanIt _First2, _RanIt _Last2)
{	
if (_First1 != _Last1 && _First2 != _Last2)
::std:: _Checked_assign_from_base(_First2, _Partial_sort_copy(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dist_type(_First2), _Val_type(_First1)));
return (_First2);
}
		
template<class _InIt,
class _RanIt,
class _Diff,
class _Ty,
class _Pr> inline
_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
_RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
{	
;
;
;
_RanIt _Mid2 = _First2;
for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
*_Mid2 = *_First1;	
std::make_heap(_First2, _Mid2, _Pred);
	for (; _First1 != _Last1; ++_First1)
if (_Pred(*_First1, *_First2))
std::_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
_Ty(*_First1), _Pred);	
	std::sort_heap(_First2, _Mid2, _Pred);
return (_Mid2);
}
template<class _InIt,
class _RanIt,
class _Pr> inline
_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
_RanIt _First2, _RanIt _Last2, _Pr _Pred)
{	
if (_First1 != _Last1 && _First2 != _Last2)
::std:: _Checked_assign_from_base(_First2, _Partial_sort_copy(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred, _Dist_type(_First2), _Val_type(_First1)));
return (_First2);
}
		
template<class _RanIt> inline
void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
{	
;
for (; _ISORT_MAX < _Last - _First; )
{	
pair<_RanIt, _RanIt> _Mid =
std::_Unguarded_partition(_First, _Last);
		if (_Mid.second <= _Nth)
_First = _Mid.second;
else if (_Mid.first <= _Nth)
return;	
else
_Last = _Mid.first;
}
	std::_Insertion_sort(_First, _Last);	
}
template<class _RanIt> inline
void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
{	
_Nth_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Nth), ::std:: _Checked_base(_Last));
}
		
template<class _RanIt,
class _Pr> inline
void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
{	
;
;
for (; _ISORT_MAX < _Last - _First; )
{	
pair<_RanIt, _RanIt> _Mid =
std::_Unguarded_partition(_First, _Last, _Pred);
		if (_Mid.second <= _Nth)
_First = _Mid.second;
else if (_Mid.first <= _Nth)
return;	
else
_Last = _Mid.first;
}
	std::_Insertion_sort(_First, _Last, _Pred);	
}
template<class _RanIt,
class _Pr> inline
void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
{	
_Nth_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Nth), ::std:: _Checked_base(_Last), _Pred);
}
		
template<class _InIt1,
class _InIt2> inline
bool _Includes(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2)
{	
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (((*_First2) < (*_First1)))
return (false);
else if (*_First1 < *_First2)
++_First1;
else
++_First1, ++_First2;
return (_First2 == _Last2);
}
template<class _InIt1,
class _InIt2> inline
bool includes(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2)
{	
return _Includes(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2));
}
		
template<class _InIt1,
class _InIt2,
class _Pr> inline
bool _Includes(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
{	
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (_Pred(*_First2, *_First1))
return (false);
else if (_Pred(*_First1, *_First2))
++_First1;
else
++_First1, ++_First2;
return (_First2 == _Last2);
}
template<class _InIt1,
class _InIt2,
class _Pr> inline
bool includes(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
{	
return _Includes(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Pred);
}
		
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (((*_First1) < (*_First2)))
*_Dest++ = *_First1, ++_First1;
else if (*_First2 < *_First1)
*_Dest++ = *_First2, ++_First2;
else
*_Dest++ = *_First1, ++_First1, ++_First2;
_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (set_union(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (_Pred(*_First1, *_First2))
*_Dest++ = *_First1, ++_First1;
else if (_Pred(*_First2, *_First1))
*_Dest++ = *_First2, ++_First2;
else
*_Dest++ = *_First1, ++_First1, ++_First2;
_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (set_union(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (((*_First1) < (*_First2)))
++_First1;
else if (*_First2 < *_First1)
++_First2;
else
*_Dest++ = *_First1++, ++_First2;
return (_Dest);
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (set_intersection(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (_Pred(*_First1, *_First2))
++_First1;
else if (_Pred(*_First2, *_First1))
++_First2;
else
*_Dest++ = *_First1++, ++_First2;
return (_Dest);
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (set_intersection(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (((*_First1) < (*_First2)))
*_Dest++ = *_First1, ++_First1;
else if (*_First2 < *_First1)
++_First2;
else
++_First1, ++_First2;
return (::stdext:: unchecked_copy(_First1, _Last1, _Dest));
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (set_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (_Pred(*_First1, *_First2))
*_Dest++ = *_First1, ++_First1;
else if (_Pred(*_First2, *_First1))
++_First2;
else
++_First1, ++_First2;
return (::stdext:: unchecked_copy(_First1, _Last1, _Dest));
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (set_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (((*_First1) < (*_First2)))
*_Dest++ = *_First1, ++_First1;
else if (*_First2 < *_First1)
*_Dest++ = *_First2, ++_First2;
else
++_First1, ++_First2;
_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (set_symmetric_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
		
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred, _Range_checked_iterator_tag)
{	
;
;
;
for (; _First1 != _Last1 && _First2 != _Last2; )
if (_Pred(*_First1, *_First2))
*_Dest++ = *_First1, ++_First1;
else if (_Pred(*_First2, *_First1))
*_Dest++ = *_First2, ++_First2;
else
++_First1, ++_First2;
_Dest = ::stdext:: unchecked_copy(_First1, _Last1, _Dest);
return (::stdext:: unchecked_copy(_First2, _Last2, _Dest));
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (set_symmetric_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
		
template<class _FwdIt> inline
_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last)
{	
;
_FwdIt _Found = _First;
if (_First != _Last)
for (; ++_First != _Last; )
if (((*_Found) < (*_First)))
_Found = _First;
return (_Found);
}
template<class _FwdIt> inline
_FwdIt max_element(_FwdIt _First, _FwdIt _Last)
{	
::std:: _Checked_assign_from_base(_First, _Max_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
return (_First);
}
		
template<class _FwdIt,
class _Pr> inline
_FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
;
;
_FwdIt _Found = _First;
if (_First != _Last)
for (; ++_First != _Last; )
if (_Pred(*_Found, *_First))
_Found = _First;
return (_Found);
}
template<class _FwdIt,
class _Pr> inline
_FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Max_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
return (_First);
}
		
template<class _FwdIt> inline
_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last)
{	
;
_FwdIt _Found = _First;
if (_First != _Last)
for (; ++_First != _Last; )
if (((*_First) < (*_Found)))
_Found = _First;
return (_Found);
}
template<class _FwdIt> inline
_FwdIt min_element(_FwdIt _First, _FwdIt _Last)
{	
::std:: _Checked_assign_from_base(_First, _Min_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last)));
return (_First);
}
		
template<class _FwdIt,
class _Pr> inline
_FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
;
;
_FwdIt _Found = _First;
if (_First != _Last)
for (; ++_First != _Last; )
if (_Pred(*_First, *_Found))
_Found = _First;
return (_Found);
}
template<class _FwdIt,
class _Pr> inline
_FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
{	
::std:: _Checked_assign_from_base(_First, _Min_element(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred));
return (_First);
}
		
template<class _BidIt> inline
bool _Next_permutation(_BidIt _First, _BidIt _Last)
{	
;
_BidIt _Next = _Last;
if (_First == _Last || _First == --_Next)
return (false);
	for (; ; )
{	
_BidIt _Next1 = _Next;
if (((*--_Next) < (*_Next1)))
{	
_BidIt _Mid = _Last;
for (; !((*_Next) < (*--_Mid)); )
;
std::iter_swap(_Next, _Mid);
std::reverse(_Next1, _Last);
return (true);
}
		if (_Next == _First)
{	
std::reverse(_First, _Last);
return (false);
}
}
}
template<class _BidIt> inline
bool next_permutation(_BidIt _First, _BidIt _Last)
{	
return _Next_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last));
}
		
template<class _BidIt,
class _Pr> inline
bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
;
;
_BidIt _Next = _Last;
if (_First == _Last || _First == --_Next)
return (false);
	for (; ; )
{	
_BidIt _Next1 = _Next;
if (_Pred(*--_Next, *_Next1))
{	
_BidIt _Mid = _Last;
for (; !_Pred(*_Next, *--_Mid); )
;
std::iter_swap(_Next, _Mid);
std::reverse(_Next1, _Last);
return (true);
}
		if (_Next == _First)
{	
std::reverse(_First, _Last);
return (false);
}
}
}
template<class _BidIt,
class _Pr> inline
bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
return _Next_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
}
		
template<class _BidIt> inline
bool _Prev_permutation(_BidIt _First, _BidIt _Last)
{	
;
_BidIt _Next = _Last;
if (_First == _Last || _First == --_Next)
return (false);
for (; ; )
{	
_BidIt _Next1 = _Next;
if (((*_Next1) < (*--_Next)))
{	
_BidIt _Mid = _Last;
for (; !((*--_Mid) < (*_Next)); )
;
std::iter_swap(_Next, _Mid);
std::reverse(_Next1, _Last);
return (true);
}
		if (_Next == _First)
{	
std::reverse(_First, _Last);
return (false);
}
}
}
template<class _BidIt> inline
bool prev_permutation(_BidIt _First, _BidIt _Last)
{	
return _Prev_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last));
}
		
template<class _BidIt,
class _Pr> inline
bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
;
;
_BidIt _Next = _Last;
if (_First == _Last || _First == --_Next)
return (false);
	for (; ; )
{	
_BidIt _Next1 = _Next;
if (_Pred(*_Next1, *--_Next))
{	
_BidIt _Mid = _Last;
for (; !_Pred(*--_Mid, *_Next); )
;
std::iter_swap(_Next, _Mid);
std::reverse(_Next1, _Last);
return (true);
}
		if (_Next == _First)
{	
std::reverse(_First, _Last);
return (false);
}
}
}
template<class _BidIt,
class _Pr> inline
bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
{	
return _Prev_permutation(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Pred);
}
}
namespace stdext {
template<class _InIt, class _OutIt, class _Fn1>
inline
_OutIt unchecked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
{
return ::std:: _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutIt, class _Fn1>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
{
return ::std:: _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Fn1, size_t _Size>
inline
_OutElem* checked_transform(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Fn1 _Func)
{
return (checked_transform(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Func).base());
}
template<class _InIt, class _OutIt, class _Fn1>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
{
return ::std:: _Transform(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Func,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
_OutIt unchecked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func)
{
return ::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
::std:: _Iter_random(_First1, _First2), ::std:: _Iter_random(_First1, _Dest), 
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result && ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func)
{
return ::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
::std:: _Iter_random(_First1, _First2), ::std:: _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InElem2, class _OutElem, class _Fn2, size_t _SizeFirst2, size_t _SizeDest>
inline
_OutElem* checked_transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
{
return (checked_transform(_First1, _Last1,
::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
::stdext:: make_checked_array_iterator(_Dest, _SizeDest),
_Func).base());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
{
return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
::std:: _Iter_random(_First1, _First2), ::std:: _Iter_cat(_First1),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Fn2, size_t _SizeDest>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result, _OutElem* >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutElem (&_Dest)[_SizeDest], _Fn2 _Func)
{
return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::stdext:: make_checked_array_iterator(_Dest, _SizeDest), _Func,
::std:: _Iter_random(_First1, _First2), ::std:: _Iter_cat(_First1),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()).base());
}
template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
_OutIt _Dest, _Fn2 _Func)
{
return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
_Dest, _Func,
::std:: _Iter_cat(_First1), ::std:: _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt1, class _InElem2, class _OutIt, class _Fn2, size_t _SizeFirst2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InElem2 (&_First2)[_SizeFirst2],
_OutIt _Dest, _Fn2 _Func)
{
return (::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::stdext:: make_checked_array_iterator(_First2, _SizeFirst2),
_Dest, _Func,
::std:: _Iter_cat(_First1), ::std:: _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt1, class _InIt2, class _OutIt, class _Fn2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _InIt2 >::_Result || !::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_transform(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
_OutIt _Dest, _Fn2 _Func)
{
return ::std:: _Transform(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2, _Dest, _Func,
::std:: _Iter_random(_First1, _First2), ::std:: _Iter_random(_First1, _Dest),
::std:: _Range_checked_iterator_tag(), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt1, class _FwdIt2>
inline
_FwdIt2 unchecked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
{
return ::std:: _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt1, class _FwdIt2>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
{
return ::std:: _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt1, class _FwdElem2, size_t _Size>
inline
_FwdElem2* checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdElem2 (&_First2)[_Size])
{
return (checked_swap_ranges(_First1, _Last1, ::stdext:: make_checked_array_iterator(_First2, _Size)).base());
}
template<class _FwdIt1, class _FwdIt2>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _FwdIt2 >::_Result, _FwdIt2 >::_Result checked_swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
{
return ::std:: _Swap_ranges(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), _First2,
::std:: _Iter_random(_First1, _First2), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
_OutIt unchecked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval)
{	
return ::std:: _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval)
{	
return ::std:: _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* checked_replace_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
const _Ty& _Oldval, const _Ty& _Newval)
{	
return (checked_replace_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size),
_Oldval, _Newval).base());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest,
const _Ty& _Oldval, const _Ty& _Newval)
{	
return ::std:: _Replace_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Oldval, _Newval,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Pr,
class _Ty> inline
_OutIt unchecked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val)
{	
return ::std:: _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Pr,
class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val)
{	
return ::std:: _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Pr, class _Ty, size_t _Size>
inline
_OutElem* checked_replace_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size],
_Pr _Pred, const _Ty& _Val)
{	
return (checked_replace_copy_if(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size),
_Pred, _Val).base());
}
template<class _InIt,
class _OutIt,
class _Pr,
class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
_Pr _Pred, const _Ty& _Val)
{	
return ::std:: _Replace_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, _Val,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _OutIt,
class _Diff,
class _Fn0> inline
void unchecked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
{	
::std:: _Generate_n(_Dest, _Count, _Func,
::std:: _Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _OutIt,
class _Diff,
class _Fn0> inline
void checked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _Diff >::_Result = 0)
{	
::std:: _Generate_n(_Dest, _Count, _Func,
::std:: _Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _OutElem, class _Diff, class _Fn0, size_t _Size>
inline
void checked_generate_n(_OutElem (&_Dest)[_Size], _Diff _Count, _Fn0 _Func)
{	
checked_generate_n(::stdext:: make_checked_array_iterator(_Dest, _Size), _Count, _Func);
}
template<class _OutIt,
class _Diff,
class _Fn0> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
void checked_generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func, typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _Diff >::_Result = 0)
{	
::std:: _Generate_n(_Dest, _Count, _Func,
::std:: _Iter_cat(_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
_OutIt unchecked_remove_copy(_InIt _First, _InIt _Last,
_OutIt _Dest, const _Ty& _Val)
{	
return ::std:: _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy(_InIt _First, _InIt _Last,
_OutIt _Dest, const _Ty& _Val)
{	
return ::std:: _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Ty, size_t _Size>
inline
_OutElem* checked_remove_copy(_InIt _First, _InIt _Last,
_OutElem (&_Dest)[_Size], const _Ty& _Val)
{	
return (checked_remove_copy(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size),
_Val).base());
}
template<class _InIt,
class _OutIt,
class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy(_InIt _First, _InIt _Last,
_OutIt _Dest, const _Ty& _Val)
{	
return ::std:: _Remove_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Val, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Pr> inline
_OutIt unchecked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_remove_copy_if(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (checked_remove_copy_if(_First, _Last,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Remove_copy_if(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt,
class _OutIt> inline
_OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_First == _Last ? _Dest :
::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_First == _Last ? _Dest :
::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutElem, size_t _Size>
inline
_OutElem* checked_unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size])
{	
return (_First == _Last ? _Dest :
(checked_unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base()));
}
template<class _InIt,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
{	
return (_First == _Last ? _Dest :
::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _OutIt,
class _Pr> inline
_OutIt unchecked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return (_First == _Last ? _Dest
: ::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred,
::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return (_First == _Last ? _Dest
: ::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _InIt, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_unique_copy(_InIt _First, _InIt _Last, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (_First == _Last ? _Dest
: (checked_unique_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base()));
}
template<class _InIt,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
{	
return (_First == _Last ? _Dest
: ::std:: _Unique_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, _Pred, ::std:: _Iter_cat(_First), ::std:: _Range_checked_iterator_tag()));
}
template<class _BidIt,
class _OutIt> inline
_OutIt unchecked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
{	
return ::std:: _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest,
::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
{	
return ::std:: _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutElem, size_t _Size>
inline
_OutElem* checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size])
{	
return (checked_reverse_copy(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _BidIt,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest)
{	
return ::std:: _Reverse_copy(::std:: _Checked_base(_First), ::std:: _Checked_base(_Last), _Dest, ::std:: _Iter_random(_First, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt,
class _OutIt> inline
_OutIt unchecked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
{	
return ::std:: _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt, class _OutIt>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
{
return ::std:: _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _FwdIt, class _OutElem, size_t _Size>
inline
_OutElem* checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutElem (&_Dest)[_Size])
{
return (checked_rotate_copy(_First, _Mid, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _FwdIt, class _OutIt>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
{
return ::std:: _Rotate_copy(_First, _Mid, _Last, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (checked_merge(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt unchecked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
::std:: _Iter_random(_First1, _First2,_Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred,
::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (checked_merge(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_merge(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Merge(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred,
::std:: _Iter_random(_First1, _First2, _Dest), ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
_BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
{
return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
{
return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest)
{
return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
_BidIt3 _Unchecked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
{
return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
{
return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt1, class _BidIt2, class _BidIt3, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _BidIt3 >::_Result, _BidIt3 >::_Result _Checked_merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
{
return ::std:: _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff>
inline
void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count)
{
::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count)
{
::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutElem, class _Diff, size_t _Size>
inline
void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
_Diff _Chunk, _Diff _Count)
{
::std:: _Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count)
{
::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
void _Unchecked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutElem, class _Diff, class _Pr, size_t _Size>
inline
void _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutElem (&_Dest)[_Size],
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
::std:: _Chunked_merge(_First, _Last, ::stdext:: make_checked_array_iterator(_Dest, _Size), _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _BidIt, class _OutIt, class _Diff, class _Pr>
inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, void >::_Result _Checked_chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
_Diff _Chunk, _Diff _Count, _Pr _Pred)
{
::std:: _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (checked_set_union(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt unchecked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (checked_set_union(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_union(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_union(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (checked_set_intersection(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt unchecked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (checked_set_intersection(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_intersection(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_intersection(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (checked_set_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt unchecked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (checked_set_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
_OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, size_t _Size>
inline
_OutElem* checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size])
{	
return (checked_set_symmetric_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size)).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
{	
return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
_OutIt unchecked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1), ::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2), _Dest, _Pred,
::std:: _Range_checked_iterator_tag());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
typename ::std:: _Enable_if< ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
template<class _InIt1, class _InIt2, class _OutElem, class _Pr, size_t _Size>
inline
_OutElem* checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutElem (&_Dest)[_Size], _Pr _Pred)
{	
return (checked_set_symmetric_difference(_First1, _Last1, _First2, _Last2,
::stdext:: make_checked_array_iterator(_Dest, _Size), _Pred).base());
}
template<class _InIt1,
class _InIt2,
class _OutIt,
class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
typename ::std:: _Enable_if< ! ::std:: _Is_checked_iterator< _OutIt >::_Result, _OutIt >::_Result checked_set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
{	
return ::std:: _Set_symmetric_difference(::std:: _Checked_base(_First1), ::std:: _Checked_base(_Last1),
::std:: _Checked_base(_First2), ::std:: _Checked_base(_Last2),
_Dest, _Pred, ::std:: _Range_checked_iterator_tag());
}
}
  #pragma warning(default: 4244)
 #pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Ty,
class _Container = deque<_Ty> >
class queue
{	
public:
typedef _Container container_type;
typedef typename _Container::value_type value_type;
typedef typename _Container::size_type size_type;
typedef typename _Container::reference reference;
typedef typename _Container::const_reference const_reference;
	queue()
: c()
{	
}
	explicit queue(const _Container& _Cont)
: c(_Cont)
{	
}
	bool empty() const
{	
return (c.empty());
}
	size_type size() const
{	
return (c.size());
}
	reference front()
{	
return (c.front());
}
	const_reference front() const
{	
return (c.front());
}
	reference back()
{	
return (c.back());
}
	const_reference back() const
{	
return (c.back());
}
	void push(const value_type& _Val)
{	
c.push_back(_Val);
}
	void pop()
{	
c.pop_front();
}
	const _Container& _Get_container() const
{	
return (c);
}
protected:
_Container c;	
};
		
template<class _Ty,
class _Container> inline
bool operator==(const queue<_Ty, _Container>& _Left,
const queue<_Ty, _Container>& _Right)
{	
return (_Left._Get_container() == _Right._Get_container());
}
template<class _Ty,
class _Container> inline
bool operator!=(const queue<_Ty, _Container>& _Left,
const queue<_Ty, _Container>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty,
class _Container> inline
bool operator<(const queue<_Ty, _Container>& _Left,
const queue<_Ty, _Container>& _Right)
{	
return (_Left._Get_container() < _Right._Get_container());
}
template<class _Ty,
class _Container> inline
bool operator>(const queue<_Ty, _Container>& _Left,
const queue<_Ty, _Container>& _Right)
{	
return (_Right < _Left);
}
template<class _Ty,
class _Container> inline
bool operator<=(const queue<_Ty, _Container>& _Left,
const queue<_Ty, _Container>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty,
class _Container> inline
bool operator>=(const queue<_Ty, _Container>& _Left,
const queue<_Ty, _Container>& _Right)
{	
return (!(_Left < _Right));
}
		
template<class _Ty,
class _Container = vector<_Ty>,
class _Pr = less<typename _Container::value_type> >
class priority_queue
{	
public:
typedef _Container container_type;
typedef typename _Container::value_type value_type;
typedef typename _Container::size_type size_type;
typedef typename _Container::reference reference;
typedef typename _Container::const_reference const_reference;
	priority_queue()
: c(), comp()
{	
}
	explicit priority_queue(const _Pr& _Pred)
: c(), comp(_Pred)
{	
}
	priority_queue(const _Pr& _Pred, const _Container& _Cont)
: c(_Cont), comp(_Pred)
{	
make_heap(c.begin(), c.end(), comp);
}
	template<class _Iter>
priority_queue(_Iter _First, _Iter _Last)
: c(_First, _Last), comp()
{	
make_heap(c.begin(), c.end(), comp);
}
	template<class _Iter>
priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred)
: c(_First, _Last), comp(_Pred)
{	
make_heap(c.begin(), c.end(), comp);
}
	template<class _Iter>
priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred,
const _Container& _Cont)
: c(_Cont), comp(_Pred)
{	
c.insert(c.end(), _First, _Last);
make_heap(c.begin(), c.end(), comp);
}
	bool empty() const
{	
return (c.empty());
}
	size_type size() const
{	
return (c.size());
}
	const_reference top() const
{	
return (c.front());
}
	reference top()
{	
return (c.front());
}
	void push(const value_type& _Pred)
{	
c.push_back(_Pred);
push_heap(c.begin(), c.end(), comp);
}
	void pop()
{	
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
}
protected:
_Container c;	
_Pr comp;	
};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4127)
namespace std {
		
template<size_t _Bits>
class bitset
{	
typedef unsigned long _Ty;	
enum {digits = _Bits};	
public:
typedef bool element_type;	
		
class reference
{	
friend class bitset<_Bits>;
	public:
reference& operator=(bool _Val)
{	
_Pbitset->set(_Mypos, _Val);
return (*this);
}
		reference& operator=(const reference& _Bitref)
{	
_Pbitset->set(_Mypos, bool(_Bitref));
return (*this);
}
		reference& flip()
{	
_Pbitset->flip(_Mypos);
return (*this);
}
		bool operator~() const
{	
return (!_Pbitset->test(_Mypos));
}
		operator bool() const
{	
return (_Pbitset->test(_Mypos));
}
	private:
reference(bitset<_Bits>& _Bitset, size_t _Pos)
: _Pbitset(&_Bitset), _Mypos(_Pos)
{	
}
		bitset<_Bits> *_Pbitset;	
size_t _Mypos;	
};
	bool at(size_t _Pos) const	
{	
return (test(_Pos));
}
	reference at(size_t _Pos)	
{	
return (reference(*this, _Pos));
}
	bool operator[](size_t _Pos) const
{	
return (test(_Pos));
}
	reference operator[](size_t _Pos)
{	
return (reference(*this, _Pos));
}
	bitset()
{	
_Tidy();
}
	bitset(unsigned long _Val)
{	
_Tidy();
for (int _Wpos = 0; ; )
{	
_Array[_Wpos] = _Val;
if ((int)(sizeof (unsigned long) / sizeof (_Ty)) <= ++_Wpos
|| _Words < _Wpos)
break;
_Val >>= _Bitsperword;
}
_Trim();
}
 
	template<class _Elem,
class _Tr,
class _Alloc>
explicit bitset(const basic_string<_Elem, _Tr, _Alloc>& _Str,
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Pos = 0)
{	
_Construct(_Str, _Pos,
basic_string<_Elem, _Tr, _Alloc>::npos, (_Elem)'0');
}
	template<class _Elem,
class _Tr,
class _Alloc>
explicit bitset(const basic_string<_Elem, _Tr, _Alloc>& _Str,
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Pos,
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Count,
_Elem _E0 = (_Elem)'0')
{	
_Construct(_Str, _Pos, _Count, _E0);
}
	template<class _Elem,
class _Tr,
class _Alloc>
void _Construct(
const basic_string<_Elem, _Tr, _Alloc>& _Str,
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Pos,
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Count,
_Elem _E0)
{	
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Num;
if (_Str.size() < _Pos)
_Xran();	
if (_Str.size() - _Pos < _Count)
_Count = _Str.size() - _Pos;	
if (_Bits < _Count)
_Count = _Bits;	
_Tidy();
		for (_Pos += _Count, _Num = 0; _Num < _Count; ++_Num)
if (_Str[--_Pos] == _E0 + 1)
set(_Num);
else if (_Str[_Pos] != _E0)
_Xinv();
}
	bitset<_Bits>& operator&=(const bitset<_Bits>& _Right)
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
_Array[_Wpos] &= _Right._Getword(_Wpos);
return (*this);
}
	bitset<_Bits>& operator|=(const bitset<_Bits>& _Right)
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
_Array[_Wpos] |= _Right._Getword(_Wpos);
return (*this);
}
	bitset<_Bits>& operator^=(const bitset<_Bits>& _Right)
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
_Array[_Wpos] ^= _Right._Getword(_Wpos);
return (*this);
}
	bitset<_Bits>& operator<<=(size_t _Pos)
{	
const int _Wordshift = (int)(_Pos / _Bitsperword);
if (_Wordshift != 0)
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)	
_Array[_Wpos] = _Wordshift <= _Wpos
? _Array[_Wpos - _Wordshift] : (_Ty)0;
		if (_Pos %= _Bitsperword)
{	
for (int _Wpos = _Words; 0 < _Wpos; --_Wpos)
_Array[_Wpos] = (_Ty)((_Array[_Wpos] << _Pos)
| (_Array[_Wpos - 1] >> (_Bitsperword - _Pos)));
_Array[0] <<= _Pos;
}
_Trim();
return (*this);
}
	bitset<_Bits>& operator>>=(size_t _Pos)
{	
const int _Wordshift = (int)(_Pos / _Bitsperword);
if (_Wordshift != 0)
for (int _Wpos = 0; _Wpos <= _Words; ++_Wpos)	
_Array[_Wpos] = _Wordshift <= _Words - _Wpos
? _Array[_Wpos + _Wordshift] : (_Ty)0;
		if (_Pos %= _Bitsperword)
{	
for (int _Wpos = 0; _Wpos < _Words; ++_Wpos)
_Array[_Wpos] = (_Ty)((_Array[_Wpos] >> _Pos)
| (_Array[_Wpos + 1] << (_Bitsperword - _Pos)));
_Array[_Words] >>= _Pos;
}
return (*this);
}
	bitset<_Bits>& set()
{	
_Tidy((_Ty)~0);
return (*this);
}
	bitset<_Bits>& set(size_t _Pos,
bool _Val = true)
{	
if (_Bits <= _Pos)
_Xran();	
if (_Val)
_Array[_Pos / _Bitsperword] |= (_Ty)1 << _Pos % _Bitsperword;
else
_Array[_Pos / _Bitsperword] &= ~((_Ty)1 << _Pos % _Bitsperword);
return (*this);
}
	bitset<_Bits>& reset()
{	
_Tidy();
return (*this);
}
	bitset<_Bits>& reset(size_t _Pos)
{	
return (set(_Pos, false));
}
	bitset<_Bits> operator~() const
{	
return (bitset<_Bits>(*this).flip());
}
	bitset<_Bits>& flip()
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
_Array[_Wpos] = (_Ty)~_Array[_Wpos];
		_Trim();
return (*this);
}
	bitset<_Bits>& flip(size_t _Pos)
{	
if (_Bits <= _Pos)
_Xran();	
_Array[_Pos / _Bitsperword] ^= (_Ty)1 << _Pos % _Bitsperword;
return (*this);
}
	unsigned long to_ulong() const
{	
enum
{	
_Assertion = 1
/ (int)(sizeof (unsigned long) % sizeof (_Ty) == 0)};
		int _Wpos = _Words;
for (; (int)(sizeof (unsigned long) / sizeof (_Ty)) <= _Wpos; --_Wpos)
if (_Array[_Wpos] != 0)
_Xoflo();	
		unsigned long _Val = _Array[_Wpos];
for (; 0 <= --_Wpos; )
_Val = ((_Val << (_Bitsperword - 1)) << 1) | _Array[_Wpos];
return (_Val);
}
	template<class _Elem,
class _Tr,
class _Alloc>
basic_string<_Elem, _Tr, _Alloc>
to_string(_Elem _E0 = (_Elem)'0') const
{	
basic_string<_Elem, _Tr, _Alloc> _Str;
typename basic_string<_Elem, _Tr, _Alloc>::size_type _Pos;
_Str.reserve(_Bits);
		for (_Pos = _Bits; 0 < _Pos; )
_Str += (_Elem)(_E0 + (int)test(--_Pos));
return (_Str);
}
	template<class _Elem,
class _Tr>
basic_string<_Elem, _Tr, allocator<_Elem> >
to_string(_Elem _E0 = (_Elem)'0') const
{	
return (to_string<_Elem, _Tr, allocator<_Elem> >(_E0));
}
	template<class _Elem>
basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
to_string(_Elem _E0 = (_Elem)'0') const
{	
return (to_string<_Elem, char_traits<_Elem>,
allocator<_Elem> >(_E0));
}
		string to_string(char _E0 = (char)'0') const
{	
return (to_string<char, char_traits<char>, allocator<char> >(_E0));
}
	size_t count() const
{	
static char _Bitsperhex[] = "\0\1\1\2\1\2\2\3\1\2\2\3\2\3\3\4";
size_t _Val = 0;
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
for (_Ty _Wordval = _Array[_Wpos]; _Wordval != 0; _Wordval >>= 4)
_Val += _Bitsperhex[_Wordval & 0xF];
return (_Val);
}
	size_t size() const
{	
return (_Bits);
}
	bool operator==(const bitset<_Bits>& _Right) const
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
if (_Array[_Wpos] != _Right._Getword(_Wpos))
return (false);
return (true);
}
	bool operator!=(const bitset<_Bits>& _Right) const
{	
return (!(*this == _Right));
}
	bool test(size_t _Pos) const
{	
if (_Bits <= _Pos)
_Xran();	
return ((_Array[_Pos / _Bitsperword]
& ((_Ty)1 << _Pos % _Bitsperword)) != 0);
}
	bool any() const
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
if (_Array[_Wpos] != 0)
return (true);
return (false);
}
	bool none() const
{	
return (!any());
}
	bitset<_Bits> operator<<(size_t _Pos) const
{	
return (bitset<_Bits>(*this) <<= _Pos);
}
	bitset<_Bits> operator>>(size_t _Pos) const
{	
return (bitset<_Bits>(*this) >>= _Pos);
}
	_Ty _Getword(size_t _Wpos) const
{	
return (_Array[_Wpos]);
}
private:
enum
{	
_Bitsperword = (int)(8 * sizeof (_Ty)),	
_Words = (int)(_Bits == 0
? 0 : (_Bits - 1) / _Bitsperword)};	
	void _Tidy(_Ty _Wordval = 0)
{	
for (int _Wpos = _Words; 0 <= _Wpos; --_Wpos)
_Array[_Wpos] = _Wordval;
if (_Wordval != 0)
_Trim();
}
	void _Trim()
{	
if (_Bits % _Bitsperword != 0)
_Array[_Words] &= ((_Ty)1 << _Bits % _Bitsperword) - 1;
}
	void _Xinv() const
{	
throw invalid_argument("invalid bitset<N> char");
}
	void _Xoflo() const
{	
throw overflow_error("bitset<N> overflow");
}
	void _Xran() const
{	
throw out_of_range("invalid bitset<N> position");
}
	_Ty _Array[_Words + 1];	
};
		
template<size_t _Bits> inline
bitset<_Bits> operator&(const bitset<_Bits>& _Left,
const bitset<_Bits>& _Right)
{	
bitset<_Bits> _Ans = _Left;
return (_Ans &= _Right);
}
template<size_t _Bits> inline
bitset<_Bits> operator|(const bitset<_Bits>& _Left,
const bitset<_Bits>& _Right)
{	
bitset<_Bits> _Ans = _Left;
return (_Ans |= _Right);
}
template<size_t _Bits> inline
bitset<_Bits> operator^(const bitset<_Bits>& _Left,
const bitset<_Bits>& _Right)
{	
bitset<_Bits> _Ans = _Left;
return (_Ans ^= _Right);
}
template<class _Elem,
class _Tr,
size_t _Bits> inline
basic_ostream<_Elem, _Tr>& operator<<(
basic_ostream<_Elem, _Tr>& _Ostr, const bitset<_Bits>& _Right)
{	
const ctype<_Elem>& _Ctype_fac = use_facet<ctype<_Elem> >(_Ostr.getloc());
const _Elem _E0 = _Ctype_fac.widen('0');
	return (_Ostr
<< _Right.template to_string<_Elem, _Tr, allocator<_Elem> >(_E0));
}
		
template<class _Elem,
class _Tr,
size_t _Bits> inline
basic_istream<_Elem, _Tr>& operator>>(
basic_istream<_Elem, _Tr>& _Istr, bitset<_Bits>& _Right)
{	
const ctype<_Elem>& _Ctype_fac = use_facet<ctype<_Elem> >(_Istr.getloc());
const _Elem _E0 = _Ctype_fac.widen('0');
ios_base::iostate _State = ios_base::goodbit;
bool _Changed = false;
string _Str;
const typename basic_istream<_Elem, _Tr>::sentry _Ok(_Istr);
	if (_Ok)
{	
try {
typename _Tr::int_type _Meta = _Istr.rdbuf()->sgetc();
for (size_t _Count = _Right.size(); 0 < _Count;
_Meta = _Istr.rdbuf()->snextc(), --_Count)
{	
_Elem _Char;
if (_Tr::eq_int_type(_Tr::eof(), _Meta))
{	
_State |= ios_base::eofbit;
break;
}
else if ((_Char = _Tr::to_char_type(_Meta)) != _E0
&& _Char != _E0 + 1)
break;	
else if (_Str.max_size() <= _Str.size())
{	
_State |= ios_base::failbit;
break;
}
else
_Str.append(1, (_Char - _E0) + '0'), _Changed = true;
}
} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
}
	if (!_Changed)
_State |= ios_base::failbit;
_Istr.setstate(_State);
_Right = bitset<_Bits>(_Str);	
return (_Istr);
}
}
  #pragma warning(default: 4127)
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4127)
 
		
namespace stdext {
 
template <class _InIt>
inline size_t _Hash_value(_InIt _Begin, _InIt _End)
{	
size_t _Val = 2166136261U;
while(_Begin != _End)
_Val = 16777619U * _Val ^ (size_t)*_Begin++;
return (_Val);
}
template<class _Elem,
class _Traits,
class _Alloc> inline
size_t hash_value(const ::std:: basic_string<_Elem, _Traits, _Alloc>& _Str)
{	
const _Elem *_Ptr = _Str.c_str();
	return (_Hash_value(_Ptr, _Ptr + _Str.size()));
}
template<class _Kty> inline
size_t hash_value(const _Kty& _Keyval)
{	
return ((size_t)_Keyval ^ (size_t)0xdeadbeef);
}
inline size_t hash_value(const char *_Str)
{	
return (_Hash_value(_Str, _Str + ::strlen(_Str)));
}
inline size_t hash_value(const wchar_t *_Str)
{	
return (_Hash_value(_Str, _Str + ::wcslen(_Str)));
}
		
 
template<class _Kty,
class _Pr = ::std:: less<_Kty> >
class hash_compare
{	
public:
enum
{	
bucket_size = 4,	
min_buckets = 8};	
	hash_compare()
: comp()
{	
}
	hash_compare(_Pr _Pred)
: comp(_Pred)
{	
}
	size_t operator()(const _Kty& _Keyval) const
{	
long _Quot = hash_value(_Keyval) & 2147483647L;
ldiv_t _Qrem = ldiv(_Quot, 127773);
		_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot;
if (_Qrem.rem < 0)
_Qrem.rem += 2147483647L;
return ((size_t)_Qrem.rem);
}
	bool operator()(const _Kty& _Keyval1, const _Kty& _Keyval2) const
{	
return (comp(_Keyval1, _Keyval2));
}
protected:
_Pr comp;	
};
		
template<class _Traits>
class _Hash
: public _Traits	
{	
public:
typedef _Hash<_Traits> _Myt;
typedef typename _Traits::key_type key_type;
typedef typename _Traits::key_compare key_compare;
typedef typename _Traits::value_compare value_compare;
enum
{	
_Bucket_size = key_compare::bucket_size,
min_buckets = key_compare::min_buckets,
_Multi = _Traits::_Multi};
typedef ::std:: list<typename _Traits::value_type,
typename _Traits::allocator_type> _Mylist;
	typedef typename _Mylist::allocator_type allocator_type;
typedef typename _Mylist::size_type size_type;
typedef typename _Mylist::difference_type difference_type;
typedef typename _Mylist::pointer pointer;
typedef typename _Mylist::const_pointer const_pointer;
typedef typename _Mylist::reference reference;
typedef typename _Mylist::const_reference const_reference;
 
	typedef typename _Mylist::iterator _Myiterator;
typedef typename _Mylist::iterator iterator;
	typedef typename _Mylist::const_iterator const_iterator;
	
	
	struct _List_position
{
public:
_List_position()
: _Mypos()
{
}
		_List_position(iterator _Iter)
: _Mypos(_Iter._Mynode(), (_Mylist*)_Iter._Getmycont())
{
}
		_List_position(const_iterator _Iter)
: _Mypos(_Iter._Mynode(), (_Mylist*)_Iter._Getmycont())
{
}
		
		iterator _Get_iter(const _Mylist &_List) const
{
			return _Myiterator(_Mypos._Mynode(), &_List);
}
		bool operator==(const _List_position &_Right) const
{
return (_Mypos._Mynode() == _Right._Mypos._Mynode());
}
		bool operator!=(const _List_position &_Right) const
{
return (!(*this == _Right));
}
		bool operator==(const const_iterator &_Right) const
{
return (_Mypos._Mynode() == _Right._Mynode());
}
		bool operator!=(const const_iterator &_Right) const
{
return (!(*this == _Right));
}
	protected:
typename _Mylist::_Iterator<0> _Mypos;
};
	typedef _List_position _Myvec_value_type;
	inline iterator _Get_iter_from_vec(const _Myvec_value_type &_Pos) const
{
return _Pos._Get_iter(_List);
}
	typedef typename _Mylist::reverse_iterator
reverse_iterator;
typedef typename _Mylist::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mylist::value_type value_type;
	typedef ::std:: vector<_Myvec_value_type,
typename allocator_type::template
rebind<_Myvec_value_type>::other> _Myvec;
typedef ::std:: pair<iterator, bool> _Pairib;
typedef ::std:: pair<iterator, iterator> _Pairii;
typedef ::std:: pair<const_iterator, const_iterator> _Paircc;
	explicit _Hash(const key_compare& _Parg,
const allocator_type& _Al)
: _Traits(_Parg), _List(_Al),
_Vec(_Al),
_Max_bucket_size(_Bucket_size)
{	
_Init();
}
	_Hash(const value_type *_First, const value_type *_Last,
const key_compare& _Parg, const allocator_type& _Al)
: _Traits(_Parg), _List(_Al),
_Vec(_Al),
_Max_bucket_size(_Bucket_size)
{	
_Init();
insert(_First, _Last);
}
	_Hash(const _Myt& _Right)
: _Traits(_Right.comp), _List(_Right.get_allocator()),
_Vec(_Right.get_allocator())
{	
_Copy(_Right);
}
	~_Hash()
{	
}
	_Myt& operator=(const _Myt& _Right)
{	
if (this != &_Right)
_Copy(_Right);
return (*this);
}
	iterator begin()
{	
return (_List.begin());
}
	const_iterator begin() const
{	
return (_List.begin());
}
	iterator end()
{	
return (_List.end());
}
	const_iterator end() const
{	
return (_List.end());
}
	reverse_iterator rbegin()
{	
return (_List.rbegin());
}
	const_reverse_iterator rbegin() const
{	
return (_List.rbegin());
}
	reverse_iterator rend()
{	
return (_List.rend());
}
	const_reverse_iterator rend() const
{	
return (_List.rend());
}
	size_type size() const
{	
return (_List.size());
}
	size_type max_size() const
{	
return (_List.max_size());
}
	bool empty() const
{	
return (_List.empty());
}
	allocator_type get_allocator() const
{	
return (_List.get_allocator());
}
	key_compare key_comp() const
{	
return (this->comp);
}
	value_compare value_comp() const
{	
return (value_compare(key_comp()));
}
	typedef iterator local_iterator;
typedef const_iterator const_local_iterator;
	size_type bucket_count() const
{	
return (_Maxidx);
}
	size_type max_bucket_count() const
{	
return (_Vec.size() - 1);
}
	size_type bucket(const key_type& _Keyval) const
{	
return (_Hashval(_Keyval));
}
	size_type bucket_size(size_type _Bucket) const
{	
size_type _Ans = 0;
if (_Bucket < _Maxidx)
for (iterator _Plist = _Get_iter_from_vec(_Vec[_Bucket]);
_Plist != _Get_iter_from_vec(_Vec[_Bucket + 1]); ++_Plist)
++_Ans;
return (_Ans);
}
	local_iterator begin(size_type _Bucket)
{	
if (_Bucket < bucket_count())
return (_Get_iter_from_vec(_Vec[_Bucket]));
else
return (end());
}
	const_local_iterator begin(size_type _Bucket) const
{	
if (_Bucket < bucket_count())
return (_Get_iter_from_vec(_Vec[_Bucket]));
else
return (end());
}
	local_iterator end(size_type _Bucket)
{	
if (_Bucket < bucket_count())
return (_Get_iter_from_vec(_Vec[_Bucket + 1]));
else
return (end());
}
	const_local_iterator end(size_type _Bucket) const
{	
if (_Bucket < bucket_count())
return (_Get_iter_from_vec(_Vec[_Bucket + 1]));
else
return (end());
}
	float load_factor() const
{	
return ((float)size() / (float)bucket_count());
}
	float max_load_factor() const
{	
return (_Max_bucket_size);
}
	void max_load_factor(float _Newmax)
{	
if (_Newmax != _Newmax	
|| _Newmax < 0)
throw ::std:: out_of_range("invalid hash load factor");
		_Max_bucket_size = _Newmax;
}
	void rehash(size_type _Buckets)
{	
size_type _Maxsize = _Vec.max_size() / 2;
size_type _Newsize = min_buckets;
		for (; _Newsize < _Buckets && _Newsize < _Maxsize; )
_Newsize *= 2;	
if (_Newsize < _Buckets)
throw ::std:: out_of_range("invalid hash bucket count");
for (float _Size = (float)size();
max_load_factor() < _Size / _Newsize && _Newsize < _Maxsize; )
_Newsize *= 2;	
		_Init(_Newsize);
_Reinsert();
}
	_Pairib insert(const value_type& _Val)
{	
return (_Insert(_Val, end()));
}
	iterator insert(const_iterator, const value_type& _Val)
{	
return (insert(_Val).first);
}
	template<class _Iter>
void insert(_Iter _First, _Iter _Last)
{	
_List.insert(begin(), _First, _Last);
_Reinsert();
}
	iterator erase(const_iterator _Where)
{	
size_type _Bucket = _Hashval(this->_Kfn(*_Where));
for (; _Vec[_Bucket] == _Where; --_Bucket)
{	
			iterator _Vec_iter = _Get_iter_from_vec(_Vec[_Bucket]);
++_Vec_iter;
_Vec[_Bucket] = _Vec_iter;
			if (_Bucket == 0)
break;
}
return (_List.erase(_Where));
}
	iterator erase(const_iterator _First, const_iterator _Last)
{	
;
if (_First == begin() && _Last == end())
{	
clear();
return (begin());
}
else
{	
while (_First != _Last)
erase(_First++);
return (_List._Make_iter(_First));
}
}
	size_type erase(const key_type& _Keyval)
{	
_Pairii _Where = equal_range(_Keyval);
size_type _Num = 0;
_Distance(_Where.first, _Where.second, _Num);
erase(_Where.first, _Where.second);
return (_Num);
}
	void erase(const key_type *_First,
const key_type *_Last)
{	
;
for (; _First != _Last; ++_First)
erase(*_First);
}
	void clear()
{	
_List.clear();
_Init();
}
	iterator find(const key_type& _Keyval)
{	
return (lower_bound(_Keyval));
}
	const_iterator find(const key_type& _Keyval) const
{	
return (lower_bound(_Keyval));
}
	size_type count(const key_type& _Keyval) const
{	
_Paircc _Ans = equal_range(_Keyval);
size_type _Num = 0;
_Distance(_Ans.first, _Ans.second, _Num);
return (_Num);
}
	iterator lower_bound(const key_type& _Keyval)
{	
size_type _Bucket = _Hashval(_Keyval);
iterator _Where;
for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)
if (!this->comp(this->_Kfn(*_Where), _Keyval))
return (this->comp(_Keyval,
this->_Kfn(*_Where)) ? end() : _Where);
return (end());
}
	const_iterator lower_bound(const key_type& _Keyval) const
{	
size_type _Bucket = _Hashval(_Keyval);
const_iterator _Where;
for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)
if (!this->comp(this->_Kfn(*_Where), _Keyval))
return (this->comp(_Keyval,
this->_Kfn(*_Where)) ? end() : _Where);
return (end());
}
	iterator upper_bound(const key_type& _Keyval)
{	
size_type _Bucket = _Hashval(_Keyval);
iterator _Where;
for (_Where = _Get_iter_from_vec(_Vec[_Bucket + 1]); _Vec[_Bucket] != _Where; )
if (!this->comp(_Keyval, this->_Kfn(*--_Where)))
return (this->comp(this->_Kfn(*_Where),
_Keyval) ? end() : (iterator)++_Where);
return (end());
}
	const_iterator upper_bound(const key_type& _Keyval) const
{	
size_type _Bucket = _Hashval(_Keyval);
const_iterator _Where;
for (_Where = _Get_iter_from_vec(_Vec[_Bucket + 1]); _Vec[_Bucket] != _Where; )
if (!this->comp(_Keyval, this->_Kfn(*--_Where)))
return (this->comp(this->_Kfn(*_Where),
_Keyval) ? end() : (const_iterator)++_Where);
return (end());
}
	_Pairii equal_range(const key_type& _Keyval)
{	
size_type _Bucket = _Hashval(_Keyval);
iterator _First, _Where;
for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)
if (!this->comp(this->_Kfn(*_Where), _Keyval))
{	
for (_First = _Where; _Vec[_Bucket + 1] != _Where; ++_Where)
if (this->comp(_Keyval, this->_Kfn(*_Where)))
break;
if (_First == _Where)
break;
return (_Pairii(_First, _Where));
}
return (_Pairii(end(), end()));
}
	_Paircc equal_range(const key_type& _Keyval) const
{	
size_type _Bucket = _Hashval(_Keyval);
iterator _First, _Where;
for (_Where = _Get_iter_from_vec(_Vec[_Bucket]); _Vec[_Bucket + 1] != _Where; ++_Where)
if (!this->comp(this->_Kfn(*_Where), _Keyval))
{	
for (_First = _Where; _Vec[_Bucket + 1] != _Where; ++_Where)
if (this->comp(_Keyval, this->_Kfn(*_Where)))
break;
if (_First == _Where)
break;
return (_Paircc(_First, _Where));
}
return (_Paircc(end(), end()));
}
	void swap(_Myt& _Right)
{	
if (this != &_Right)
{	
_Myt _Tmp = *this;
			*this = _Right;
_Right = _Tmp;
}
}
 
protected:
void _Copy(const _Myt& _Right)
{	
_Vec.resize(_Right._Vec.size(), end());
_Mask = _Right._Mask;
_Maxidx = _Right._Maxidx;
_Max_bucket_size = _Right._Max_bucket_size;
_List.clear();
		try {
_List.insert(end(), _Right._List.begin(), _Right._List.end());
this->comp = _Right.comp;
} catch (...) {
_List.clear();	
fill(_Vec.begin(), _Vec.end(), end());
throw;
}
		iterator _Whereto = begin();
const_iterator _Wherefrom = _Right.begin();
for (size_type _Bucket = 0; _Bucket < _Vec.size(); )
if (_Right._Vec[_Bucket] == _Wherefrom)
_Vec[_Bucket] = _Whereto, ++_Bucket;
else
++_Whereto, ++_Wherefrom;
}
	void _Grow()
{	
iterator _Plist;
		if (_Vec.size() - 1 <= _Maxidx)
{	
_Mask = ((_Vec.size() - 1) << 1) - 1;
_Vec.resize(_Mask + 2, end());
}
else if (_Mask < _Maxidx)
_Mask = (_Mask << 1) + 1;
		size_type _Bucket = _Maxidx - (_Mask >> 1) - 1;
for (_Plist = _Get_iter_from_vec(_Vec[_Bucket]); 
_Plist != _Get_iter_from_vec(_Vec[_Bucket + 1]); )
{	
size_type _Newbucket =
this->comp(this->_Kfn(*_Plist)) & _Mask;
if (_Newbucket == _Bucket)
++_Plist;	
 
			else
{	
size_type _Idx;
iterator _Pnext = _Plist;
if (++_Pnext != end())
{	
for (_Idx = _Bucket; _Plist == _Get_iter_from_vec(_Vec[_Idx]); --_Idx)
{	
_Vec[_Idx] = _Pnext;
if (_Idx == 0)
break;
}
_List._Splice(end(), _List, _Plist, _Pnext, 0);
_Plist = --end();
_Vec[_Maxidx + 1] = end();
}
				for (_Idx = _Maxidx; _Bucket < _Idx; --_Idx)
{	
if (_Get_iter_from_vec(_Vec[_Idx]) != end())
break;
_Vec[_Idx] = _Plist;
}
				if (_Pnext == end())
break;
else
_Plist = _Pnext;
}
}
++_Maxidx;	
}
	size_type _Hashval(const key_type& _Keyval) const
{	
size_type _Num = this->comp(_Keyval) & _Mask;
if (_Maxidx <= _Num)
_Num -= (_Mask >> 1) + 1;
return (_Num);
}
	void _Init(size_type _Buckets = min_buckets)
{	
_Vec.assign(_Buckets + 1, end());
_Mask = _Buckets - 1;
_Maxidx = _Buckets;
}
	_Pairib _Insert(const value_type& _Val, iterator _Where)
{	
size_type _Bucket = _Hashval(this->_Kfn(_Val));
iterator _Plist = _Get_iter_from_vec(_Vec[_Bucket + 1]);
		for (; _Plist != _Get_iter_from_vec(_Vec[_Bucket]); )
if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))
;	
else if (_Multi
|| this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))
{	
++_Plist;
break;
}
else
{	
if (_Where != end())
_List.erase(_Where);
return (_Pairib(_Plist, false));
}
		if (_Where != end())
_List.splice(_Plist, _List, _Where);	
else
_Where = _List.insert(_Plist, _Val);	
for (; _Plist == _Get_iter_from_vec(_Vec[_Bucket]); --_Bucket)
{	
_Vec[_Bucket] = _Where;
if (_Bucket == 0)
break;
}
		if (max_load_factor() < load_factor())
_Grow();	
return (_Pairib(_Where, true));	
}
	void _Reinsert()
{	
iterator _First;
for (; (_First = _List.begin()) != _Get_iter_from_vec(_Vec[0]); )
_Insert(*_First, _First);
}
	_Mylist _List;	
_Myvec _Vec;	
size_type _Mask;	
size_type _Maxidx;	
float _Max_bucket_size;	
};
		
template<class _Ty> inline
bool operator==(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
{	
return (_Left.size() == _Right.size()
&& equal(_Left.begin(), _Left.end(), _Right.begin()));
}
template<class _Ty> inline
bool operator!=(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
{	
return (!(_Left == _Right));
}
template<class _Ty> inline
bool operator<(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
{	
return (lexicographical_compare(_Left.begin(), _Left.end(),
_Right.begin(), _Right.end()));
}
template<class _Ty> inline
bool operator>(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
{	
return (_Right < _Left);
}
template<class _Ty> inline
bool operator<=(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
{	
return (!(_Right < _Left));
}
template<class _Ty> inline
bool operator>=(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
{	
return (!(_Left < _Right));
}
}
namespace std {
	
template <class _Traits>
class _Move_operation_category<::stdext:: _Hash<_Traits> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
}
 #pragma warning(default: 4127)
#pragma warning(pop)
#pragma pack(pop)
 #pragma pack(push,8)
#pragma warning(push,3)
namespace stdext {
 
		
template<class _Kty,	
class _Tr,	
class _Alloc,	
bool _Mfl>	
class _Hset_traits
: public ::std:: _Container_base
{	
public:
typedef _Kty key_type;
typedef _Kty value_type;
typedef _Tr key_compare;
typedef typename _Alloc::template rebind<value_type>::other
allocator_type;
	typedef typename allocator_type::const_pointer _ITptr;
typedef typename allocator_type::const_reference _IReft;
	enum
{	
_Multi = _Mfl};
	_Hset_traits()
: comp()
{	
}
	_Hset_traits(const _Tr& _Traits)
: comp(_Traits)
{	
}
	typedef key_compare value_compare;
	static const _Kty& _Kfn(const value_type& _Val)
{	
return (_Val);
}
	_Tr comp;	
};
		
template<class _Kty,
class _Tr = hash_compare<_Kty, ::std:: less<_Kty> >,
class _Alloc = ::std:: allocator<_Kty> >
class hash_set
: public _Hash<_Hset_traits<_Kty, _Tr, _Alloc, false> >
{	
public:
typedef hash_set<_Kty, _Tr, _Alloc> _Myt;
typedef _Hash<_Hset_traits<_Kty, _Tr, _Alloc, false> > _Mybase;
typedef _Kty key_type;
typedef _Tr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	hash_set()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit hash_set(const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
}
	hash_set(const key_compare& _Traits, const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
}
	template<class _Iter>
hash_set(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_set(_Iter _First, _Iter _Last,
const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_set(_Iter _First, _Iter _Last,
const key_compare& _Traits, const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
};
template<class _Kty,
class _Tr,
class _Alloc> inline
void swap(::stdext:: hash_set<_Kty, _Tr, _Alloc>& _Left,
::stdext:: hash_set<_Kty, _Tr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
		
template<class _Kty,
class _Tr = hash_compare<_Kty, ::std:: less<_Kty> >,
class _Alloc = ::std:: allocator<_Kty> >
class hash_multiset
: public _Hash<_Hset_traits<_Kty, _Tr, _Alloc, true> >
{	
public:
typedef hash_multiset<_Kty, _Tr, _Alloc> _Myt;
typedef _Hash<_Hset_traits<_Kty, _Tr, _Alloc, true> > _Mybase;
typedef _Kty key_type;
typedef _Tr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	hash_multiset()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit hash_multiset(const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
}
	hash_multiset(const key_compare& _Traits,
const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
}
	template<class _Iter>
hash_multiset(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_multiset(_Iter _First, _Iter _Last,
const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_multiset(_Iter _First, _Iter _Last,
const key_compare& _Traits, const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	iterator insert(const value_type& _Val)
{	
return (_Mybase::insert(_Val).first);
}
	iterator insert(const_iterator _Where, const value_type& _Val)
{	
return (_Mybase::insert(_Where, _Val));
}
	template<class _Iter>
void insert(_Iter _First, _Iter _Last)
{	
 
		this->_Mybase::insert(_First, _Last);
}
};
template<class _Kty,
class _Tr,
class _Alloc> inline
void swap(::stdext:: hash_multiset<_Kty, _Tr, _Alloc>& _Left,
::stdext:: hash_multiset<_Kty, _Tr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
}
namespace std {
	
template<class _Kty, class _Tr, class _Alloc>
class _Move_operation_category<::stdext:: hash_set<_Kty, _Tr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
	
template<class _Kty, class _Tr, class _Alloc>
class _Move_operation_category<::stdext:: hash_multiset<_Kty, _Tr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace stdext {
 
		
template<class _Kty,	
class _Ty,	
class _Tr,	
class _Alloc,	
bool _Mfl>	
class _Hmap_traits
: public ::std:: _Container_base
{	
public:
typedef _Kty key_type;
typedef ::std:: pair<const _Kty, _Ty> value_type;
typedef _Tr key_compare;
typedef typename _Alloc::template rebind<value_type>::other
allocator_type;
 	typedef typename allocator_type::pointer _ITptr;
typedef typename allocator_type::reference _IReft;
	enum
{	
_Multi = _Mfl};
	_Hmap_traits()
: comp()
{	
}
	_Hmap_traits(const _Tr& _Traits)
: comp(_Traits)
{	
}
	class value_compare
: public ::std:: binary_function<value_type, value_type, bool>
{	
friend class _Hmap_traits<_Kty, _Ty, _Tr, _Alloc, _Mfl>;
	public:
bool operator()(const value_type& _Left,
const value_type& _Right) const
{	
return (comp(_Left.first, _Right.first));
}
		value_compare(const key_compare& _Traits)
: comp(_Traits)
{	
}
	protected:
key_compare comp;	
};
	static const _Kty& _Kfn(const value_type& _Val)
{	
return (_Val.first);
}
	_Tr comp;	
};
		
template<class _Kty,
class _Ty,
class _Tr = hash_compare<_Kty, ::std:: less<_Kty> >,
class _Alloc = ::std:: allocator< ::std:: pair<const _Kty, _Ty> > >
class hash_map
: public _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, false> >
{	
public:
typedef hash_map<_Kty, _Ty, _Tr, _Alloc> _Myt;
typedef _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, false> > _Mybase;
typedef _Kty key_type;
typedef _Ty mapped_type;
typedef _Ty referent_type;
typedef _Tr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	hash_map()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit hash_map(const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
}
	hash_map(const key_compare& _Traits, const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
}
	template<class _Iter>
hash_map(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_map(_Iter _First, _Iter _Last,
const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_map(_Iter _First, _Iter _Last,
const key_compare& _Traits,
const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	mapped_type& operator[](const key_type& _Keyval)
{	
iterator _Where = this->lower_bound(_Keyval);
if (_Where == this->end())
_Where = this->insert(value_type(_Keyval, mapped_type())).first;
return ((*_Where).second);
}
};
template<class _Kty,
class _Ty,
class _Tr,
class _Alloc> inline
void swap( ::stdext:: hash_map<_Kty, _Ty, _Tr, _Alloc>& _Left,
::stdext:: hash_map<_Kty, _Ty, _Tr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
		
template<class _Kty,
class _Ty,
class _Tr = hash_compare<_Kty, ::std:: less<_Kty> >,
class _Alloc = ::std:: allocator< ::std:: pair<const _Kty, _Ty> > >
class hash_multimap
: public _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, true> >
{	
public:
typedef hash_multimap<_Kty, _Ty, _Tr, _Alloc> _Myt;
typedef _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, true> > _Mybase;
typedef _Kty key_type;
typedef _Ty mapped_type;
typedef _Ty referent_type;	
typedef _Tr key_compare;
typedef typename _Mybase::value_compare value_compare;
typedef typename _Mybase::allocator_type allocator_type;
typedef typename _Mybase::size_type size_type;
typedef typename _Mybase::difference_type difference_type;
typedef typename _Mybase::pointer pointer;
typedef typename _Mybase::const_pointer const_pointer;
typedef typename _Mybase::reference reference;
typedef typename _Mybase::const_reference const_reference;
typedef typename _Mybase::iterator iterator;
typedef typename _Mybase::const_iterator const_iterator;
typedef typename _Mybase::reverse_iterator reverse_iterator;
typedef typename _Mybase::const_reverse_iterator
const_reverse_iterator;
typedef typename _Mybase::value_type value_type;
	hash_multimap()
: _Mybase(key_compare(), allocator_type())
{	
}
	explicit hash_multimap(const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
}
	hash_multimap(const key_compare& _Traits,
const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
}
	template<class _Iter>
hash_multimap(_Iter _First, _Iter _Last)
: _Mybase(key_compare(), allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_multimap(_Iter _First, _Iter _Last,
const key_compare& _Traits)
: _Mybase(_Traits, allocator_type())
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	template<class _Iter>
hash_multimap(_Iter _First, _Iter _Last,
const key_compare& _Traits,
const allocator_type& _Al)
: _Mybase(_Traits, _Al)
{	
;
for (; _First != _Last; ++_First)
this->insert(*_First);
}
	iterator insert(const value_type& _Val)
{	
return (_Mybase::insert(_Val).first);
}
	iterator insert(const_iterator _Where, const value_type& _Val)
{	
return (_Mybase::insert(_Where, _Val));
}
	template<class _Iter>
void insert(_Iter _First, _Iter _Last)
{	
		this->_Mybase::insert(_First, _Last);
}
};
template<class _Kty,
class _Ty,
class _Tr,
class _Alloc> inline
void swap( ::stdext:: hash_multimap<_Kty, _Ty, _Tr, _Alloc>& _Left,
::stdext:: hash_multimap<_Kty, _Ty, _Tr, _Alloc>& _Right)
{	
_Left.swap(_Right);
}
}
namespace std {
	
template<class _Kty, class _Ty, class _Tr, class _Alloc>
class _Move_operation_category<::stdext:: hash_map<_Kty, _Ty, _Tr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
	
template<class _Kty, class _Ty, class _Tr, class _Alloc>
class _Move_operation_category<::stdext:: hash_multimap<_Kty, _Ty, _Tr, _Alloc> >
{
public:
typedef _Swap_move_tag _Move_cat;
};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
#pragma once
extern "C" {
#pragma pack(push,8)
		
		
		
typedef union
{	
unsigned short _Word[8];
float _Float;
double _Double;
long double _Long_double;
} _Dconst;
		
void __cdecl _Feraise(int);
		
__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) short __cdecl _Exp(double *, double, short);
__declspec(dllimport) double __cdecl _Sinh(double, double);
extern __declspec(dllimport)  _Dconst _Denorm, _Hugeval, _Inf,
_Nan, _Snan;
		
__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) short __cdecl _FExp(float *, float, short);
__declspec(dllimport) float __cdecl _FSinh(float, float);
extern __declspec(dllimport)  _Dconst _FDenorm, _FInf, _FNan, _FSnan;
		
__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);
extern __declspec(dllimport)  _Dconst _LDenorm, _LInf, _LNan, _LSnan;
}
#pragma pack(pop)
#pragma once
#pragma once
 
#pragma once
 
extern "C" {
 __declspec(dllimport) unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _NewValue,[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Mask);
#pragma warning(pop)
__declspec(dllimport) void __cdecl _set_controlfp([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _NewValue, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Mask);
__declspec(dllimport) errno_t __cdecl _controlfp_s([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] unsigned int *_CurrentState, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _NewValue, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Mask);
__declspec(dllimport) unsigned int __cdecl _statusfp(void);
__declspec(dllimport) void __cdecl _fpreset(void);
 __declspec(dllimport) void __cdecl _statusfp2([SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] unsigned int *_X86_status, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] unsigned int *_SSE2_status);
 __declspec(dllimport) unsigned int __cdecl _control87([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _NewValue,[SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Mask);
 __declspec(dllimport) int __cdecl __control87_2([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _NewValue, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] unsigned int _Mask,
[SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] unsigned int* _X86_cw, [SA_Pre(Null=SA_Maybe,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] unsigned int* _Sse2_cw);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) extern int * __cdecl __fpecode(void);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _scalb([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] long _Y);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _logb([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) double __cdecl _nextafter([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X, [SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _Y);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _finite([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _isnan([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
[returnvalue:SA_Post(MustCheck=SA_Yes)] __declspec(dllimport) int    __cdecl _fpclass([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] double _X);
 __declspec(dllimport) void __cdecl fpreset(void);
}
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
typedef enum
{	
denorm_indeterminate = -1,
denorm_absent = 0,
denorm_present = 1}
float_denorm_style;
		
typedef enum
{	
round_indeterminate = -1,
round_toward_zero = 0,
round_to_nearest = 1,
round_toward_infinity = 2,
round_toward_neg_infinity = 3}
float_round_style;
		
struct __declspec(dllimport) _Num_base
{	
static const float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
static const bool has_denorm_loss = (bool)(false);
static const bool has_infinity = (bool)(false);
static const bool has_quiet_NaN = (bool)(false);
static const bool has_signaling_NaN = (bool)(false);
static const bool is_bounded = (bool)(false);
static const bool is_exact = (bool)(false);
static const bool is_iec559 = (bool)(false);
static const bool is_integer = (bool)(false);
static const bool is_modulo = (bool)(false);
static const bool is_signed = (bool)(false);
static const bool is_specialized = (bool)(false);
static const bool tinyness_before = (bool)(false);
static const bool traps = (bool)(false);
static const float_round_style round_style = (float_round_style)(round_toward_zero);
static const int digits = (int)(0);
static const int digits10 = (int)(0);
static const int max_exponent = (int)(0);
static const int max_exponent10 = (int)(0);
static const int min_exponent = (int)(0);
static const int min_exponent10 = (int)(0);
static const int radix = (int)(0);
};
		
template<class _Ty>
class numeric_limits
: public _Num_base
{	
public:
static _Ty (__cdecl min)() throw ()
{	
return (_Ty(0));
}
	static _Ty (__cdecl max)() throw ()
{	
return (_Ty(0));
}
	static _Ty __cdecl epsilon() throw ()
{	
return (_Ty(0));
}
	static _Ty __cdecl round_error() throw ()
{	
return (_Ty(0));
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (_Ty(0));
}
	static _Ty __cdecl infinity() throw ()
{	
return (_Ty(0));
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (_Ty(0));
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (_Ty(0));
}
};
		
struct __declspec(dllimport) _Num_int_base
: public _Num_base
{	
static const bool is_bounded = (bool)(true);
static const bool is_exact = (bool)(true);
static const bool is_integer = (bool)(true);
static const bool is_modulo = (bool)(true);
static const bool is_specialized = (bool)(true);
static const int radix = (int)(2);
};
		
struct __declspec(dllimport) _Num_float_base
: public _Num_base
{	
static const float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
static const bool has_denorm_loss = (bool)(true);
static const bool has_infinity = (bool)(true);
static const bool has_quiet_NaN = (bool)(true);
static const bool has_signaling_NaN = (bool)(true);
static const bool is_bounded = (bool)(true);
static const bool is_exact = (bool)(false);
static const bool is_iec559 = (bool)(true);
static const bool is_integer = (bool)(false);
static const bool is_modulo = (bool)(false);
static const bool is_signed = (bool)(true);
static const bool is_specialized = (bool)(true);
static const bool tinyness_before = (bool)(true);
static const bool traps = (bool)(true);
static const float_round_style round_style = (float_round_style)(round_to_nearest);
static const int radix = (int)(2);
};
		
template<> class __declspec(dllimport) numeric_limits<char>
: public _Num_int_base
{	
public:
typedef char _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return ((-128));
}
	static _Ty (__cdecl max)() throw ()
{	
return (127);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)((-128) != 0);
static const int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
static const int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
};
 
template<> class __declspec(dllimport) numeric_limits<wchar_t>
: public _Num_int_base
{	
public:
typedef wchar_t _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return ((_Ty)0);
}
	static _Ty (__cdecl max)() throw ()
{	
return ((_Ty)0xffff);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(0 != 0);
static const int digits = (int)(8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0));
static const int digits10 = (int)((8 * sizeof (wchar_t) - (0 != 0 ? 1 : 0)) * 301L / 1000);
};
 
		
template<> class __declspec(dllimport) numeric_limits<_Bool>
: public _Num_int_base
{	
public:
typedef bool _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (false);
}
	static _Ty (__cdecl max)() throw ()
{	
return (true);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_modulo = (bool)(false);
static const bool is_signed = (bool)(false);
static const int digits = (int)(1);
static const int digits10 = (int)(0);
};
		
template<> class __declspec(dllimport) numeric_limits<signed char>
: public _Num_int_base
{	
public:
typedef signed char _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return ((-128));
}
	static _Ty (__cdecl max)() throw ()
{	
return (127);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(true);
static const int digits = (int)(8 - 1);
static const int digits10 = (int)((8 - 1) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<unsigned char>
: public _Num_int_base
{	
public:
typedef unsigned char _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (0);
}
	static _Ty (__cdecl max)() throw ()
{	
return (0xff);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(false);
static const int digits = (int)(8);
static const int digits10 = (int)((8) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<short>
: public _Num_int_base
{	
public:
typedef short _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return ((-32768));
}
	static _Ty (__cdecl max)() throw ()
{	
return (32767);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(true);
static const int digits = (int)(8 * sizeof (short) - 1);
static const int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<unsigned short>
: public _Num_int_base
{	
public:
typedef unsigned short _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (0);
}
	static _Ty (__cdecl max)() throw ()
{	
return (0xffff);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(false);
static const int digits = (int)(8 * sizeof (unsigned short));
static const int digits10 = (int)((8 * sizeof (unsigned short)) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<int>
: public _Num_int_base
{	
public:
typedef int _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return ((-2147483647 - 1));
}
	static _Ty (__cdecl max)() throw ()
{	
return (2147483647);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(true);
static const int digits = (int)(8 * sizeof (int) - 1);
static const int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<unsigned int>
: public _Num_int_base
{	
public:
typedef unsigned int _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (0);
}
	static _Ty (__cdecl max)() throw ()
{	
return (0xffffffff);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(false);
static const int digits = (int)(8 * sizeof (unsigned int));
static const int digits10 = (int)((8 * sizeof (unsigned int)) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<long>
: public _Num_int_base
{	
public:
typedef long _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return ((-2147483647L - 1));
}
	static _Ty (__cdecl max)() throw ()
{	
return (2147483647L);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(true);
static const int digits = (int)(8 * sizeof (long) - 1);
static const int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<unsigned long>
: public _Num_int_base
{	
public:
typedef unsigned long _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (0);
}
	static _Ty (__cdecl max)() throw ()
{	
return (0xffffffffUL);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(false);
static const int digits = (int)(8 * sizeof (unsigned long));
static const int digits10 = (int)((8 * sizeof (unsigned long)) * 301L / 1000);
};
 
template<> class __declspec(dllimport) numeric_limits<__int64>
: public _Num_int_base
{	
public:
typedef __int64 _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (-0x7fffffffffffffff - 1);
}
	static _Ty (__cdecl max)() throw ()
{	
return (0x7fffffffffffffff);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(true);
static const int digits = (int)(8 * sizeof (__int64) - 1);
static const int digits10 = (int)((8 * sizeof (__int64) - 1) * 301L / 1000);
};
		
template<> class __declspec(dllimport) numeric_limits<unsigned __int64>
: public _Num_int_base
{	
public:
typedef unsigned __int64 _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (0);
}
	static _Ty (__cdecl max)() throw ()
{	
return (0xffffffffffffffff);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (0);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (0);
}
	static _Ty __cdecl infinity() throw ()
{	
return (0);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (0);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (0);
}
	static const bool is_signed = (bool)(false);
static const int digits = (int)(8 * sizeof (unsigned __int64));
static const int digits10 = (int)((8 * sizeof (unsigned __int64)) * 301L / 1000);
};
 
		
template<> class __declspec(dllimport) numeric_limits<float>
: public _Num_float_base
{	
public:
typedef float _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (1.175494351e-38F);
}
	static _Ty (__cdecl max)() throw ()
{	
return (3.402823466e+38F);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (1.192092896e-07F);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0.5);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (::_FDenorm._Float);
}
	static _Ty __cdecl infinity() throw ()
{	
return (::_FInf._Float);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (::_FNan._Float);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (::_FSnan._Float);
}
	static const int digits = (int)(24);
static const int digits10 = (int)(6);
static const int max_exponent = (int)((int)128);
static const int max_exponent10 = (int)((int)38);
static const int min_exponent = (int)((int)(-125));
static const int min_exponent10 = (int)((int)(-37));
};
		
template<> class __declspec(dllimport) numeric_limits<double>
: public _Num_float_base
{	
public:
typedef double _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (2.2250738585072014e-308);
}
	static _Ty (__cdecl max)() throw ()
{	
return (1.7976931348623158e+308);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (2.2204460492503131e-016);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0.5);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (::_Denorm._Double);
}
	static _Ty __cdecl infinity() throw ()
{	
return (::_Inf._Double);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (::_Nan._Double);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (::_Snan._Double);
}
	static const int digits = (int)(53);
static const int digits10 = (int)(15);
static const int max_exponent = (int)((int)1024);
static const int max_exponent10 = (int)((int)308);
static const int min_exponent = (int)((int)(-1021));
static const int min_exponent10 = (int)((int)(-307));
};
		
template<> class __declspec(dllimport) numeric_limits<long double>
: public _Num_float_base
{	
public:
typedef long double _Ty;
	static _Ty (__cdecl min)() throw ()
{	
return (2.2250738585072014e-308);
}
	static _Ty (__cdecl max)() throw ()
{	
return (1.7976931348623158e+308);
}
	static _Ty __cdecl epsilon() throw ()
{	
return (2.2204460492503131e-016);
}
	static _Ty __cdecl round_error() throw ()
{	
return (0.5);
}
	static _Ty __cdecl denorm_min() throw ()
{	
return (::_LDenorm._Long_double);
}
	static _Ty __cdecl infinity() throw ()
{	
return (::_LInf._Long_double);
}
	static _Ty __cdecl quiet_NaN() throw ()
{	
return (::_LNan._Long_double);
}
	static _Ty __cdecl signaling_NaN() throw ()
{	
return (::_LSnan._Long_double);
}
	static const int digits = (int)(53);
static const int digits10 = (int)(15);
static const int max_exponent = (int)((int)1024);
static const int max_exponent10 = (int)((int)308);
static const int min_exponent = (int)((int)(-1021));
static const int min_exponent10 = (int)((int)(-307));
};
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4127)
namespace std {
extern __declspec(dllimport) _iobuf *__cdecl _Fiopen(const char *,
ios_base::openmode, int);
extern __declspec(dllimport) _iobuf *__cdecl _Fiopen(const wchar_t *,
ios_base::openmode, int);
extern __declspec(dllimport) _iobuf *__cdecl _Fiopen(const unsigned short *,
ios_base::openmode, int);
		
template<class _Elem> inline
bool _Fgetc(_Elem& _Ch, _iobuf *_File)
{	
return (fread(&_Ch, sizeof (_Elem), 1, _File) == 1);
}
template<> inline bool _Fgetc(char& _Byte, _iobuf *_File)
{	
int _Meta;
if ((_Meta = fgetc(_File)) == (-1))
return (false);
else
{	
_Byte = (char)_Meta;
return (true);
}
}
template<> inline bool _Fgetc(wchar_t& _Wchar, _iobuf *_File)
{	
wint_t _Meta;
if ((_Meta = ::fgetwc(_File)) == (wint_t)(0xFFFF))
return (false);
else
{	
_Wchar = (wchar_t)_Meta;
return (true);
}
}
		
template<class _Elem> inline
bool _Fputc(_Elem _Ch, _iobuf *_File)
{	
return (fwrite(&_Ch, 1, sizeof (_Elem), _File) == sizeof (_Elem));
}
template<> inline bool _Fputc(char _Byte, _iobuf *_File)
{	
return (fputc(_Byte, _File) != (-1));
}
template<> inline bool _Fputc(wchar_t _Wchar, _iobuf *_File)
{	
return (::fputwc(_Wchar, _File) != (wint_t)(0xFFFF));
}
		
template<class _Elem> inline
bool _Ungetc(const _Elem& _Ch, _iobuf *_File)
{	
return (false);
}
template<> inline bool _Ungetc(const char& _Byte, _iobuf *_File)
{	
return (ungetc((unsigned char)_Byte, _File) != (-1));
}
template<> inline bool _Ungetc(const signed char& _Byte, _iobuf *_File)
{	
return (ungetc((unsigned char)_Byte, _File) != (-1));
}
template<> inline bool _Ungetc(const unsigned char& _Byte, _iobuf *_File)
{	
return (ungetc(_Byte, _File) != (-1));
}
template<> inline bool _Ungetc(const wchar_t& _Wchar, _iobuf *_File)
{	
return (::ungetwc(_Wchar, _File) != (wint_t)(0xFFFF));
}
		
template<class _Elem,
class _Traits>
class basic_filebuf
: public basic_streambuf<_Elem, _Traits>
{	
public:
typedef basic_filebuf<_Elem, _Traits> _Myt;
typedef basic_streambuf<_Elem, _Traits> _Mysb;
typedef typename _Traits::state_type _Myst;
typedef codecvt<_Elem, char, typename _Traits::state_type> _Cvt;
	virtual  ~basic_filebuf()
{	
if (_Closef)
close();
}
	 basic_filebuf(_iobuf *_File = 0)
: _Mysb()
{	
_Init(_File, _Newfl);
}
	typedef _Elem char_type;
typedef _Traits traits_type;
typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	 basic_filebuf(_Uninitialized)
: _Mysb(_Noinit)
{	
}
	enum _Initfl
{	
_Newfl, _Openfl, _Closefl};
	bool  is_open() const
{	
return (_Myfile != 0);
}
	_Myt * open(const char *_Filename,
ios_base::openmode _Mode,
int _Prot = (int)ios_base::_Openprot)
{	
_iobuf *_File;
if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
return (0);	
		_Init(_File, _Openfl);
_Initcvt((_Cvt *)&use_facet<_Cvt >(_Mysb::getloc()));
return (this);	
}
	_Myt * open(const char *_Filename, ios_base::open_mode _Mode)
{	
return (open(_Filename, (ios_base::openmode)_Mode));
}
	_Myt * open(const wchar_t *_Filename,
ios_base::openmode _Mode,
int _Prot = (int)ios_base::_Openprot)
{	
_iobuf *_File;
if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
return (0);	
		_Init(_File, _Openfl);
_Initcvt((_Cvt *)&use_facet<_Cvt >(_Mysb::getloc()));
return (this);	
}
	_Myt * open(const wchar_t *_Filename, ios_base::open_mode _Mode)
{	
return (open(_Filename, (ios_base::openmode)_Mode));
}
	_Myt *  open(const unsigned short *_Filename,
ios_base::openmode _Mode,
int _Prot = (int)ios_base::_Openprot)
{	
_iobuf *_File;
if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
return (0);	
		_Init(_File, _Openfl);
_Initcvt((_Cvt *)&use_facet<_Cvt >(_Mysb::getloc()));
return (this);	
}
	_Myt *  open(const unsigned short *_Filename, ios_base::open_mode _Mode)
{	
return (open(_Filename, (ios_base::openmode)_Mode));
}
	_Myt * close()
{	
_Myt *_Ans = this;
if (_Myfile == 0)
_Ans = 0;
else
{	
if (!_Endwrite())
_Ans = 0;
if (fclose(_Myfile) != 0)
_Ans = 0;
}
_Init(0, _Closefl);
return (_Ans);
}
protected:
virtual int_type  overflow(int_type _Meta = _Traits::eof())
{	
if (_Traits::eq_int_type(_Traits::eof(), _Meta))
return (_Traits::not_eof(_Meta));	
else if (_Mysb::pptr() != 0
&& _Mysb::pptr() < _Mysb::epptr())
{	
*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
return (_Meta);
}
else if (_Myfile == 0)
return (_Traits::eof());	
else if (_Pcvt == 0)
return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
? _Meta : _Traits::eof());	
else
{	
const int _STRING_INC = 8;
const _Elem _Ch = _Traits::to_char_type(_Meta);
const _Elem *_Src;
char *_Dest;
			string _Str(_STRING_INC, '\0');
for (; ; )
switch (_Pcvt->out(_State,
&_Ch, &_Ch + 1, _Src,
&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
{	
case codecvt_base::partial:
case codecvt_base::ok:
{	
size_t _Count = _Dest - &*_Str.begin();
if (0 < _Count && _Count !=
fwrite(&*_Str.begin(), 1, _Count, _Myfile))
return (_Traits::eof());	
					_Wrotesome = true;	
if (_Src != &_Ch)
return (_Meta);	
					if (0 < _Count)
;
else if (_Str.size() < 4 * _STRING_INC)
_Str.append(_STRING_INC, '\0');	
else
return (_Traits::eof());	
break;
}
				case codecvt_base::noconv:
return (_Fputc(_Ch, _Myfile) ? _Meta
: _Traits::eof());	
				default:
return (_Traits::eof());	
}
}
}
	virtual int_type  pbackfail(int_type _Meta = _Traits::eof())
{	
if (_Mysb::gptr() != 0
&& _Mysb::eback() < _Mysb::gptr()
&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
_Meta)))
{	
_Mysb::_Gndec();
return (_Traits::not_eof(_Meta));
}
else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
return (_Traits::eof());	
else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
return (_Meta);	
#pragma warning(push)
#pragma warning(disable: 6237 6239)
		else if (1 < sizeof (_Elem) && _Mysb::gptr() != &_Mychar)
#pragma warning(pop)
{	
_Mychar = _Traits::to_char_type(_Meta);
_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
return (_Meta);
}
else
return (_Traits::eof());	
}
	virtual int_type  underflow()
{	
int_type _Meta;
if (_Mysb::gptr() != 0
&& _Mysb::gptr() < _Mysb::egptr())
return (_Traits::to_int_type(*_Mysb::gptr()));	
else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
return (_Meta);	
else
{	
pbackfail(_Meta);
return (_Meta);
}
}
	virtual int_type  uflow()
{	
if (_Mysb::gptr() != 0
&& _Mysb::gptr() < _Mysb::egptr())
return (_Traits::to_int_type(
*_Mysb::_Gninc()));	
else if (_Myfile == 0)
return (_Traits::eof());	
else if (_Pcvt == 0)
{	
_Elem _Ch;
return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
: _Traits::eof());
}
else
{	
string _Str;
			for (; ; )
{	
_Elem _Ch, *_Dest;
const char *_Src;
ptrdiff_t _Nleft;
int _Meta = fgetc(_Myfile);
				if (_Meta == (-1))
return (_Traits::eof());	
				_Str.append(1, (char)_Meta);	
switch (_Pcvt->in(_State,
&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
&_Ch, &_Ch + 1, _Dest))
{	
case codecvt_base::partial:
case codecvt_base::ok:
if (_Dest != &_Ch)
{	
_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
for (; 0 < _Nleft; )
ungetc(_Src[--_Nleft], _Myfile);
return (_Traits::to_int_type(_Ch));
}
else
_Str.erase((size_t)0,	
(size_t)(_Src - &*_Str.begin()));
break;
				case codecvt_base::noconv:
if (_Str.size() < sizeof (_Elem))
break;	
					::memcpy_s((&_Ch), (sizeof (_Elem)), (&*_Str.begin()), (sizeof (_Elem)));	
return (_Traits::to_int_type(_Ch));	
				default:
return (_Traits::eof());	
}
}
}
}
	virtual pos_type  seekoff(off_type _Off,
ios_base::seekdir _Way,
ios_base::openmode =
(ios_base::openmode)(ios_base::in | ios_base::out))
{	
fpos_t _Fileposition;
		if (_Mysb::gptr() == &_Mychar	
&& _Way == ios_base::cur	
&& _Pcvt == 0)	
_Off -= (off_type)sizeof (_Elem);	
		if (_Myfile == 0 || !_Endwrite()
|| (_Off != 0 || _Way != ios_base::cur)
&& fseek(_Myfile, (long)_Off, _Way) != 0
|| fgetpos(_Myfile, &_Fileposition) != 0)
return (pos_type(_BADOFF));	
		if (_Mysb::gptr() == &_Mychar)
_Mysb::setg(&_Mychar, &_Mychar + 1,
&_Mychar + 1);	
return (pos_type(_State, _Fileposition));	
}
	virtual pos_type  seekpos(pos_type _Pos,
ios_base::openmode =
(ios_base::openmode)(ios_base::in | ios_base::out))
{	
fpos_t _Fileposition = _Pos.seekpos();
off_type _Off = (off_type)_Pos - (off_type)((long)(_Fileposition));
		if (_Myfile == 0 || !_Endwrite()
|| fsetpos(_Myfile, &_Fileposition) != 0
|| _Off != 0 && fseek(_Myfile, (long)_Off, 1) != 0
|| fgetpos(_Myfile, &_Fileposition) != 0)
return (pos_type(_BADOFF));	
		_State = _Pos.state();
		if (_Mysb::gptr() == &_Mychar)
_Mysb::setg(&_Mychar, &_Mychar + 1,
&_Mychar + 1);	
return (pos_type(_State, _Fileposition));	
}
	virtual _Mysb * setbuf(_Elem *_Buffer, streamsize _Count)
{	
if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
_Buffer == 0 && _Count == 0 ? 0x0004 : 0x0000,
_Count * sizeof (_Elem)) != 0)
return (0);	
else
{	
_Init(_Myfile, _Openfl);
return (this);
}
}
	virtual int  sync()
{	
return (_Myfile == 0
|| _Traits::eq_int_type(_Traits::eof(), overflow())
|| 0 <= fflush(_Myfile) ? 0 : -1);
}
	virtual void  imbue(const locale& _Loc)
{	
_Initcvt((_Cvt *)&use_facet<_Cvt >(_Loc));
}
	void  _Init(_iobuf *_File, _Initfl _Which)
{	
static _Myst _Stinit;	
_Closef = _Which == _Openfl;
_Wrotesome = false;
		_Mysb::_Init();	
 
  
#pragma warning(push)
#pragma warning(disable: 6240)
		if (_File != 0 && sizeof (_Elem) == 1)
#pragma warning(pop)
{	
_Elem **_Pb = (_Elem **)&_File->_base;
_Elem **_Pn = (_Elem **)&_File->_ptr;
int *_Nr = (int *)&_File->_cnt;
int *_Nw = (int *)&_File->_cnt;
_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
}
		_Myfile = _File;
_State = _Stinit;
_Pcvt = 0;	
}
	bool  _Endwrite()
{	
if (_Pcvt == 0 || !_Wrotesome)
return (true);
else
{	
const int _STRING_INC = 8;
char *_Dest;
if (_Traits::eq_int_type(_Traits::eof(), overflow()))
return (false);
			string _Str(_STRING_INC, '\0');
for (; ; )
switch (_Pcvt->unshift(_State,
&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
{	
case codecvt_base::ok:
_Wrotesome = false;	
				case codecvt_base::partial:	
{	
size_t _Count = _Dest - &*_Str.begin();
if (0 < _Count && _Count !=
fwrite(&*_Str.begin(), 1, _Count, _Myfile))
return (false);	
if (!_Wrotesome)
return (true);
if (_Count == 0)
_Str.append(_STRING_INC, '\0');	
break;
}
				case codecvt_base::noconv:
return (true);	
				default:
return (false);	
}
}
}
	void  _Initcvt(_Cvt *_Newpcvt)
{	
if (_Newpcvt->always_noconv())
_Pcvt = 0;	
else
{	
_Pcvt = _Newpcvt;
_Mysb::_Init();	
}
}
private:
_Cvt *_Pcvt;	
_Elem _Mychar;	
bool _Wrotesome;	
typename _Traits::state_type _State;	
bool _Closef;	
_iobuf *_Myfile;	
};
 
template class __declspec(dllimport) basic_filebuf<char,
char_traits<char> >;
template class __declspec(dllimport) basic_filebuf<wchar_t,
char_traits<wchar_t> >;
 
		
template<class _Elem,
class _Traits>
class basic_ifstream
: public basic_istream<_Elem, _Traits>
{	
public:
typedef basic_ifstream<_Elem, _Traits> _Myt;
typedef basic_filebuf<_Elem, _Traits> _Myfb;
typedef basic_ios<_Elem, _Traits> _Myios;
	 basic_ifstream()
: basic_istream<_Elem, _Traits>(&_Filebuffer)
{	
}
	explicit  basic_ifstream(const char *_Filename,
ios_base::openmode _Mode = ios_base::in,
int _Prot = (int)ios_base::_Openprot)
: basic_istream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	explicit  basic_ifstream(const wchar_t *_Filename,
ios_base::openmode _Mode = ios_base::in,
int _Prot = (int)ios_base::_Openprot)
: basic_istream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
 
explicit  basic_ifstream(const unsigned short *_Filename,
ios_base::openmode _Mode = ios_base::in,
int _Prot = (int)ios_base::_Openprot)
: basic_istream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	explicit  basic_ifstream(_iobuf *_File)
: basic_istream<_Elem, _Traits>(&_Filebuffer),
_Filebuffer(_File)
{	
}
	void  open(const wchar_t *_Filename,
ios_base::openmode _Mode = ios_base::in,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const wchar_t *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
 
void  open(const unsigned short *_Filename,
ios_base::openmode _Mode = ios_base::in,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const unsigned short *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
	virtual  ~basic_ifstream()
{	
}
	_Myfb * rdbuf() const
{	
return ((_Myfb *)&_Filebuffer);
}
	bool  is_open() const
{	
return (_Filebuffer.is_open());
}
	void  open(const char *_Filename,
ios_base::openmode _Mode = ios_base::in,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const char *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
	void  close()
{	
if (_Filebuffer.close() == 0)
_Myios::setstate(ios_base::failbit);
}
private:
_Myfb _Filebuffer;	
};
 
template class __declspec(dllimport) basic_ifstream<char,
char_traits<char> >;
template class __declspec(dllimport) basic_ifstream<wchar_t,
char_traits<wchar_t> >;
 
		
template<class _Elem,
class _Traits>
class basic_ofstream
: public basic_ostream<_Elem, _Traits>
{	
public:
typedef basic_ofstream<_Elem, _Traits> _Myt;
typedef basic_filebuf<_Elem, _Traits> _Myfb;
typedef basic_ios<_Elem, _Traits> _Myios;
	 basic_ofstream()
: basic_ostream<_Elem, _Traits>(&_Filebuffer)
{	
}
	explicit  basic_ofstream(const char *_Filename,
ios_base::openmode _Mode = ios_base::out,
int _Prot = (int)ios_base::_Openprot)
: basic_ostream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	explicit  basic_ofstream(const wchar_t *_Filename,
ios_base::openmode _Mode = ios_base::out,
int _Prot = (int)ios_base::_Openprot)
: basic_ostream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
 
explicit  basic_ofstream(const unsigned short *_Filename,
ios_base::openmode _Mode = ios_base::out,
int _Prot = (int)ios_base::_Openprot)
: basic_ostream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	explicit  basic_ofstream(_iobuf *_File)
: basic_ostream<_Elem, _Traits>(&_Filebuffer),
_Filebuffer(_File)
{	
}
	virtual  ~basic_ofstream()
{	
}
	_Myfb * rdbuf() const
{	
return ((_Myfb *)&_Filebuffer);
}
	bool  is_open() const
{	
return (_Filebuffer.is_open());
}
	void  open(const wchar_t *_Filename,
ios_base::openmode _Mode = ios_base::out,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const wchar_t *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
 
void  open(const unsigned short *_Filename,
ios_base::openmode _Mode = ios_base::out,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const unsigned short *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
	void  open(const char *_Filename,
ios_base::openmode _Mode = ios_base::out,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const char *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
	void  close()
{	
if (_Filebuffer.close() == 0)
_Myios::setstate(ios_base::failbit);
}
private:
_Myfb _Filebuffer;	
};
 
template class __declspec(dllimport) basic_ofstream<char,
char_traits<char> >;
template class __declspec(dllimport) basic_ofstream<wchar_t,
char_traits<wchar_t> >;
 
		
template<class _Elem,
class _Traits>
class basic_fstream
: public basic_iostream<_Elem, _Traits>
{	
public:
typedef basic_fstream<_Elem, _Traits> _Myt;
typedef basic_ios<_Elem, _Traits> _Myios;
typedef _Elem char_type;
typedef _Traits traits_type;
typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	 basic_fstream()
: basic_iostream<_Elem, _Traits>(&_Filebuffer)
{	
}
	explicit  basic_fstream(const char *_Filename,
ios_base::openmode _Mode = ios_base::in | ios_base::out,
int _Prot = (int)ios_base::_Openprot)
: basic_iostream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	explicit  basic_fstream(const wchar_t *_Filename,
ios_base::openmode _Mode = ios_base::in | ios_base::out,
int _Prot = (int)ios_base::_Openprot)
: basic_iostream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
 
explicit  basic_fstream(const unsigned short *_Filename,
ios_base::openmode _Mode = ios_base::in | ios_base::out,
int _Prot = (int)ios_base::_Openprot)
: basic_iostream<_Elem, _Traits>(&_Filebuffer)
{	
if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	explicit  basic_fstream(_iobuf *_File)
: basic_iostream<_Elem, _Traits>(&_Filebuffer),
_Filebuffer(_File)
{	
}
	void  open(const wchar_t *_Filename,
ios_base::openmode _Mode = ios_base::in | ios_base::out,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const wchar_t *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
 
void  open(const unsigned short *_Filename,
ios_base::openmode _Mode = ios_base::in | ios_base::out,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const unsigned short *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
	virtual  ~basic_fstream()
{	
}
	basic_filebuf<_Elem, _Traits> * rdbuf() const
{	
return ((basic_filebuf<_Elem, _Traits> *)&_Filebuffer);
}
	bool  is_open() const
{	
return (_Filebuffer.is_open());
}
	void  open(const char *_Filename,
ios_base::openmode _Mode = ios_base::in | ios_base::out,
int _Prot = (int)ios_base::_Openprot)
{	
if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
_Myios::setstate(ios_base::failbit);
}
	void  open(const char *_Filename, ios_base::open_mode _Mode)
{	
open(_Filename, (ios_base::openmode)_Mode);
}
	void  close()
{	
if (_Filebuffer.close() == 0)
_Myios::setstate(ios_base::failbit);
}
private:
basic_filebuf<_Elem, _Traits> _Filebuffer;	
};
 
template class __declspec(dllimport) basic_fstream<char,
char_traits<char> >;
template class __declspec(dllimport) basic_fstream<wchar_t,
char_traits<wchar_t> >;
 
}
  #pragma warning(default: 4127)
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
 extern __declspec(dllimport) istream *_Ptr_cin;
extern __declspec(dllimport) ostream *_Ptr_cout;
extern __declspec(dllimport) ostream *_Ptr_cerr;
extern __declspec(dllimport) ostream *_Ptr_clog;
		
class __declspec(dllimport) _Winit {
public:
__thiscall _Winit();
__thiscall ~_Winit();
private:
static int _Init_cnt;
};
		
 extern __declspec(dllimport) wistream *_Ptr_wcin;
extern __declspec(dllimport) wostream *_Ptr_wcout;
extern __declspec(dllimport) wostream *_Ptr_wcerr;
extern __declspec(dllimport) wostream *_Ptr_wclog;
 extern __declspec(dllimport) istream cin;
extern __declspec(dllimport) ostream cout;
extern __declspec(dllimport) ostream cerr;
extern __declspec(dllimport) ostream clog;
 extern __declspec(dllimport) wistream wcin;
extern __declspec(dllimport) wostream wcout;
extern __declspec(dllimport) wostream wcerr;
extern __declspec(dllimport) wostream wclog;
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
		
template<class _Elem>
struct _Fillobj
{	
_Fillobj(_Elem _Ch)
: _Fill(_Ch)
{	
}
	_Elem _Fill;	
};
		
template<class _Elem> inline
_Fillobj<_Elem> __cdecl setfill(_Elem _Ch)
{	
return (_Fillobj<_Elem>(_Ch));
}
template<class _Elem,
class _Traits> inline
basic_istream<_Elem, _Traits>&
__cdecl operator>>(basic_istream<_Elem, _Traits>& _Istr,
const _Fillobj<_Elem>& _Manip)
{	
_Istr.fill(_Manip._Fill);
return (_Istr);
}
template<class _Elem,
class _Traits> inline
basic_ostream<_Elem, _Traits>&
__cdecl operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
const _Fillobj<_Elem>& _Manip)
{	
_Ostr.fill(_Manip._Fill);
return (_Ostr);
}
		
template<class _Arg>
struct _Smanip
{	
_Smanip(void (__cdecl *_Left)(ios_base&, _Arg), _Arg _Val)
: _Pfun(_Left), _Manarg(_Val)
{	
}
	void (__cdecl *_Pfun)(ios_base&, _Arg);	
_Arg _Manarg;	
};
template<class _Elem,
class _Traits,
class _Arg> inline
basic_istream<_Elem, _Traits>& __cdecl operator>>(
basic_istream<_Elem, _Traits>& _Istr, const _Smanip<_Arg>& _Manip)
{	
(*_Manip._Pfun)(_Istr, _Manip._Manarg);
return (_Istr);
}
template<class _Elem,
class _Traits,
class _Arg> inline
basic_ostream<_Elem, _Traits>& __cdecl operator<<(
basic_ostream<_Elem, _Traits>& _Ostr, const _Smanip<_Arg>& _Manip)
{	
(*_Manip._Pfun)(_Ostr, _Manip._Manarg);
return (_Ostr);
}
		
__declspec(dllimport) _Smanip<ios_base::fmtflags> __cdecl resetiosflags(ios_base::fmtflags);
__declspec(dllimport) _Smanip<ios_base::fmtflags> __cdecl setiosflags(ios_base::fmtflags);
__declspec(dllimport) _Smanip<int> __cdecl setbase(int);
__declspec(dllimport) _Smanip<streamsize> __cdecl setprecision(streamsize);
__declspec(dllimport) _Smanip<streamsize> __cdecl setw(streamsize);
}
 #pragma warning(pop)
#pragma pack(pop)
#pragma once
 #pragma pack(push,8)
#pragma warning(push,3)
namespace std {
  #pragma warning(disable:4251)
		
template<class _Elem,
class _Traits,
class _Alloc>
class basic_stringbuf
: public basic_streambuf<_Elem, _Traits>
{	
public:
typedef _Alloc allocator_type;
typedef basic_streambuf<_Elem, _Traits> _Mysb;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	explicit  basic_stringbuf(ios_base::openmode _Mode =
ios_base::in | ios_base::out)
{	
_Init(0, 0, _Getstate(_Mode));
}
	explicit  basic_stringbuf(const _Mystr& _Str,
ios_base::openmode _Mode = ios_base::in | ios_base::out)
{	
_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
}
	virtual  ~basic_stringbuf()
{	
_Tidy();
}
	enum
{	
_Allocated = 1,	
_Constant = 2,	
_Noread = 4,	
_Append = 8,	
_Atend = 16};	
typedef int _Strstate;
	typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
	_Mystr  str() const
{	
if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
{	
_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
return (_Str);
}
else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
{	
_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
return (_Str);
}
else
{	
_Mystr _Nul;
return (_Nul);
}
}
	void  str(const _Mystr& _Newstr)
{	
_Tidy();
_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
}
protected:
virtual int_type  overflow(int_type _Meta = _Traits::eof())
{	
if (_Mystate & _Append
&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
return (_Traits::not_eof(_Meta));	
else if (_Mysb::pptr() != 0
&& _Mysb::pptr() < _Mysb::epptr())
{	
*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
return (_Meta);
}
else if (_Mystate & _Constant)
return (_Traits::eof());	
else
{	
size_t _Oldsize = _Mysb::pptr() == 0
? 0 : _Mysb::epptr() - _Mysb::eback();
size_t _Newsize = _Oldsize;
size_t _Inc = _Newsize / 2 < _MINSIZE
? _MINSIZE : _Newsize / 2;	
_Elem *_Newptr = 0;
_Elem *_Oldptr = _Mysb::eback();
			while (0 < _Inc && 2147483647 - _Inc < _Newsize)
_Inc /= 2;	
if (0 < _Inc)
{	
_Newsize += _Inc;
_Newptr = _Al.allocate(_Newsize);
}
			if (0 < _Oldsize)
_Traits_helper::copy_s<_Traits>(_Newptr, _Newsize, _Oldptr, _Oldsize);
			if (_Oldsize == 0)
{	
_Seekhigh = _Newptr;
_Mysb::setp(_Newptr, _Newptr + _Newsize);
if (_Mystate & _Noread)
_Mysb::setg(_Newptr, 0, _Newptr);
else
_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
}
else
{	
_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
_Newptr + (_Mysb::pptr() - _Oldptr),
_Newptr + _Newsize);
if (_Mystate & _Noread)
_Mysb::setg(_Newptr, 0, _Newptr);
else
_Mysb::setg(_Newptr,
_Newptr + (_Mysb::gptr() - _Oldptr),
_Mysb::pptr() + 1);
}
			if (_Mystate & _Allocated)
_Al.deallocate(_Oldptr, _Oldsize);
_Mystate |= _Allocated;
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
return (_Meta);
}
}
	virtual int_type  pbackfail(int_type _Meta = _Traits::eof())
{	
if (_Mysb::gptr() == 0
|| _Mysb::gptr() <= _Mysb::eback()
|| !_Traits::eq_int_type(_Traits::eof(), _Meta)
&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
&& _Mystate & _Constant)
return (_Traits::eof());	
else
{	
_Mysb::gbump(-1);
if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
*_Mysb::gptr() = _Traits::to_char_type(_Meta);
return (_Traits::not_eof(_Meta));
}
}
	virtual int_type  underflow()
{	
if (_Mysb::gptr() == 0)
return (_Traits::eof());	
else if (_Mysb::gptr() < _Mysb::egptr())
return (_Traits::to_int_type(*_Mysb::gptr()));	
else if (_Mystate & _Noread || _Mysb::pptr() == 0
|| _Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr())
return (_Traits::eof());	
else
{	
if (_Seekhigh < _Mysb::pptr())
_Seekhigh = _Mysb::pptr();
_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
return (_Traits::to_int_type(*_Mysb::gptr()));
}
}
	virtual pos_type  seekoff(off_type _Off,
ios_base::seekdir _Way,
ios_base::openmode _Which = ios_base::in | ios_base::out)
{	
if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
_Seekhigh = _Mysb::pptr();	
		if (_Which & ios_base::in && _Mysb::gptr() != 0)
{	
if (_Way == ios_base::end)
_Off += (off_type)(_Seekhigh - _Mysb::eback());
else if (_Way == ios_base::cur
&& (_Which & ios_base::out) == 0)
_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
else if (_Way != ios_base::beg)
_Off = _BADOFF;
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
{	
_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
if (_Which & ios_base::out && _Mysb::pptr() != 0)
_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
_Mysb::epptr());	
}
else
_Off = _BADOFF;
}
else if (_Which & ios_base::out && _Mysb::pptr() != 0)
{	
if (_Way == ios_base::end)
_Off += (off_type)(_Seekhigh - _Mysb::eback());
else if (_Way == ios_base::cur)
_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
else if (_Way != ios_base::beg)
_Off = _BADOFF;
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
_Mysb::pbump((int)(_Mysb::eback()
- _Mysb::pptr() + _Off));	
else
_Off = _BADOFF;
}
else
_Off = _BADOFF;	
return (pos_type(_Off));
}
	virtual pos_type  seekpos(pos_type _Ptr,
ios_base::openmode _Mode = ios_base::in | ios_base::out)
{	
streamoff _Off = (streamoff)_Ptr;
if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
_Seekhigh = _Mysb::pptr();	
		if (_Off == _BADOFF)
;
else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
{	
if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
{	
_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
if (_Mode & ios_base::out && _Mysb::pptr() != 0)
_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
_Mysb::epptr());	
}
else
_Off = _BADOFF;
}
else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
{	
if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
_Mysb::pbump((int)(_Mysb::eback()
- _Mysb::pptr() + _Off));	
else
_Off = _BADOFF;
}
else
_Off = _BADOFF;
return (streampos(_Off));
}
	void  _Init(const _Elem *_Ptr,
size_t _Count, _Strstate _State)
{	
_Seekhigh = 0;
_Mystate = _State;
		if (_Count != 0
&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
{	
_Elem *_Pnew = _Al.allocate(_Count);
_Traits_helper::copy_s<_Traits>(_Pnew, _Count, _Ptr, _Count);
_Seekhigh = _Pnew + _Count;
			if (!(_Mystate & _Noread))
_Mysb::setg(_Pnew, _Pnew,
_Pnew + _Count);	
if (!(_Mystate & _Constant))
{	
_Mysb::setp(_Pnew,
(_Mystate & _Atend) ? _Pnew + _Count : _Pnew,
_Pnew + _Count);
if (_Mysb::gptr() == 0)
_Mysb::setg(_Pnew, 0, _Pnew);
}
_Mystate |= _Allocated;
}
}
	void  _Tidy()
{	
if (_Mystate & _Allocated)
_Al.deallocate(_Mysb::eback(),
(_Mysb::pptr() != 0 ? _Mysb::epptr()
: _Mysb::egptr()) - _Mysb::eback());
_Mysb::setg(0, 0, 0);
_Mysb::setp(0, 0);
_Seekhigh = 0;
_Mystate &= ~_Allocated;
}
private:
enum
{	
_MINSIZE = 32};
	_Strstate  _Getstate(ios_base::openmode _Mode)
{	
_Strstate _State = (_Strstate)0;
if (!(_Mode & ios_base::in))
_State |= _Noread;
if (!(_Mode & ios_base::out))
_State |= _Constant;
if (_Mode & ios_base::app)
_State |= _Append;
if (_Mode & ios_base::ate)
_State |= _Atend;
return (_State);
}
	_Elem *_Seekhigh;	
_Strstate _Mystate;	
allocator_type _Al;	
};
 
template class __declspec(dllimport) basic_stringbuf<char,
char_traits<char>, allocator<char> >;
template class __declspec(dllimport) basic_stringbuf<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> >;
 
		
template<class _Elem,
class _Traits,
class _Alloc>
class basic_istringstream
: public basic_istream<_Elem, _Traits>
{	
public:
typedef _Alloc allocator_type;
typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	explicit  basic_istringstream(ios_base::openmode _Mode = ios_base::in)
: basic_istream<_Elem, _Traits>(&_Stringbuffer),
_Stringbuffer(_Mode | ios_base::in)
{	
}
	explicit  basic_istringstream(const _Mystr& _Str,
ios_base::openmode _Mode = ios_base::in)
: basic_istream<_Elem, _Traits>(&_Stringbuffer),
_Stringbuffer(_Str, _Mode | ios_base::in)
{	
}
	virtual  ~basic_istringstream()
{	
}
	_Mysb * rdbuf() const
{	
return ((_Mysb *)&_Stringbuffer);
}
	_Mystr  str() const
{	
return (_Stringbuffer.str());
}
	void  str(const _Mystr& _Newstr)
{	
_Stringbuffer.str(_Newstr);
}
private:
_Mysb _Stringbuffer;	
};
 
template class __declspec(dllimport) basic_istringstream<char,
char_traits<char>, allocator<char> >;
template class __declspec(dllimport) basic_istringstream<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> >;
 
		
template<class _Elem,
class _Traits,
class _Alloc>
class basic_ostringstream
: public basic_ostream<_Elem, _Traits>
{	
public:
typedef _Alloc allocator_type;
typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	explicit  basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
: basic_ostream<_Elem, _Traits>(&_Stringbuffer),
_Stringbuffer(_Mode | ios_base::out)
{	
}
	explicit  basic_ostringstream(const _Mystr& _Str,
ios_base::openmode _Mode = ios_base::out)
: basic_ostream<_Elem, _Traits>(&_Stringbuffer),
_Stringbuffer(_Str, _Mode | ios_base::out)
{	
}
	virtual  ~basic_ostringstream()
{	
}
	_Mysb * rdbuf() const
{	
return ((_Mysb *)&_Stringbuffer);
}
	_Mystr  str() const
{	
return (_Stringbuffer.str());
}
	void  str(const _Mystr& _Newstr)
{	
_Stringbuffer.str(_Newstr);
}
private:
_Mysb _Stringbuffer;	
};
 
template class __declspec(dllimport) basic_ostringstream<char,
char_traits<char>, allocator<char> >;
template class __declspec(dllimport) basic_ostringstream<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> >;
 
		
template<class _Elem,
class _Traits,
class _Alloc>
class basic_stringstream
: public basic_iostream<_Elem, _Traits>
{	
public:
typedef _Elem char_type;
typedef _Traits traits_type;
typedef _Alloc allocator_type;
typedef typename _Traits::int_type int_type;
typedef typename _Traits::pos_type pos_type;
typedef typename _Traits::off_type off_type;
typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	explicit  basic_stringstream(ios_base::openmode _Mode =
ios_base::in | ios_base::out)
: basic_iostream<_Elem, _Traits>(&_Stringbuffer),
_Stringbuffer(_Mode)
{	
}
	explicit  basic_stringstream(const _Mystr& _Str,
ios_base::openmode _Mode = ios_base::in | ios_base::out)
: basic_iostream<_Elem, _Traits>(&_Stringbuffer),
_Stringbuffer(_Str, _Mode)
{	
}
	virtual  ~basic_stringstream()
{	
}
	basic_stringbuf<_Elem, _Traits, _Alloc> * rdbuf() const
{	
return ((basic_stringbuf<_Elem, _Traits, _Alloc> *)&_Stringbuffer);
}
	_Mystr  str() const
{	
return (_Stringbuffer.str());
}
	void  str(const _Mystr& _Newstr)
{	
_Stringbuffer.str(_Newstr);
}
private:
basic_stringbuf<_Elem, _Traits, _Alloc>
_Stringbuffer;	
};
 
template class __declspec(dllimport) basic_stringstream<char,
char_traits<char>, allocator<char> >;
template class __declspec(dllimport) basic_stringstream<wchar_t,
char_traits<wchar_t>, allocator<wchar_t> >;
 
}
 #pragma warning(pop)
#pragma pack(pop)
extern "C" {
#pragma once
#pragma once
 
#pragma pack(push,8)
extern "C" {
__declspec(dllimport) int __cdecl _fstat32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileDes, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat32 * _Stat);
__declspec(dllimport) int __cdecl _stat32([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat32 * _Stat);
__declspec(dllimport) int __cdecl _fstat32i64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileDes, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _fstat64i32([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileDes, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _fstat64([SA_Pre(Null=SA_No)] [SA_Pre(Deref=1,Valid=SA_Yes,Access=SA_Read)] int _FileDes, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat64 * _Stat);
__declspec(dllimport) int __cdecl _stat32i64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _stat64i32([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _stat64([SA_Pre(Null=SA_No,NullTerminated=SA_Yes)] [SA_Pre(Deref=1,Valid=SA_Yes)] [SA_Pre(Deref=1,Access=SA_Read)] const char * _Name, [SA_Pre(Null=SA_No,WritableElementsConst=1)] [SA_Pre(Deref=1,Valid=SA_No)] struct _stat64 * _Stat);
#pragma once
static __inline int __cdecl fstat(int _Desc, struct stat * _Stat)
{
typedef char __static_assert_t[ (sizeof(struct stat) == sizeof(struct _stat64i32)) ];
return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);
}
static __inline int __cdecl stat(const char * _Filename, struct stat * _Stat)
{
typedef char __static_assert_t[ (sizeof(struct stat) == sizeof(struct _stat64i32)) ];
return _stat64i32(_Filename,(struct _stat64i32 *)_Stat);
}
}
#pragma pack(pop)
}
namespace Ogre {
    
	
    class __declspec( dllexport ) MemoryManager
{
public:
static MemoryManager& instance(void);
        MemoryManager();
~MemoryManager();
        
        void *allocMem( const char *szFile, size_t uLine, size_t count ) throw ( );
        
        void *rllocMem( const char *szFile, size_t uLine, void *ptr , size_t count ) throw ( );
        
        void *cllocMem( const char *szFile, size_t uLine, size_t num, size_t size ) throw ( );
        
        void dllocMem( const char *szFile, size_t uLine, void *ptr ) throw ( );
};
}
namespace Ogre {
    
    
    
    
    
    
		
        typedef float Real;
    
    
    
    
    
    
    typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
    
    
	
		typedef std::string _StringBase;
	typedef _StringBase String;
	
	
		
		
		
		
		
		
        
		
		
		
		
	
    class Angle;
class Animation;
class AnimationState;
class AnimationStateSet;
class AnimationTrack;
class Archive;
class ArchiveFactory;
class ArchiveManager;
class AutoParamDataSource;
class AxisAlignedBox;
class AxisAlignedBoxSceneQuery;
class Billboard;
class BillboardChain;
class BillboardSet;
class Bone;
class Camera;
class Codec;
class ColourValue;
class ConfigDialog;
template <typename T> class Controller;
template <typename T> class ControllerFunction;
class ControllerManager;
template <typename T> class ControllerValue;
class Degree;
class DynLib;
class DynLibManager;
class EdgeData;
class EdgeListBuilder;
class Entity;
class ErrorDialog;
class ExternalTextureSourceManager;
class Factory;
class Font;
class FontPtr;
class FontManager;
struct FrameEvent;
class FrameListener;
class Frustum;
class GpuProgram;
class GpuProgramPtr;
class GpuProgramManager;
class GpuProgramUsage;
class HardwareIndexBuffer;
class HardwareOcclusionQuery;
class HardwareVertexBuffer;
class HardwarePixelBuffer;
class HardwarePixelBufferSharedPtr;
class HighLevelGpuProgram;
class HighLevelGpuProgramPtr;
class HighLevelGpuProgramManager;
class HighLevelGpuProgramFactory;
class IndexData;
class IntersectionSceneQuery;
class IntersectionSceneQueryListener;
class Image;
class KeyFrame;
class Light;
class Log;
class LogManager;
class ManualResourceLoader;
class ManualObject;
class Material;
class MaterialPtr;
class MaterialManager;
class MaterialScriptCompiler;
class Math;
class Matrix3;
class Matrix4;
class MemoryManager;
class Mesh;
class MeshPtr;
class MeshSerializer;
class MeshSerializerImpl;
class MeshManager;
class MovableObject;
class MovablePlane;
class Node;
class NodeAnimationTrack;
class NodeKeyFrame;
class NumericAnimationTrack;
class NumericKeyFrame;
class Overlay;
class OverlayContainer;
class OverlayElement;
class OverlayElementFactory;
class OverlayManager;
class Particle;
class ParticleAffector;
class ParticleAffectorFactory;
class ParticleEmitter;
class ParticleEmitterFactory;
class ParticleSystem;
class ParticleSystemManager;
class ParticleSystemRenderer;
class ParticleSystemRendererFactory;
class ParticleVisualData;
class Pass;
class PatchMesh;
class PixelBox;
class Plane;
class PlaneBoundedVolume;
class Plugin;
class Pose;
class ProgressiveMesh;
class Profile;
class Profiler;
class Quaternion;
class Radian;
class Ray;
class RaySceneQuery;
class RaySceneQueryListener;
class Renderable;
class RenderPriorityGroup;
class RenderQueue;
class RenderQueueGroup;
class RenderQueueInvocation;
class RenderQueueInvocationSequence;
class RenderQueueListener;
class RenderSystem;
class RenderSystemCapabilities;
class RenderTarget;
class RenderTargetListener;
class RenderTexture;
class MultiRenderTarget;
class RenderWindow;
class RenderOperation;
class Resource;
class ResourceBackgroundQueue;
class ResourceGroupManager;
class ResourceManager;
class RibbonTrail;
class Root;
class SceneManager;
class SceneManagerEnumerator;
class SceneNode;
class SceneQuery;
class SceneQueryListener;
class ScriptLoader;
class Serializer;
class ShadowCaster;
class ShadowRenderable;
class ShadowTextureManager;
class SimpleRenderable;
class SimpleSpline;
class Skeleton;
class SkeletonPtr;
class SkeletonInstance;
class SkeletonManager;
class Sphere;
class SphereSceneQuery;
class StaticGeometry;
class StringConverter;
class StringInterface;
class SubEntity;
class SubMesh;
class TagPoint;
class Technique;
class TempBlendedBufferInfo;
class ExternalTextureSource;
class TextureUnitState;
class Texture;
class TexturePtr;
class TextureFont;
class TextureManager;
class TransformKeyFrame;
class Timer;
class UserDefinedObject;
class Vector2;
class Vector3;
class Vector4;
class Viewport;
class VertexAnimationTrack;
class VertexBufferBinding;
class VertexData;
class VertexDeclaration;
class VertexMorphKeyFrame;
class WireBoundingBox;
class Compositor;
class CompositorManager;
class CompositorChain;
class CompositorInstance;
class CompositionTechnique;
class CompositionPass;
class CompositionTargetPass;
}
namespace Ogre {
    
class __declspec( dllexport ) StringUtil
{
public:
typedef std::ostringstream StrStreamType;
        
        static void trim( String& str, bool left = true, bool right = true );
        
		static std::vector< String > split( const String& str, const String& delims = "\t\n ", unsigned int maxSplits = 0);
        
        static void toLowerCase( String& str );
        
        static void toUpperCase( String& str );
        
        static bool startsWith(const String& str, const String& pattern, bool lowerCase = true);
        
        static bool endsWith(const String& str, const String& pattern, bool lowerCase = true);
        
        static String standardisePath( const String &init);
        
        static void splitFilename(const String& qualifiedName,
String& outBasename, String& outPath);
		
		static void splitFullFilename(const Ogre::String& qualifiedName, 
Ogre::String& outBasename, Ogre::String& outExtention, 
Ogre::String& outPath);
		
		static void splitBaseFilename(const Ogre::String& fullName, 
Ogre::String& outBasename, Ogre::String& outExtention);
        
        static bool match(const String& str, const String& pattern, bool caseSensitive = true);
        
static const String BLANK;
};
	typedef stdext::hash_compare< _StringBase, std::less< _StringBase > > _StringHash;
} 
namespace Ogre {
	
    template<class T> class SharedPtr {
protected:
T* pRep;
unsigned int* pUseCount;
public:
		
		SharedPtr() : pRep(0), pUseCount(0)
{
        }
        template< class Y>
explicit SharedPtr(Y* rep) : pRep(rep), pUseCount(new unsigned int(1))
{
			
}
SharedPtr(const SharedPtr& r)
: pRep(0), pUseCount(0)
{
            
            if(true)
{
			    
pRep = r.pRep;
pUseCount = r.pUseCount; 
			    if(pUseCount)
{
++(*pUseCount); 
}
}
}
SharedPtr& operator=(const SharedPtr& r) {
if (pRep == r.pRep)
return *this;
			
SharedPtr<T> tmp(r);
swap(tmp);
return *this;
}
		template< class Y>
SharedPtr(const SharedPtr<Y>& r)
: pRep(0), pUseCount(0)
{
            
if(true)
{
			    
pRep = r.getPointer();
pUseCount = r.useCountPointer();
			    if(pUseCount)
{
++(*pUseCount);
}
}
}
template< class Y>
SharedPtr& operator=(const SharedPtr<Y>& r) {
if (pRep == r.pRep)
return *this;
			
SharedPtr<T> tmp(r);
swap(tmp);
return *this;
}
virtual ~SharedPtr() {
release();
}
		inline T& operator*() const { ((void)0); return *pRep; }
inline T* operator->() const { ((void)0); return pRep; }
inline T* get() const { return pRep; }
		
		void bind(T* rep) {
((void)0);
			
pUseCount = new unsigned int(1);
pRep = rep;
}
		inline bool unique() const {  ((void)0); return *pUseCount == 1; }
inline unsigned int useCount() const {  ((void)0); return *pUseCount; }
inline unsigned int* useCountPointer() const { return pUseCount; }
		inline T* getPointer() const { return pRep; }
		inline bool isNull(void) const { return pRep == 0; }
        inline void setNull(void) { 
if (pRep)
{
				release();
pRep = 0;
pUseCount = 0;
}
}
    protected:
        inline void release(void)
{
bool destroyThis = false;
            
            if(true)
{
				
if (pUseCount)
{
if (--(*pUseCount) == 0) 
{
destroyThis = true;
}
}
}
if (destroyThis)
destroy();
            
}
        virtual void destroy(void)
{
            
            
delete pRep;
delete pUseCount;
        }
		virtual void swap(SharedPtr<T> &other) 
{
std::swap(pRep, other.pRep);
std::swap(pUseCount, other.pUseCount);
		}
};
	template<class T, class U> inline bool operator==(SharedPtr<T> const& a, SharedPtr<U> const& b)
{
return a.get() == b.get();
}
	template<class T, class U> inline bool operator!=(SharedPtr<T> const& a, SharedPtr<U> const& b)
{
return a.get() != b.get();
}
}
namespace Ogre {
	
	class __declspec( dllexport ) DataStream
{
protected:
		String mName;		
        size_t mSize;
	public:
        DataStream() : mSize(0) {}
		DataStream(const String& name) : mName(name), mSize(0) {}
		const String& getName(void) { return mName; }
virtual ~DataStream() {}
        template<typename T> DataStream& operator>>(T& val);
		virtual size_t read(void* buf, size_t count) = 0;
		virtual size_t readLine(char* buf, size_t maxCount, const String& delim = "\n");
	    
	    virtual String getLine( bool trimAfter = true );
	    
	    virtual String getAsString(void);
		
		virtual size_t skipLine(const String& delim = "\n");
		
		virtual void skip(long count) = 0;
		
	    virtual void seek( size_t pos ) = 0;
		
virtual size_t tell(void) const = 0;
		
	    virtual bool eof(void) const = 0;
		
        size_t size(void) const { return mSize; }
        
virtual void close(void) = 0;
	};
	
	typedef SharedPtr<DataStream> DataStreamPtr;
	
typedef std::list<DataStreamPtr> DataStreamList;
	typedef SharedPtr<DataStreamList> DataStreamListPtr;
	
	class __declspec( dllexport ) MemoryDataStream : public DataStream
{
protected:
	    uchar* mData;
	    uchar* mPos;
	    uchar* mEnd;
		bool mFreeOnClose;			
public:
		
		MemoryDataStream(void* pMem, size_t size, bool freeOnClose = false);
		
		MemoryDataStream(const String& name, void* pMem, size_t size, 
bool freeOnClose = false);
		
		MemoryDataStream(DataStream& sourceStream, 
bool freeOnClose = true);
		
		MemoryDataStream(DataStreamPtr& sourceStream, 
bool freeOnClose = true);
		
		MemoryDataStream(const String& name, DataStream& sourceStream, 
bool freeOnClose = true);
        
        MemoryDataStream(const String& name, const DataStreamPtr& sourceStream, 
bool freeOnClose = true);
        
		MemoryDataStream(size_t size, bool freeOnClose = true);
		MemoryDataStream(const String& name, size_t size, 
bool freeOnClose = true);
		~MemoryDataStream();
		
uchar* getPtr(void) { return mData; }
		
uchar* getCurrentPtr(void) { return mPos; }
		
		size_t read(void* buf, size_t count);
		size_t readLine(char* buf, size_t maxCount, const String& delim = "\n");
		
		size_t skipLine(const String& delim = "\n");
		
		void skip(long count);
		
	    void seek( size_t pos );
		
	    size_t tell(void) const;
		
	    bool eof(void) const;
        
        void close(void);
		
void setFreeOnClose(bool free) { mFreeOnClose = free; }
};
    
    typedef SharedPtr<MemoryDataStream> MemoryDataStreamPtr;
    
	class __declspec( dllexport ) FileStreamDataStream : public DataStream
{
protected:
		std::ifstream* mpStream;
bool mFreeOnClose;			
public:
		FileStreamDataStream(std::ifstream* s, 
bool freeOnClose = true);
		FileStreamDataStream(const String& name, 
std::ifstream* s, 
bool freeOnClose = true);
		
		FileStreamDataStream(const String& name, 
std::ifstream* s, 
size_t size, 
bool freeOnClose = true);
        ~FileStreamDataStream();
		
		size_t read(void* buf, size_t count);
        size_t readLine(char* buf, size_t maxCount, const String& delim = "\n");
		
		void skip(long count);
		
	    void seek( size_t pos );
		
		size_t tell(void) const;
		
	    bool eof(void) const;
        
        void close(void);
		
};
	
	class __declspec( dllexport ) FileHandleDataStream : public DataStream
{
protected:
FILE* mFileHandle;
public:
		FileHandleDataStream(FILE* handle);
		FileHandleDataStream(const String& name, FILE* handle);
~FileHandleDataStream();
		
		size_t read(void* buf, size_t count);
		
		void skip(long count);
		
	    void seek( size_t pos );
		
		size_t tell(void) const;
		
	    bool eof(void) const;
        
        void close(void);
	};
}
namespace Ogre {
    typedef std::vector<String> StringVector;
typedef SharedPtr<StringVector> StringVectorPtr;
}
namespace Ogre {
    
    struct FileInfo {
		
Archive* archive;
        String filename;
        String path;
        String basename;
        size_t compressedSize;
        size_t uncompressedSize;
};
    typedef std::vector<FileInfo> FileInfoList;
typedef SharedPtr<FileInfoList> FileInfoListPtr;
    
    class __declspec( dllexport ) Archive  
{
protected:
        String mName; 
        String mType;
public:
        
        Archive( const String& name, const String& archType )
: mName(name), mType(archType) {}
        
        virtual ~Archive() {}
		
const String& getName(void) const { return mName; }
        
virtual bool isCaseSensitive(void) const = 0;
        
        virtual void load() = 0;
        
        virtual void unload() = 0;
        
        virtual DataStreamPtr open(const String& filename) const = 0;
        
        virtual StringVectorPtr list(bool recursive = true, bool dirs = false) = 0;
        
        virtual FileInfoListPtr listFileInfo(bool recursive = true, bool dirs = false) = 0;
        
        virtual StringVectorPtr find(const String& pattern, bool recursive = true,
bool dirs = false) = 0;
        
virtual bool exists(const String& filename) = 0; 
        
        virtual FileInfoListPtr findFileInfo(const String& pattern, 
bool recursive = true, bool dirs = false) = 0;
        
const String& getType(void) const { return mType; }
    };
}
namespace Ogre
{
	class Radian
{
Real mRad;
	public:
explicit Radian ( Real r=0 ) : mRad(r) {}
Radian ( const Degree& d );
Radian& operator = ( const Real& f ) { mRad = f; return *this; }
Radian& operator = ( const Radian& r ) { mRad = r.mRad; return *this; }
Radian& operator = ( const Degree& d );
		Real valueDegrees() const; 
Real valueRadians() const { return mRad; }
Real valueAngleUnits() const;
        const Radian& operator + () const { return *this; }
Radian operator + ( const Radian& r ) const { return Radian ( mRad + r.mRad ); }
Radian operator + ( const Degree& d ) const;
Radian& operator += ( const Radian& r ) { mRad += r.mRad; return *this; }
Radian& operator += ( const Degree& d );
Radian operator - () const { return Radian(-mRad); }
Radian operator - ( const Radian& r ) const { return Radian ( mRad - r.mRad ); }
Radian operator - ( const Degree& d ) const;
Radian& operator -= ( const Radian& r ) { mRad -= r.mRad; return *this; }
Radian& operator -= ( const Degree& d );
Radian operator * ( Real f ) const { return Radian ( mRad * f ); }
Radian operator * ( const Radian& f ) const { return Radian ( mRad * f.mRad ); }
Radian& operator *= ( Real f ) { mRad *= f; return *this; }
Radian operator / ( Real f ) const { return Radian ( mRad / f ); }
Radian& operator /= ( Real f ) { mRad /= f; return *this; }
		bool operator <  ( const Radian& r ) const { return mRad <  r.mRad; }
bool operator <= ( const Radian& r ) const { return mRad <= r.mRad; }
bool operator == ( const Radian& r ) const { return mRad == r.mRad; }
bool operator != ( const Radian& r ) const { return mRad != r.mRad; }
bool operator >= ( const Radian& r ) const { return mRad >= r.mRad; }
bool operator >  ( const Radian& r ) const { return mRad >  r.mRad; }
};
    
	class Degree
{
Real mDeg; 
	public:
explicit Degree ( Real d=0 ) : mDeg(d) {}
Degree ( const Radian& r ) : mDeg(r.valueDegrees()) {}
Degree& operator = ( const Real& f ) { mDeg = f; return *this; }
Degree& operator = ( const Degree& d ) { mDeg = d.mDeg; return *this; }
Degree& operator = ( const Radian& r ) { mDeg = r.valueDegrees(); return *this; }
		Real valueDegrees() const { return mDeg; }
Real valueRadians() const; 
Real valueAngleUnits() const;
		const Degree& operator + () const { return *this; }
Degree operator + ( const Degree& d ) const { return Degree ( mDeg + d.mDeg ); }
Degree operator + ( const Radian& r ) const { return Degree ( mDeg + r.valueDegrees() ); }
Degree& operator += ( const Degree& d ) { mDeg += d.mDeg; return *this; }
Degree& operator += ( const Radian& r ) { mDeg += r.valueDegrees(); return *this; }
Degree operator - () const { return Degree(-mDeg); }
Degree operator - ( const Degree& d ) const { return Degree ( mDeg - d.mDeg ); }
Degree operator - ( const Radian& r ) const { return Degree ( mDeg - r.valueDegrees() ); }
Degree& operator -= ( const Degree& d ) { mDeg -= d.mDeg; return *this; }
Degree& operator -= ( const Radian& r ) { mDeg -= r.valueDegrees(); return *this; }
Degree operator * ( Real f ) const { return Degree ( mDeg * f ); }
Degree operator * ( const Degree& f ) const { return Degree ( mDeg * f.mDeg ); }
Degree& operator *= ( Real f ) { mDeg *= f; return *this; }
Degree operator / ( Real f ) const { return Degree ( mDeg / f ); }
Degree& operator /= ( Real f ) { mDeg /= f; return *this; }
		bool operator <  ( const Degree& d ) const { return mDeg <  d.mDeg; }
bool operator <= ( const Degree& d ) const { return mDeg <= d.mDeg; }
bool operator == ( const Degree& d ) const { return mDeg == d.mDeg; }
bool operator != ( const Degree& d ) const { return mDeg != d.mDeg; }
bool operator >= ( const Degree& d ) const { return mDeg >= d.mDeg; }
bool operator >  ( const Degree& d ) const { return mDeg >  d.mDeg; }
};
    
	class Angle
{
Real mAngle;
public:
explicit Angle ( Real angle ) : mAngle(angle) {}
operator Radian() const;
operator Degree() const;
};
	
	inline Radian::Radian ( const Degree& d ) : mRad(d.valueRadians()) {
}
inline Radian& Radian::operator = ( const Degree& d ) {
mRad = d.valueRadians(); return *this;
}
inline Radian Radian::operator + ( const Degree& d ) const {
return Radian ( mRad + d.valueRadians() );
}
inline Radian& Radian::operator += ( const Degree& d ) {
mRad += d.valueRadians();
return *this;
}
inline Radian Radian::operator - ( const Degree& d ) const {
return Radian ( mRad - d.valueRadians() );
}
inline Radian& Radian::operator -= ( const Degree& d ) {
mRad -= d.valueRadians();
return *this;
}
    
    class __declspec( dllexport ) Math 
{
public:
       enum AngleUnit
{
AU_DEGREE,
AU_RADIAN
};
    protected:
       static AngleUnit msAngleUnit;
        
static int mTrigTableSize;
        
static Real mTrigTableFactor;
static Real* mSinTable;
static Real* mTanTable;
        
        void buildTrigTables();
		static Real SinTable (Real fValue);
static Real TanTable (Real fValue);
public:
        Math(unsigned int trigTableSize = 4096);
        
        ~Math();
		static inline int IAbs (int iValue) { return ( iValue >= 0 ? iValue : -iValue ); }
static inline int ICeil (float fValue) { return int(ceil(fValue)); }
static inline int IFloor (float fValue) { return int(floor(fValue)); }
static int ISign (int iValue);
		static inline Real Abs (Real fValue) { return Real(fabs(fValue)); }
static inline Degree Abs (const Degree& dValue) { return Degree(fabs(dValue.valueDegrees())); }
static inline Radian Abs (const Radian& rValue) { return Radian(fabs(rValue.valueRadians())); }
static Radian ACos (Real fValue);
static Radian ASin (Real fValue);
static inline Radian ATan (Real fValue) { return Radian(atan(fValue)); }
static inline Radian ATan2 (Real fY, Real fX) { return Radian(atan2(fY,fX)); }
static inline Real Ceil (Real fValue) { return Real(ceil(fValue)); }
        
        static inline Real Cos (const Radian& fValue, bool useTables = false) {
return (!useTables) ? Real(cos(fValue.valueRadians())) : SinTable(fValue.valueRadians() + HALF_PI);
}
        static inline Real Cos (Real fValue, bool useTables = false) {
return (!useTables) ? Real(cos(fValue)) : SinTable(fValue + HALF_PI);
}
		static inline Real Exp (Real fValue) { return Real(exp(fValue)); }
		static inline Real Floor (Real fValue) { return Real(floor(fValue)); }
		static inline Real Log (Real fValue) { return Real(log(fValue)); }
		static inline Real Pow (Real fBase, Real fExponent) { return Real(pow(fBase,fExponent)); }
        static Real Sign (Real fValue);
static inline Radian Sign ( const Radian& rValue )
{
return Radian(Sign(rValue.valueRadians()));
}
static inline Degree Sign ( const Degree& dValue )
{
return Degree(Sign(dValue.valueDegrees()));
}
        
        static inline Real Sin (const Radian& fValue, bool useTables = false) {
return (!useTables) ? Real(sin(fValue.valueRadians())) : SinTable(fValue.valueRadians());
}
        static inline Real Sin (Real fValue, bool useTables = false) {
return (!useTables) ? Real(sin(fValue)) : SinTable(fValue);
}
		static inline Real Sqr (Real fValue) { return fValue*fValue; }
		static inline Real Sqrt (Real fValue) { return Real(sqrt(fValue)); }
        static inline Radian Sqrt (const Radian& fValue) { return Radian(sqrt(fValue.valueRadians())); }
        static inline Degree Sqrt (const Degree& fValue) { return Degree(sqrt(fValue.valueDegrees())); }
        
		static Real InvSqrt(Real fValue);
        static Real UnitRandom ();  
        static Real RangeRandom (Real fLow, Real fHigh);  
        static Real SymmetricRandom ();  
        
		static inline Real Tan (const Radian& fValue, bool useTables = false) {
return (!useTables) ? Real(tan(fValue.valueRadians())) : TanTable(fValue.valueRadians());
}
		static inline Real Tan (Real fValue, bool useTables = false) {
return (!useTables) ? Real(tan(fValue)) : TanTable(fValue);
}
		static inline Real DegreesToRadians(Real degrees) { return degrees * fDeg2Rad; }
static inline Real RadiansToDegrees(Real radians) { return radians * fRad2Deg; }
       
       static void setAngleUnit(AngleUnit unit);
       static AngleUnit getAngleUnit(void);
       
static Real AngleUnitsToRadians(Real units);
       static Real RadiansToAngleUnits(Real radians);
       static Real AngleUnitsToDegrees(Real units);
       static Real DegreesToAngleUnits(Real degrees);
       
        static bool pointInTri2D(const Vector2& p, const Vector2& a, 
const Vector2& b, const Vector2& c);
       
        static bool pointInTri3D(const Vector3& p, const Vector3& a, 
const Vector3& b, const Vector3& c, const Vector3& normal);
        static std::pair<bool, Real> intersects(const Ray& ray, const Plane& plane);
        
static std::pair<bool, Real> intersects(const Ray& ray, const Sphere& sphere, 
bool discardInside = true);
        
static std::pair<bool, Real> intersects(const Ray& ray, const AxisAlignedBox& box);
        
        static bool intersects(const Ray& ray, const AxisAlignedBox& box,
Real* d1, Real* d2);
        
        static std::pair<bool, Real> intersects(const Ray& ray, const Vector3& a,
const Vector3& b, const Vector3& c, const Vector3& normal,
bool positiveSide = true, bool negativeSide = true);
        
        static std::pair<bool, Real> intersects(const Ray& ray, const Vector3& a,
const Vector3& b, const Vector3& c,
bool positiveSide = true, bool negativeSide = true);
        
static bool intersects(const Sphere& sphere, const AxisAlignedBox& box);
        
static bool intersects(const Plane& plane, const AxisAlignedBox& box);
        
        static std::pair<bool, Real> intersects(
const Ray& ray, const std::vector<Plane>& planeList, 
bool normalIsOutside);
        static std::pair<bool, Real> intersects(
const Ray& ray, const std::list<Plane>& planeList, 
bool normalIsOutside);
        
        static bool intersects(const Sphere& sphere, const Plane& plane);
        
        static bool RealEqual(Real a, Real b,
Real tolerance = std::numeric_limits<Real>::epsilon());
        
static Vector3 calculateTangentSpaceVector(
const Vector3& position1, const Vector3& position2, const Vector3& position3,
Real u1, Real v1, Real u2, Real v2, Real u3, Real v3);
        
static Matrix4 buildReflectionMatrix(const Plane& p);
        static Vector4 calculateFaceNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3);
        static Vector3 calculateBasicFaceNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3);
        static Vector4 calculateFaceNormalWithoutNormalize(const Vector3& v1, const Vector3& v2, const Vector3& v3);
        static Vector3 calculateBasicFaceNormalWithoutNormalize(const Vector3& v1, const Vector3& v2, const Vector3& v3);
		
		static Real gaussianDistribution(Real x, Real offset = 0.0f, Real scale = 1.0f);
        static const Real POS_INFINITY;
static const Real NEG_INFINITY;
static const Real PI;
static const Real TWO_PI;
static const Real HALF_PI;
static const Real fDeg2Rad;
static const Real fRad2Deg;
    };
	
	inline Real Radian::valueDegrees() const
{
return Math::RadiansToDegrees ( mRad );
}
	inline Real Radian::valueAngleUnits() const
{
return Math::RadiansToAngleUnits ( mRad );
}
	inline Real Degree::valueRadians() const
{
return Math::DegreesToRadians ( mDeg );
}
	inline Real Degree::valueAngleUnits() const
{
return Math::DegreesToAngleUnits ( mDeg );
}
	inline Angle::operator Radian() const
{
return Radian(Math::AngleUnitsToRadians(mAngle));
}
	inline Angle::operator Degree() const
{
return Degree(Math::AngleUnitsToDegrees(mAngle));
}
	inline Radian operator * ( Real a, const Radian& b )
{
return Radian ( a * b.valueRadians() );
}
	inline Radian operator / ( Real a, const Radian& b )
{
return Radian ( a / b.valueRadians() );
}
	inline Degree operator * ( Real a, const Degree& b )
{
return Degree ( a * b.valueDegrees() );
}
	inline Degree operator / ( Real a, const Degree& b )
{
return Degree ( a / b.valueDegrees() );
}
}
namespace Ogre {
    
    class __declspec( dllexport ) Quaternion
{
public:
inline Quaternion (
Real fW = 1.0,
Real fX = 0.0, Real fY = 0.0, Real fZ = 0.0)
{
w = fW;
x = fX;
y = fY;
z = fZ;
}
inline Quaternion (const Quaternion& rkQ)
{
w = rkQ.w;
x = rkQ.x;
y = rkQ.y;
z = rkQ.z;
}
        inline Quaternion(const Matrix3& rot)
{
this->FromRotationMatrix(rot);
}
        inline Quaternion(const Radian& rfAngle, const Vector3& rkAxis)
{
this->FromAngleAxis(rfAngle, rkAxis);
}
        
inline Quaternion(const Vector3& xaxis, const Vector3& yaxis, const Vector3& zaxis)
{
this->FromAxes(xaxis, yaxis, zaxis);
}
        inline Quaternion(const Vector3* akAxis)
{
this->FromAxes(akAxis);
}
		inline Quaternion(Real* valptr)
{
memcpy(&w, valptr, sizeof(Real)*4);
}
		
inline Real operator [] ( const size_t i ) const
{
((void)0);
			return *(&w+i);
}
		
inline Real& operator [] ( const size_t i )
{
((void)0);
			return *(&w+i);
}
		
inline Real* ptr()
{
return &w;
}
		
inline const Real* ptr() const
{
return &w;
}
		void FromRotationMatrix (const Matrix3& kRot);
void ToRotationMatrix (Matrix3& kRot) const;
void FromAngleAxis (const Radian& rfAngle, const Vector3& rkAxis);
void ToAngleAxis (Radian& rfAngle, Vector3& rkAxis) const;
inline void ToAngleAxis (Degree& dAngle, Vector3& rkAxis) const {
Radian rAngle;
ToAngleAxis ( rAngle, rkAxis );
dAngle = rAngle;
}
        void FromAxes (const Vector3* akAxis);
void FromAxes (const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis);
void ToAxes (Vector3* akAxis) const;
void ToAxes (Vector3& xAxis, Vector3& yAxis, Vector3& zAxis) const;
        Vector3 xAxis(void) const;
        Vector3 yAxis(void) const;
        Vector3 zAxis(void) const;
        inline Quaternion& operator= (const Quaternion& rkQ)
{
w = rkQ.w;
x = rkQ.x;
y = rkQ.y;
z = rkQ.z;
return *this;
}
Quaternion operator+ (const Quaternion& rkQ) const;
Quaternion operator- (const Quaternion& rkQ) const;
Quaternion operator* (const Quaternion& rkQ) const;
Quaternion operator* (Real fScalar) const;
__declspec( dllexport ) friend Quaternion operator* (Real fScalar,
const Quaternion& rkQ);
Quaternion operator- () const;
inline bool operator== (const Quaternion& rhs) const
{
return (rhs.x == x) && (rhs.y == y) &&
(rhs.z == z) && (rhs.w == w);
}
inline bool operator!= (const Quaternion& rhs) const
{
return !operator==(rhs);
}
        Real Dot (const Quaternion& rkQ) const;  
Real Norm () const;  
        Real normalise(void); 
Quaternion Inverse () const;  
Quaternion UnitInverse () const;  
Quaternion Exp () const;
Quaternion Log () const;
        
Vector3 operator* (const Vector3& rkVector) const;
   		
		Radian getRoll(bool reprojectAxis = true) const;
		Radian getPitch(bool reprojectAxis = true) const;
		Radian getYaw(bool reprojectAxis = true) const;		
		bool equals(const Quaternion& rhs, const Radian& tolerance) const;
	    
static Quaternion Slerp (Real fT, const Quaternion& rkP,
const Quaternion& rkQ, bool shortestPath = false);
        static Quaternion SlerpExtraSpins (Real fT,
const Quaternion& rkP, const Quaternion& rkQ,
int iExtraSpins);
        
static void Intermediate (const Quaternion& rkQ0,
const Quaternion& rkQ1, const Quaternion& rkQ2,
Quaternion& rka, Quaternion& rkB);
        
static Quaternion Squad (Real fT, const Quaternion& rkP,
const Quaternion& rkA, const Quaternion& rkB,
const Quaternion& rkQ, bool shortestPath = false);
        
static Quaternion nlerp(Real fT, const Quaternion& rkP, 
const Quaternion& rkQ, bool shortestPath = false);
        
static const Real ms_fEpsilon;
        
static const Quaternion ZERO;
static const Quaternion IDENTITY;
		Real w, x, y, z;
        
        inline __declspec( dllexport ) friend std::ostream& operator <<
( std::ostream& o, const Quaternion& q )
{
o << "Quaternion(" << q.w << ", " << q.x << ", " << q.y << ", " << q.z << ")";
return o;
}
    };
}
namespace Ogre
{
    
    class __declspec( dllexport ) Vector3
{
public:
Real x, y, z;
    public:
inline Vector3()
{
}
        inline Vector3( const Real fX, const Real fY, const Real fZ )
: x( fX ), y( fY ), z( fZ )
{
}
        inline explicit Vector3( const Real afCoordinate[3] )
: x( afCoordinate[0] ),
y( afCoordinate[1] ),
z( afCoordinate[2] )
{
}
        inline explicit Vector3( const int afCoordinate[3] )
{
x = (Real)afCoordinate[0];
y = (Real)afCoordinate[1];
z = (Real)afCoordinate[2];
}
        inline explicit Vector3( Real* const r )
: x( r[0] ), y( r[1] ), z( r[2] )
{
}
        inline explicit Vector3( const Real scaler )
: x( scaler )
, y( scaler )
, z( scaler )
{
}
        inline Vector3( const Vector3& rkVector )
: x( rkVector.x ), y( rkVector.y ), z( rkVector.z )
{
}
		inline Real operator [] ( const size_t i ) const
{
((void)0);
            return *(&x+i);
}
		inline Real& operator [] ( const size_t i )
{
((void)0);
            return *(&x+i);
}
		inline Real* ptr()
{
return &x;
}
		inline const Real* ptr() const
{
return &x;
}
        
        inline Vector3& operator = ( const Vector3& rkVector )
{
x = rkVector.x;
y = rkVector.y;
z = rkVector.z;
            return *this;
}
        inline Vector3& operator = ( const Real fScaler )
{
x = fScaler;
y = fScaler;
z = fScaler;
            return *this;
}
        inline bool operator == ( const Vector3& rkVector ) const
{
return ( x == rkVector.x && y == rkVector.y && z == rkVector.z );
}
        inline bool operator != ( const Vector3& rkVector ) const
{
return ( x != rkVector.x || y != rkVector.y || z != rkVector.z );
}
        
inline Vector3 operator + ( const Vector3& rkVector ) const
{
return Vector3(
x + rkVector.x,
y + rkVector.y,
z + rkVector.z);
}
        inline Vector3 operator - ( const Vector3& rkVector ) const
{
return Vector3(
x - rkVector.x,
y - rkVector.y,
z - rkVector.z);
}
        inline Vector3 operator * ( const Real fScalar ) const
{
return Vector3(
x * fScalar,
y * fScalar,
z * fScalar);
}
        inline Vector3 operator * ( const Vector3& rhs) const
{
return Vector3(
x * rhs.x,
y * rhs.y,
z * rhs.z);
}
        inline Vector3 operator / ( const Real fScalar ) const
{
((void)0);
            Real fInv = 1.0 / fScalar;
            return Vector3(
x * fInv,
y * fInv,
z * fInv);
}
        inline Vector3 operator / ( const Vector3& rhs) const
{
return Vector3(
x / rhs.x,
y / rhs.y,
z / rhs.z);
}
        inline const Vector3& operator + () const
{
return *this;
}
        inline Vector3 operator - () const
{
return Vector3(-x, -y, -z);
}
        
inline friend Vector3 operator * ( const Real fScalar, const Vector3& rkVector )
{
return Vector3(
fScalar * rkVector.x,
fScalar * rkVector.y,
fScalar * rkVector.z);
}
        inline friend Vector3 operator / ( const Real fScalar, const Vector3& rkVector )
{
return Vector3(
fScalar / rkVector.x,
fScalar / rkVector.y,
fScalar / rkVector.z);
}
        inline friend Vector3 operator + (const Vector3& lhs, const Real rhs)
{
return Vector3(
lhs.x + rhs,
lhs.y + rhs,
lhs.z + rhs);
}
        inline friend Vector3 operator + (const Real lhs, const Vector3& rhs)
{
return Vector3(
lhs + rhs.x,
lhs + rhs.y,
lhs + rhs.z);
}
        inline friend Vector3 operator - (const Vector3& lhs, const Real rhs)
{
return Vector3(
lhs.x - rhs,
lhs.y - rhs,
lhs.z - rhs);
}
        inline friend Vector3 operator - (const Real lhs, const Vector3& rhs)
{
return Vector3(
lhs - rhs.x,
lhs - rhs.y,
lhs - rhs.z);
}
        
inline Vector3& operator += ( const Vector3& rkVector )
{
x += rkVector.x;
y += rkVector.y;
z += rkVector.z;
            return *this;
}
        inline Vector3& operator += ( const Real fScalar )
{
x += fScalar;
y += fScalar;
z += fScalar;
return *this;
}
        inline Vector3& operator -= ( const Vector3& rkVector )
{
x -= rkVector.x;
y -= rkVector.y;
z -= rkVector.z;
            return *this;
}
        inline Vector3& operator -= ( const Real fScalar )
{
x -= fScalar;
y -= fScalar;
z -= fScalar;
return *this;
}
        inline Vector3& operator *= ( const Real fScalar )
{
x *= fScalar;
y *= fScalar;
z *= fScalar;
return *this;
}
        inline Vector3& operator *= ( const Vector3& rkVector )
{
x *= rkVector.x;
y *= rkVector.y;
z *= rkVector.z;
            return *this;
}
        inline Vector3& operator /= ( const Real fScalar )
{
((void)0);
            Real fInv = 1.0 / fScalar;
            x *= fInv;
y *= fInv;
z *= fInv;
            return *this;
}
        inline Vector3& operator /= ( const Vector3& rkVector )
{
x /= rkVector.x;
y /= rkVector.y;
z /= rkVector.z;
            return *this;
}
        
        inline Real length () const
{
return Math::Sqrt( x * x + y * y + z * z );
}
        
        inline Real squaredLength () const
{
return x * x + y * y + z * z;
}
        
        inline Real distance(const Vector3& rhs) const
{
return (*this - rhs).length();
}
        
        inline Real squaredDistance(const Vector3& rhs) const
{
return (*this - rhs).squaredLength();
}
        
        inline Real dotProduct(const Vector3& vec) const
{
return x * vec.x + y * vec.y + z * vec.z;
}
        
        inline Real absDotProduct(const Vector3& vec) const
{
return Math::Abs(x * vec.x) + Math::Abs(y * vec.y) + Math::Abs(z * vec.z);
}
        
        inline Real normalise()
{
Real fLength = Math::Sqrt( x * x + y * y + z * z );
            
if ( fLength > 1e-08 )
{
Real fInvLength = 1.0 / fLength;
x *= fInvLength;
y *= fInvLength;
z *= fInvLength;
}
            return fLength;
}
        
        inline Vector3 crossProduct( const Vector3& rkVector ) const
{
return Vector3(
y * rkVector.z - z * rkVector.y,
z * rkVector.x - x * rkVector.z,
x * rkVector.y - y * rkVector.x);
}
        
        inline Vector3 midPoint( const Vector3& vec ) const
{
return Vector3(
( x + vec.x ) * 0.5,
( y + vec.y ) * 0.5,
( z + vec.z ) * 0.5 );
}
        
        inline bool operator < ( const Vector3& rhs ) const
{
if( x < rhs.x && y < rhs.y && z < rhs.z )
return true;
return false;
}
        
        inline bool operator > ( const Vector3& rhs ) const
{
if( x > rhs.x && y > rhs.y && z > rhs.z )
return true;
return false;
}
        
        inline void makeFloor( const Vector3& cmp )
{
if( cmp.x < x ) x = cmp.x;
if( cmp.y < y ) y = cmp.y;
if( cmp.z < z ) z = cmp.z;
}
        
        inline void makeCeil( const Vector3& cmp )
{
if( cmp.x > x ) x = cmp.x;
if( cmp.y > y ) y = cmp.y;
if( cmp.z > z ) z = cmp.z;
}
        
        inline Vector3 perpendicular(void) const
{
static const Real fSquareZero = 1e-06 * 1e-06;
            Vector3 perp = this->crossProduct( Vector3::UNIT_X );
            
if( perp.squaredLength() < fSquareZero )
{
                perp = this->crossProduct( Vector3::UNIT_Y );
}
perp.normalise();
            return perp;
}
        inline Vector3 randomDeviant(
const Radian& angle,
const Vector3& up = Vector3::ZERO ) const
{
Vector3 newUp;
            if (up == Vector3::ZERO)
{
                newUp = this->perpendicular();
}
else
{
newUp = up;
}
            
Quaternion q;
q.FromAngleAxis( Radian(Math::UnitRandom() * Math::TWO_PI), *this );
newUp = q * newUp;
            
q.FromAngleAxis( angle, newUp );
return q * (*this);
}
        
        Quaternion getRotationTo(const Vector3& dest,
const Vector3& fallbackAxis = Vector3::ZERO) const
{
            Quaternion q;
            Vector3 v0 = *this;
Vector3 v1 = dest;
v0.normalise();
v1.normalise();
            Real d = v0.dotProduct(v1);
            if (d >= 1.0f)
{
return Quaternion::IDENTITY;
}
if (d < (1e-6f - 1.0f))
{
if (fallbackAxis != Vector3::ZERO)
{
					q.FromAngleAxis(Radian(Math::PI), fallbackAxis);
}
else
{
					Vector3 axis = Vector3::UNIT_X.crossProduct(*this);
if (axis.isZeroLength()) 
axis = Vector3::UNIT_Y.crossProduct(*this);
axis.normalise();
q.FromAngleAxis(Radian(Math::PI), axis);
}
}
else
{
Real s = Math::Sqrt( (1+d)*2 );
Real invs = 1 / s;
				Vector3 c = v0.crossProduct(v1);
    	        q.x = c.x * invs;
q.y = c.y * invs;
q.z = c.z * invs;
q.w = s * 0.5;
q.normalise();
}
return q;
}
        
inline bool isZeroLength(void) const
{
Real sqlen = (x * x) + (y * y) + (z * z);
return (sqlen < (1e-06 * 1e-06));
        }
        
        inline Vector3 normalisedCopy(void) const
{
Vector3 ret = *this;
ret.normalise();
return ret;
}
        
        inline Vector3 reflect(const Vector3& normal) const
{
return Vector3( *this - ( 2 * this->dotProduct(normal) * normal ) );
}
		
		inline bool positionEquals(const Vector3& rhs, Real tolerance = 1e-03) const
{
return Math::RealEqual(x, rhs.x, tolerance) &&
Math::RealEqual(y, rhs.y, tolerance) &&
Math::RealEqual(z, rhs.z, tolerance);
		}
		
		inline bool positionCloses(const Vector3& rhs, Real tolerance = 1e-03f) const
{
return squaredDistance(rhs) <=
(squaredLength() + rhs.squaredLength()) * tolerance;
}
		
		inline bool directionEquals(const Vector3& rhs,
const Radian& tolerance) const
{
Real dot = dotProduct(rhs);
Radian angle = Math::ACos(dot);
			return Math::Abs(angle.valueRadians()) <= tolerance.valueRadians();
		}
        
static const Vector3 ZERO;
static const Vector3 UNIT_X;
static const Vector3 UNIT_Y;
static const Vector3 UNIT_Z;
static const Vector3 NEGATIVE_UNIT_X;
static const Vector3 NEGATIVE_UNIT_Y;
static const Vector3 NEGATIVE_UNIT_Z;
static const Vector3 UNIT_SCALE;
        
        inline __declspec( dllexport ) friend std::ostream& operator <<
( std::ostream& o, const Vector3& v )
{
o << "Vector3(" << v.x << ", " << v.y << ", " << v.z << ")";
return o;
}
};
}
namespace Ogre
{
    class __declspec( dllexport ) Matrix3
{
public:
		inline Matrix3 () {};
inline explicit Matrix3 (const Real arr[3][3])
{
memcpy(m,arr,9*sizeof(Real));
}
inline Matrix3 (const Matrix3& rkMatrix)
{
memcpy(m,rkMatrix.m,9*sizeof(Real));
}
Matrix3 (Real fEntry00, Real fEntry01, Real fEntry02,
Real fEntry10, Real fEntry11, Real fEntry12,
Real fEntry20, Real fEntry21, Real fEntry22)
{
m[0][0] = fEntry00;
m[0][1] = fEntry01;
m[0][2] = fEntry02;
m[1][0] = fEntry10;
m[1][1] = fEntry11;
m[1][2] = fEntry12;
m[2][0] = fEntry20;
m[2][1] = fEntry21;
m[2][2] = fEntry22;
}
        
inline Real* operator[] (size_t iRow) const
{
return (Real*)m[iRow];
}
        Vector3 GetColumn (size_t iCol) const;
void SetColumn(size_t iCol, const Vector3& vec);
void FromAxes(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis);
        
inline Matrix3& operator= (const Matrix3& rkMatrix)
{
memcpy(m,rkMatrix.m,9*sizeof(Real));
return *this;
}
bool operator== (const Matrix3& rkMatrix) const;
inline bool operator!= (const Matrix3& rkMatrix) const
{
return !operator==(rkMatrix);
}
        
Matrix3 operator+ (const Matrix3& rkMatrix) const;
Matrix3 operator- (const Matrix3& rkMatrix) const;
Matrix3 operator* (const Matrix3& rkMatrix) const;
Matrix3 operator- () const;
        
Vector3 operator* (const Vector3& rkVector) const;
        
__declspec( dllexport ) friend Vector3 operator* (const Vector3& rkVector,
const Matrix3& rkMatrix);
        
Matrix3 operator* (Real fScalar) const;
        
__declspec( dllexport ) friend Matrix3 operator* (Real fScalar, const Matrix3& rkMatrix);
        
Matrix3 Transpose () const;
bool Inverse (Matrix3& rkInverse, Real fTolerance = 1e-06) const;
Matrix3 Inverse (Real fTolerance = 1e-06) const;
Real Determinant () const;
        
void SingularValueDecomposition (Matrix3& rkL, Vector3& rkS,
Matrix3& rkR) const;
void SingularValueComposition (const Matrix3& rkL,
const Vector3& rkS, const Matrix3& rkR);
        
void Orthonormalize ();
        
void QDUDecomposition (Matrix3& rkQ, Vector3& rkD,
Vector3& rkU) const;
        Real SpectralNorm () const;
        
void ToAxisAngle (Vector3& rkAxis, Radian& rfAngle) const;
inline void ToAxisAngle (Vector3& rkAxis, Degree& rfAngle) const {
Radian r;
ToAxisAngle ( rkAxis, r );
rfAngle = r;
}
void FromAxisAngle (const Vector3& rkAxis, const Radian& fRadians);
        
        
bool ToEulerAnglesXYZ (Radian& rfYAngle, Radian& rfPAngle,
Radian& rfRAngle) const;
bool ToEulerAnglesXZY (Radian& rfYAngle, Radian& rfPAngle,
Radian& rfRAngle) const;
bool ToEulerAnglesYXZ (Radian& rfYAngle, Radian& rfPAngle,
Radian& rfRAngle) const;
bool ToEulerAnglesYZX (Radian& rfYAngle, Radian& rfPAngle,
Radian& rfRAngle) const;
bool ToEulerAnglesZXY (Radian& rfYAngle, Radian& rfPAngle,
Radian& rfRAngle) const;
bool ToEulerAnglesZYX (Radian& rfYAngle, Radian& rfPAngle,
Radian& rfRAngle) const;
void FromEulerAnglesXYZ (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
void FromEulerAnglesXZY (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
void FromEulerAnglesYXZ (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
void FromEulerAnglesYZX (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
void FromEulerAnglesZXY (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
void FromEulerAnglesZYX (const Radian& fYAngle, const Radian& fPAngle, const Radian& fRAngle);
        
void EigenSolveSymmetric (Real afEigenvalue[3],
Vector3 akEigenvector[3]) const;
        static void TensorProduct (const Vector3& rkU, const Vector3& rkV,
Matrix3& rkProduct);
        static const Real EPSILON;
static const Matrix3 ZERO;
static const Matrix3 IDENTITY;
    protected:
        void Tridiagonal (Real afDiag[3], Real afSubDiag[3]);
bool QLAlgorithm (Real afDiag[3], Real afSubDiag[3]);
        
static const Real ms_fSvdEpsilon;
static const unsigned int ms_iSvdMaxIterations;
static void Bidiagonalize (Matrix3& kA, Matrix3& kL,
Matrix3& kR);
static void GolubKahanStep (Matrix3& kA, Matrix3& kL,
Matrix3& kR);
        
static Real MaxCubicRoot (Real afCoeff[3]);
        Real m[3][3];
        
friend class Matrix4;
};
}
namespace Ogre
{
    
    class __declspec( dllexport ) Vector4
{
public:
Real x, y, z, w;
    public:
inline Vector4()
{
}
        inline Vector4( const Real fX, const Real fY, const Real fZ, const Real fW )
: x( fX ), y( fY ), z( fZ ), w( fW)
{
}
        inline explicit Vector4( const Real afCoordinate[4] )
: x( afCoordinate[0] ),
y( afCoordinate[1] ),
z( afCoordinate[2] ),
w( afCoordinate[3] )
{
}
        inline explicit Vector4( const int afCoordinate[4] )
{
x = (Real)afCoordinate[0];
y = (Real)afCoordinate[1];
z = (Real)afCoordinate[2];
w = (Real)afCoordinate[3];
}
        inline explicit Vector4( Real* const r )
: x( r[0] ), y( r[1] ), z( r[2] ), w( r[3] )
{
}
        inline explicit Vector4( const Real scaler )
: x( scaler )
, y( scaler )
, z( scaler )
, w( scaler )
{
}
        inline explicit Vector4(const Vector3& rhs)
: x(rhs.x), y(rhs.y), z(rhs.z), w(1.0f)
{
}
        inline Vector4( const Vector4& rkVector )
: x( rkVector.x ), y( rkVector.y ), z( rkVector.z ), w (rkVector.w)
{
}
		inline Real operator [] ( const size_t i ) const
{
((void)0);
            return *(&x+i);
}
		inline Real& operator [] ( const size_t i )
{
((void)0);
            return *(&x+i);
}
		
inline Real* ptr()
{
return &x;
}
		inline const Real* ptr() const
{
return &x;
}
        
        inline Vector4& operator = ( const Vector4& rkVector )
{
x = rkVector.x;
y = rkVector.y;
z = rkVector.z;
w = rkVector.w;
            return *this;
}
		inline Vector4& operator = ( const Real fScalar)
{
x = fScalar;
y = fScalar;
z = fScalar;
w = fScalar;
return *this;
}
        inline bool operator == ( const Vector4& rkVector ) const
{
return ( x == rkVector.x &&
y == rkVector.y &&
z == rkVector.z &&
w == rkVector.w );
}
        inline bool operator != ( const Vector4& rkVector ) const
{
return ( x != rkVector.x ||
y != rkVector.y ||
z != rkVector.z ||
w != rkVector.w );
}
        inline Vector4& operator = (const Vector3& rhs)
{
x = rhs.x;
y = rhs.y;
z = rhs.z;
w = 1.0f;
return *this;
}
        
inline Vector4 operator + ( const Vector4& rkVector ) const
{
return Vector4(
x + rkVector.x,
y + rkVector.y,
z + rkVector.z,
w + rkVector.w);
}
        inline Vector4 operator - ( const Vector4& rkVector ) const
{
return Vector4(
x - rkVector.x,
y - rkVector.y,
z - rkVector.z,
w - rkVector.w);
}
        inline Vector4 operator * ( const Real fScalar ) const
{
return Vector4(
x * fScalar,
y * fScalar,
z * fScalar,
w * fScalar);
}
        inline Vector4 operator * ( const Vector4& rhs) const
{
return Vector4(
rhs.x * x,
rhs.y * y,
rhs.z * z,
rhs.w * w);
}
        inline Vector4 operator / ( const Real fScalar ) const
{
((void)0);
            Real fInv = 1.0 / fScalar;
            return Vector4(
x * fInv,
y * fInv,
z * fInv,
w * fInv);
}
        inline Vector4 operator / ( const Vector4& rhs) const
{
return Vector4(
x / rhs.x,
y / rhs.y,
z / rhs.z,
w / rhs.w);
}
        inline const Vector4& operator + () const
{
return *this;
}
        inline Vector4 operator - () const
{
return Vector4(-x, -y, -z, -w);
}
        inline friend Vector4 operator * ( const Real fScalar, const Vector4& rkVector )
{
return Vector4(
fScalar * rkVector.x,
fScalar * rkVector.y,
fScalar * rkVector.z,
fScalar * rkVector.w);
}
        inline friend Vector4 operator / ( const Real fScalar, const Vector4& rkVector )
{
return Vector4(
fScalar / rkVector.x,
fScalar / rkVector.y,
fScalar / rkVector.z,
fScalar / rkVector.w);
}
        inline friend Vector4 operator + (const Vector4& lhs, const Real rhs)
{
return Vector4(
lhs.x + rhs,
lhs.y + rhs,
lhs.z + rhs,
lhs.w + rhs);
}
        inline friend Vector4 operator + (const Real lhs, const Vector4& rhs)
{
return Vector4(
lhs + rhs.x,
lhs + rhs.y,
lhs + rhs.z,
lhs + rhs.w);
}
        inline friend Vector4 operator - (const Vector4& lhs, Real rhs)
{
return Vector4(
lhs.x - rhs,
lhs.y - rhs,
lhs.z - rhs,
lhs.w - rhs);
}
        inline friend Vector4 operator - (const Real lhs, const Vector4& rhs)
{
return Vector4(
lhs - rhs.x,
lhs - rhs.y,
lhs - rhs.z,
lhs - rhs.w);
}
        
inline Vector4& operator += ( const Vector4& rkVector )
{
x += rkVector.x;
y += rkVector.y;
z += rkVector.z;
w += rkVector.w;
            return *this;
}
        inline Vector4& operator -= ( const Vector4& rkVector )
{
x -= rkVector.x;
y -= rkVector.y;
z -= rkVector.z;
w -= rkVector.w;
            return *this;
}
        inline Vector4& operator *= ( const Real fScalar )
{
x *= fScalar;
y *= fScalar;
z *= fScalar;
w *= fScalar;
return *this;
}
        inline Vector4& operator += ( const Real fScalar )
{
x += fScalar;
y += fScalar;
z += fScalar;
w += fScalar;
return *this;
}
        inline Vector4& operator -= ( const Real fScalar )
{
x -= fScalar;
y -= fScalar;
z -= fScalar;
w -= fScalar;
return *this;
}
        inline Vector4& operator *= ( const Vector4& rkVector )
{
x *= rkVector.x;
y *= rkVector.y;
z *= rkVector.z;
w *= rkVector.w;
            return *this;
}
        inline Vector4& operator /= ( const Real fScalar )
{
((void)0);
            Real fInv = 1.0 / fScalar;
            x *= fInv;
y *= fInv;
z *= fInv;
w *= fInv;
            return *this;
}
        inline Vector4& operator /= ( const Vector4& rkVector )
{
x /= rkVector.x;
y /= rkVector.y;
z /= rkVector.z;
w /= rkVector.w;
            return *this;
}
        
        inline Real dotProduct(const Vector4& vec) const
{
return x * vec.x + y * vec.y + z * vec.z + w * vec.w;
}
        inline __declspec( dllexport ) friend std::ostream& operator <<
( std::ostream& o, const Vector4& v )
{
o << "Vector4(" << v.x << ", " << v.y << ", " << v.z << ", " << v.w << ")";
return o;
}
        static const Vector4 ZERO;
};
}
namespace Ogre {
    
    class __declspec( dllexport ) Plane
{
public:
        Plane ();
Plane (const Plane& rhs);
        Plane (const Vector3& rkNormal, Real fConstant);
Plane (const Vector3& rkNormal, const Vector3& rkPoint);
Plane (const Vector3& rkPoint0, const Vector3& rkPoint1,
const Vector3& rkPoint2);
        
        enum Side
{
NO_SIDE,
POSITIVE_SIDE,
NEGATIVE_SIDE,
BOTH_SIDE
};
        Side getSide (const Vector3& rkPoint) const;
        
        Side getSide (const AxisAlignedBox& rkBox) const;
        
        Side getSide (const Vector3& centre, const Vector3& halfSize) const;
        
        Real getDistance (const Vector3& rkPoint) const;
        
void redefine(const Vector3& rkPoint0, const Vector3& rkPoint1,
const Vector3& rkPoint2);
		
void redefine(const Vector3& rkNormal, const Vector3& rkPoint);
		
		Vector3 projectVector(const Vector3& v) const;
        
        Real normalise(void);
		Vector3 normal;
Real d;
        
bool operator==(const Plane& rhs) const
{
return (rhs.d == d && rhs.normal == normal);
}
bool operator!=(const Plane& rhs) const
{
return (rhs.d != d && rhs.normal != normal);
}
        __declspec( dllexport ) friend std::ostream& operator<< (std::ostream& o, const Plane& p);
};
    typedef std::vector<Plane> PlaneList;
} 
namespace Ogre
{
    class __declspec( dllexport ) Matrix4
{
protected:
        union {
Real m[4][4];
Real _m[16];
};
public:
        inline Matrix4()
{
}
        inline Matrix4(
Real m00, Real m01, Real m02, Real m03,
Real m10, Real m11, Real m12, Real m13,
Real m20, Real m21, Real m22, Real m23,
Real m30, Real m31, Real m32, Real m33 )
{
m[0][0] = m00;
m[0][1] = m01;
m[0][2] = m02;
m[0][3] = m03;
m[1][0] = m10;
m[1][1] = m11;
m[1][2] = m12;
m[1][3] = m13;
m[2][0] = m20;
m[2][1] = m21;
m[2][2] = m22;
m[2][3] = m23;
m[3][0] = m30;
m[3][1] = m31;
m[3][2] = m32;
m[3][3] = m33;
}
        
        inline Matrix4(const Matrix3& m3x3)
{
operator=(IDENTITY);
operator=(m3x3);
}
        
        
inline Matrix4(const Quaternion& rot)
{
Matrix3 m3x3;
rot.ToRotationMatrix(m3x3);
operator=(IDENTITY);
operator=(m3x3);
}
        inline Real* operator [] ( size_t iRow )
{
((void)0);
return m[iRow];
}
        inline const Real *const operator [] ( size_t iRow ) const
{
((void)0);
return m[iRow];
}
        inline Matrix4 concatenate(const Matrix4 &m2) const
{
Matrix4 r;
r.m[0][0] = m[0][0] * m2.m[0][0] + m[0][1] * m2.m[1][0] + m[0][2] * m2.m[2][0] + m[0][3] * m2.m[3][0];
r.m[0][1] = m[0][0] * m2.m[0][1] + m[0][1] * m2.m[1][1] + m[0][2] * m2.m[2][1] + m[0][3] * m2.m[3][1];
r.m[0][2] = m[0][0] * m2.m[0][2] + m[0][1] * m2.m[1][2] + m[0][2] * m2.m[2][2] + m[0][3] * m2.m[3][2];
r.m[0][3] = m[0][0] * m2.m[0][3] + m[0][1] * m2.m[1][3] + m[0][2] * m2.m[2][3] + m[0][3] * m2.m[3][3];
            r.m[1][0] = m[1][0] * m2.m[0][0] + m[1][1] * m2.m[1][0] + m[1][2] * m2.m[2][0] + m[1][3] * m2.m[3][0];
r.m[1][1] = m[1][0] * m2.m[0][1] + m[1][1] * m2.m[1][1] + m[1][2] * m2.m[2][1] + m[1][3] * m2.m[3][1];
r.m[1][2] = m[1][0] * m2.m[0][2] + m[1][1] * m2.m[1][2] + m[1][2] * m2.m[2][2] + m[1][3] * m2.m[3][2];
r.m[1][3] = m[1][0] * m2.m[0][3] + m[1][1] * m2.m[1][3] + m[1][2] * m2.m[2][3] + m[1][3] * m2.m[3][3];
            r.m[2][0] = m[2][0] * m2.m[0][0] + m[2][1] * m2.m[1][0] + m[2][2] * m2.m[2][0] + m[2][3] * m2.m[3][0];
r.m[2][1] = m[2][0] * m2.m[0][1] + m[2][1] * m2.m[1][1] + m[2][2] * m2.m[2][1] + m[2][3] * m2.m[3][1];
r.m[2][2] = m[2][0] * m2.m[0][2] + m[2][1] * m2.m[1][2] + m[2][2] * m2.m[2][2] + m[2][3] * m2.m[3][2];
r.m[2][3] = m[2][0] * m2.m[0][3] + m[2][1] * m2.m[1][3] + m[2][2] * m2.m[2][3] + m[2][3] * m2.m[3][3];
            r.m[3][0] = m[3][0] * m2.m[0][0] + m[3][1] * m2.m[1][0] + m[3][2] * m2.m[2][0] + m[3][3] * m2.m[3][0];
r.m[3][1] = m[3][0] * m2.m[0][1] + m[3][1] * m2.m[1][1] + m[3][2] * m2.m[2][1] + m[3][3] * m2.m[3][1];
r.m[3][2] = m[3][0] * m2.m[0][2] + m[3][1] * m2.m[1][2] + m[3][2] * m2.m[2][2] + m[3][3] * m2.m[3][2];
r.m[3][3] = m[3][0] * m2.m[0][3] + m[3][1] * m2.m[1][3] + m[3][2] * m2.m[2][3] + m[3][3] * m2.m[3][3];
            return r;
}
        
        inline Matrix4 operator * ( const Matrix4 &m2 ) const
{
return concatenate( m2 );
}
        
        inline Vector3 operator * ( const Vector3 &v ) const
{
Vector3 r;
            Real fInvW = 1.0 / ( m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] );
            r.x = ( m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] ) * fInvW;
r.y = ( m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] ) * fInvW;
r.z = ( m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] ) * fInvW;
            return r;
}
inline Vector4 operator * (const Vector4& v) const
{
return Vector4(
m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w, 
m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w
);
}
inline Plane operator * (const Plane& p) const
{
Plane ret;
Matrix4 invTrans = inverse().transpose();
Vector4 v4( p.normal.x, p.normal.y, p.normal.z, p.d );
v4 = invTrans * v4;
ret.normal.x = v4.x; 
ret.normal.y = v4.y; 
ret.normal.z = v4.z;
ret.d = v4.w / ret.normal.normalise();
            return ret;
}
        
        inline Matrix4 operator + ( const Matrix4 &m2 ) const
{
Matrix4 r;
            r.m[0][0] = m[0][0] + m2.m[0][0];
r.m[0][1] = m[0][1] + m2.m[0][1];
r.m[0][2] = m[0][2] + m2.m[0][2];
r.m[0][3] = m[0][3] + m2.m[0][3];
            r.m[1][0] = m[1][0] + m2.m[1][0];
r.m[1][1] = m[1][1] + m2.m[1][1];
r.m[1][2] = m[1][2] + m2.m[1][2];
r.m[1][3] = m[1][3] + m2.m[1][3];
            r.m[2][0] = m[2][0] + m2.m[2][0];
r.m[2][1] = m[2][1] + m2.m[2][1];
r.m[2][2] = m[2][2] + m2.m[2][2];
r.m[2][3] = m[2][3] + m2.m[2][3];
            r.m[3][0] = m[3][0] + m2.m[3][0];
r.m[3][1] = m[3][1] + m2.m[3][1];
r.m[3][2] = m[3][2] + m2.m[3][2];
r.m[3][3] = m[3][3] + m2.m[3][3];
            return r;
}
        
        inline Matrix4 operator - ( const Matrix4 &m2 ) const
{
Matrix4 r;
r.m[0][0] = m[0][0] - m2.m[0][0];
r.m[0][1] = m[0][1] - m2.m[0][1];
r.m[0][2] = m[0][2] - m2.m[0][2];
r.m[0][3] = m[0][3] - m2.m[0][3];
            r.m[1][0] = m[1][0] - m2.m[1][0];
r.m[1][1] = m[1][1] - m2.m[1][1];
r.m[1][2] = m[1][2] - m2.m[1][2];
r.m[1][3] = m[1][3] - m2.m[1][3];
            r.m[2][0] = m[2][0] - m2.m[2][0];
r.m[2][1] = m[2][1] - m2.m[2][1];
r.m[2][2] = m[2][2] - m2.m[2][2];
r.m[2][3] = m[2][3] - m2.m[2][3];
            r.m[3][0] = m[3][0] - m2.m[3][0];
r.m[3][1] = m[3][1] - m2.m[3][1];
r.m[3][2] = m[3][2] - m2.m[3][2];
r.m[3][3] = m[3][3] - m2.m[3][3];
            return r;
}
        
        inline bool operator == ( const Matrix4& m2 ) const
{
if( 
m[0][0] != m2.m[0][0] || m[0][1] != m2.m[0][1] || m[0][2] != m2.m[0][2] || m[0][3] != m2.m[0][3] ||
m[1][0] != m2.m[1][0] || m[1][1] != m2.m[1][1] || m[1][2] != m2.m[1][2] || m[1][3] != m2.m[1][3] ||
m[2][0] != m2.m[2][0] || m[2][1] != m2.m[2][1] || m[2][2] != m2.m[2][2] || m[2][3] != m2.m[2][3] ||
m[3][0] != m2.m[3][0] || m[3][1] != m2.m[3][1] || m[3][2] != m2.m[3][2] || m[3][3] != m2.m[3][3] )
return false;
return true;
}
        
        inline bool operator != ( const Matrix4& m2 ) const
{
if( 
m[0][0] != m2.m[0][0] || m[0][1] != m2.m[0][1] || m[0][2] != m2.m[0][2] || m[0][3] != m2.m[0][3] ||
m[1][0] != m2.m[1][0] || m[1][1] != m2.m[1][1] || m[1][2] != m2.m[1][2] || m[1][3] != m2.m[1][3] ||
m[2][0] != m2.m[2][0] || m[2][1] != m2.m[2][1] || m[2][2] != m2.m[2][2] || m[2][3] != m2.m[2][3] ||
m[3][0] != m2.m[3][0] || m[3][1] != m2.m[3][1] || m[3][2] != m2.m[3][2] || m[3][3] != m2.m[3][3] )
return true;
return false;
}
        
        inline void operator = ( const Matrix3& mat3 )
{
m[0][0] = mat3.m[0][0]; m[0][1] = mat3.m[0][1]; m[0][2] = mat3.m[0][2];
m[1][0] = mat3.m[1][0]; m[1][1] = mat3.m[1][1]; m[1][2] = mat3.m[1][2];
m[2][0] = mat3.m[2][0]; m[2][1] = mat3.m[2][1]; m[2][2] = mat3.m[2][2];
}
        inline Matrix4 transpose(void) const
{
return Matrix4(m[0][0], m[1][0], m[2][0], m[3][0],
m[0][1], m[1][1], m[2][1], m[3][1],
m[0][2], m[1][2], m[2][2], m[3][2],
m[0][3], m[1][3], m[2][3], m[3][3]);
}
        
        
        inline void setTrans( const Vector3& v )
{
m[0][3] = v.x;
m[1][3] = v.y;
m[2][3] = v.z;
}
        
        inline Vector3 getTrans() const
{
return Vector3(m[0][3], m[1][3], m[2][3]);
}
        
        inline void makeTrans( const Vector3& v )
{
m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = v.x;
m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = v.y;
m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = v.z;
m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
}
        inline void makeTrans( Real tx, Real ty, Real tz )
{
m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = tx;
m[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = ty;
m[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = tz;
m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;
}
        
        inline static Matrix4 getTrans( const Vector3& v )
{
Matrix4 r;
            r.m[0][0] = 1.0; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = v.x;
r.m[1][0] = 0.0; r.m[1][1] = 1.0; r.m[1][2] = 0.0; r.m[1][3] = v.y;
r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = 1.0; r.m[2][3] = v.z;
r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;
            return r;
}
        
        inline static Matrix4 getTrans( Real t_x, Real t_y, Real t_z )
{
Matrix4 r;
            r.m[0][0] = 1.0; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = t_x;
r.m[1][0] = 0.0; r.m[1][1] = 1.0; r.m[1][2] = 0.0; r.m[1][3] = t_y;
r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = 1.0; r.m[2][3] = t_z;
r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;
            return r;
}
        
        
        inline void setScale( const Vector3& v )
{
m[0][0] = v.x;
m[1][1] = v.y;
m[2][2] = v.z;
}
        
        inline static Matrix4 getScale( const Vector3& v )
{
Matrix4 r;
r.m[0][0] = v.x; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = 0.0;
r.m[1][0] = 0.0; r.m[1][1] = v.y; r.m[1][2] = 0.0; r.m[1][3] = 0.0;
r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = v.z; r.m[2][3] = 0.0;
r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;
            return r;
}
        
        inline static Matrix4 getScale( Real s_x, Real s_y, Real s_z )
{
Matrix4 r;
r.m[0][0] = s_x; r.m[0][1] = 0.0; r.m[0][2] = 0.0; r.m[0][3] = 0.0;
r.m[1][0] = 0.0; r.m[1][1] = s_y; r.m[1][2] = 0.0; r.m[1][3] = 0.0;
r.m[2][0] = 0.0; r.m[2][1] = 0.0; r.m[2][2] = s_z; r.m[2][3] = 0.0;
r.m[3][0] = 0.0; r.m[3][1] = 0.0; r.m[3][2] = 0.0; r.m[3][3] = 1.0;
            return r;
}
        
        inline void extract3x3Matrix(Matrix3& m3x3) const
{
m3x3.m[0][0] = m[0][0];
m3x3.m[0][1] = m[0][1];
m3x3.m[0][2] = m[0][2];
m3x3.m[1][0] = m[1][0];
m3x3.m[1][1] = m[1][1];
m3x3.m[1][2] = m[1][2];
m3x3.m[2][0] = m[2][0];
m3x3.m[2][1] = m[2][1];
m3x3.m[2][2] = m[2][2];
        }
        
        inline Quaternion extractQuaternion() const
{
Matrix3 m3x3;
extract3x3Matrix(m3x3);
return Quaternion(m3x3);
}
        static const Matrix4 ZERO;
static const Matrix4 IDENTITY;
        static const Matrix4 CLIPSPACE2DTOIMAGESPACE;
        inline Matrix4 operator*(Real scalar) const
{
return Matrix4(
scalar*m[0][0], scalar*m[0][1], scalar*m[0][2], scalar*m[0][3],
scalar*m[1][0], scalar*m[1][1], scalar*m[1][2], scalar*m[1][3],
scalar*m[2][0], scalar*m[2][1], scalar*m[2][2], scalar*m[2][3],
scalar*m[3][0], scalar*m[3][1], scalar*m[3][2], scalar*m[3][3]);
}
        
        inline __declspec( dllexport ) friend std::ostream& operator <<
( std::ostream& o, const Matrix4& m )
{
o << "Matrix4(";
for (size_t i = 0; i < 4; ++i)
{
o << " row" << (unsigned)i << "{";
for(size_t j = 0; j < 4; ++j)
{
o << m[i][j] << " ";
}
o << "}";
}
o << ")";
return o;
}
		Matrix4 adjoint() const;
Real determinant() const;
Matrix4 inverse() const;
        
        void makeTransform(const Vector3& position, const Vector3& scale, const Quaternion& orientation);
        
        void makeInverseTransform(const Vector3& position, const Vector3& scale, const Quaternion& orientation);
        
        inline bool isAffine(void) const
{
return m[3][0] == 0 && m[3][1] == 0 && m[3][2] == 0 && m[3][3] == 1;
}
        
        Matrix4 inverseAffine(void) const;
        
        inline Matrix4 concatenateAffine(const Matrix4 &m2) const
{
((void)0);
            return Matrix4(
m[0][0] * m2.m[0][0] + m[0][1] * m2.m[1][0] + m[0][2] * m2.m[2][0],
m[0][0] * m2.m[0][1] + m[0][1] * m2.m[1][1] + m[0][2] * m2.m[2][1],
m[0][0] * m2.m[0][2] + m[0][1] * m2.m[1][2] + m[0][2] * m2.m[2][2],
m[0][0] * m2.m[0][3] + m[0][1] * m2.m[1][3] + m[0][2] * m2.m[2][3] + m[0][3],
                m[1][0] * m2.m[0][0] + m[1][1] * m2.m[1][0] + m[1][2] * m2.m[2][0],
m[1][0] * m2.m[0][1] + m[1][1] * m2.m[1][1] + m[1][2] * m2.m[2][1],
m[1][0] * m2.m[0][2] + m[1][1] * m2.m[1][2] + m[1][2] * m2.m[2][2],
m[1][0] * m2.m[0][3] + m[1][1] * m2.m[1][3] + m[1][2] * m2.m[2][3] + m[1][3],
                m[2][0] * m2.m[0][0] + m[2][1] * m2.m[1][0] + m[2][2] * m2.m[2][0],
m[2][0] * m2.m[0][1] + m[2][1] * m2.m[1][1] + m[2][2] * m2.m[2][1],
m[2][0] * m2.m[0][2] + m[2][1] * m2.m[1][2] + m[2][2] * m2.m[2][2],
m[2][0] * m2.m[0][3] + m[2][1] * m2.m[1][3] + m[2][2] * m2.m[2][3] + m[2][3],
                0, 0, 0, 1);
}
        
        inline Vector3 transformAffine(const Vector3& v) const
{
((void)0);
            return Vector3(
m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3], 
m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3],
m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3]);
}
        
        inline Vector4 transformAffine(const Vector4& v) const
{
((void)0);
            return Vector4(
m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w, 
m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
v.w);
}
};
    
    inline Vector4 operator * (const Vector4& v, const Matrix4& mat)
{
return Vector4(
v.x*mat[0][0] + v.y*mat[1][0] + v.z*mat[2][0] + v.w*mat[3][0],
v.x*mat[0][1] + v.y*mat[1][1] + v.z*mat[2][1] + v.w*mat[3][1],
v.x*mat[0][2] + v.y*mat[1][2] + v.z*mat[2][2] + v.w*mat[3][2],
v.x*mat[0][3] + v.y*mat[1][3] + v.z*mat[2][3] + v.w*mat[3][3]
);
}
}
namespace Ogre {
	
	class __declspec( dllexport ) AxisAlignedBox
{
protected:
enum Extent
{
EXTENT_NULL,
EXTENT_FINITE,
EXTENT_INFINITE
};
		Vector3 mMinimum;
Vector3 mMaximum;
Extent mExtent;
mutable Vector3* mpCorners;
	public:
		typedef enum {
FAR_LEFT_BOTTOM = 0,
FAR_LEFT_TOP = 1,
FAR_RIGHT_TOP = 2,
FAR_RIGHT_BOTTOM = 3,
NEAR_RIGHT_BOTTOM = 7,
NEAR_LEFT_BOTTOM = 6,
NEAR_LEFT_TOP = 5,
NEAR_RIGHT_TOP = 4
} CornerEnum;
inline AxisAlignedBox() : mpCorners(0)
{
			setMinimum( -0.5, -0.5, -0.5 );
setMaximum( 0.5, 0.5, 0.5 );
mExtent = EXTENT_NULL;
}
		inline AxisAlignedBox(const AxisAlignedBox & rkBox) : mpCorners(0)
{
if (rkBox.isNull())
setNull();
else if (rkBox.isInfinite())
setInfinite();
else
setExtents( rkBox.mMinimum, rkBox.mMaximum );
}
		inline AxisAlignedBox( const Vector3& min, const Vector3& max ) : mpCorners(0)
{
setExtents( min, max );
}
		inline AxisAlignedBox(
Real mx, Real my, Real mz,
Real Mx, Real My, Real Mz ) : mpCorners(0)
{
setExtents( mx, my, mz, Mx, My, Mz );
}
		AxisAlignedBox& operator=(const AxisAlignedBox& rhs)
{
			if (rhs.isNull())
setNull();
else if (rhs.isInfinite())
setInfinite();
else
setExtents(rhs.mMinimum, rhs.mMaximum);
			return *this;
}
		~AxisAlignedBox()
{
if (mpCorners)
delete [] mpCorners;
}
		
		inline const Vector3& getMinimum(void) const
{ 
return mMinimum; 
}
		
		inline Vector3& getMinimum(void)
{ 
return mMinimum; 
}
		
		inline const Vector3& getMaximum(void) const
{ 
return mMaximum;
}
		
		inline Vector3& getMaximum(void)
{ 
return mMaximum;
}
		
		inline void setMinimum( const Vector3& vec )
{
mExtent = EXTENT_FINITE;
mMinimum = vec;
}
		inline void setMinimum( Real x, Real y, Real z )
{
mExtent = EXTENT_FINITE;
mMinimum.x = x;
mMinimum.y = y;
mMinimum.z = z;
}
		
		inline void setMinimumX(Real x)
{
mMinimum.x = x;
}
		inline void setMinimumY(Real y)
{
mMinimum.y = y;
}
		inline void setMinimumZ(Real z)
{
mMinimum.z = z;
}
		
		inline void setMaximum( const Vector3& vec )
{
mExtent = EXTENT_FINITE;
mMaximum = vec;
}
		inline void setMaximum( Real x, Real y, Real z )
{
mExtent = EXTENT_FINITE;
mMaximum.x = x;
mMaximum.y = y;
mMaximum.z = z;
}
		
		inline void setMaximumX( Real x )
{
mMaximum.x = x;
}
		inline void setMaximumY( Real y )
{
mMaximum.y = y;
}
		inline void setMaximumZ( Real z )
{
mMaximum.z = z;
}
		
		inline void setExtents( const Vector3& min, const Vector3& max )
{
((void)0);
			mExtent = EXTENT_FINITE;
mMinimum = min;
mMaximum = max;
}
		inline void setExtents(
Real mx, Real my, Real mz,
Real Mx, Real My, Real Mz )
{
((void)0);
			mExtent = EXTENT_FINITE;
			mMinimum.x = mx;
mMinimum.y = my;
mMinimum.z = mz;
			mMaximum.x = Mx;
mMaximum.y = My;
mMaximum.z = Mz;
		}
		
		inline const Vector3* getAllCorners(void) const
{
((void)0);
			
			
			
			if (!mpCorners)
mpCorners = new Vector3[8];
			mpCorners[0] = mMinimum;
mpCorners[1].x = mMinimum.x; mpCorners[1].y = mMaximum.y; mpCorners[1].z = mMinimum.z;
mpCorners[2].x = mMaximum.x; mpCorners[2].y = mMaximum.y; mpCorners[2].z = mMinimum.z;
mpCorners[3].x = mMaximum.x; mpCorners[3].y = mMinimum.y; mpCorners[3].z = mMinimum.z;            
			mpCorners[4] = mMaximum;
mpCorners[5].x = mMinimum.x; mpCorners[5].y = mMaximum.y; mpCorners[5].z = mMaximum.z;
mpCorners[6].x = mMinimum.x; mpCorners[6].y = mMinimum.y; mpCorners[6].z = mMaximum.z;
mpCorners[7].x = mMaximum.x; mpCorners[7].y = mMinimum.y; mpCorners[7].z = mMaximum.z;
			return mpCorners;
}
		
		Vector3 getCorner(CornerEnum cornerToGet) const
{
switch(cornerToGet)
{
case FAR_LEFT_BOTTOM:
return mMinimum;
case FAR_LEFT_TOP:
return Vector3(mMinimum.x, mMaximum.y, mMinimum.z);
case FAR_RIGHT_TOP:
return Vector3(mMaximum.x, mMaximum.y, mMinimum.z);
case FAR_RIGHT_BOTTOM:
return Vector3(mMaximum.x, mMinimum.y, mMinimum.z);
case NEAR_RIGHT_BOTTOM:
return Vector3(mMaximum.x, mMinimum.y, mMaximum.z);
case NEAR_LEFT_BOTTOM:
return Vector3(mMinimum.x, mMinimum.y, mMaximum.z);
case NEAR_LEFT_TOP:
return Vector3(mMinimum.x, mMaximum.y, mMaximum.z);
case NEAR_RIGHT_TOP:
return mMaximum;
default:
return Vector3();
}
}
		__declspec( dllexport ) friend std::ostream& operator<<( std::ostream& o, const AxisAlignedBox aab )
{
switch (aab.mExtent)
{
case EXTENT_NULL:
o << "AxisAlignedBox(null)";
return o;
			case EXTENT_FINITE:
o << "AxisAlignedBox(min=" << aab.mMinimum << ", max=" << aab.mMaximum << ")";
return o;
			case EXTENT_INFINITE:
o << "AxisAlignedBox(infinite)";
return o;
			default: 
((void)0);
return o;
}
}
		
		void merge( const AxisAlignedBox& rhs )
{
			if ((rhs.mExtent == EXTENT_NULL) || (mExtent == EXTENT_INFINITE))
{
return;
}
			else if (rhs.mExtent == EXTENT_INFINITE)
{
mExtent = EXTENT_INFINITE;
}
			else if (mExtent == EXTENT_NULL)
{
setExtents(rhs.mMinimum, rhs.mMaximum);
}
			else
{
Vector3 min = mMinimum;
Vector3 max = mMaximum;
max.makeCeil(rhs.mMaximum);
min.makeFloor(rhs.mMinimum);
				setExtents(min, max);
}
		}
		
		inline void merge( const Vector3& point )
{
switch (mExtent)
{
case EXTENT_NULL: 
setExtents(point, point);
return;
			case EXTENT_FINITE:
mMaximum.makeCeil(point);
mMinimum.makeFloor(point);
return;
			case EXTENT_INFINITE: 
return;
}
			((void)0);
}
		
		inline void transform( const Matrix4& matrix )
{
			if( mExtent != EXTENT_FINITE )
return;
			Vector3 oldMin, oldMax, currentCorner;
			
oldMin = mMinimum;
oldMax = mMaximum;
			
setNull();
			
			
			
			
			currentCorner = oldMin;
merge( matrix * currentCorner );
			
currentCorner.z = oldMax.z;
merge( matrix * currentCorner );
			
currentCorner.y = oldMax.y;
merge( matrix * currentCorner );
			
currentCorner.z = oldMin.z;
merge( matrix * currentCorner );
			
currentCorner.x = oldMax.x;
merge( matrix * currentCorner );
			
currentCorner.z = oldMax.z;
merge( matrix * currentCorner );
			
currentCorner.y = oldMin.y;
merge( matrix * currentCorner );
			
currentCorner.z = oldMin.z;
merge( matrix * currentCorner ); 
}
		
		void transformAffine(const Matrix4& m)
{
((void)0);
			
if ( mExtent != EXTENT_FINITE )
return;
			Vector3 centre = getCenter();
Vector3 halfSize = getHalfSize();
			Vector3 newCentre = m.transformAffine(centre);
Vector3 newHalfSize(
Math::Abs(m[0][0]) * halfSize.x + Math::Abs(m[0][1]) * halfSize.y + Math::Abs(m[0][2]) * halfSize.z, 
Math::Abs(m[1][0]) * halfSize.x + Math::Abs(m[1][1]) * halfSize.y + Math::Abs(m[1][2]) * halfSize.z,
Math::Abs(m[2][0]) * halfSize.x + Math::Abs(m[2][1]) * halfSize.y + Math::Abs(m[2][2]) * halfSize.z);
			setExtents(newCentre - newHalfSize, newCentre + newHalfSize);
}
		
		inline void setNull()
{
mExtent = EXTENT_NULL;
}
		
		inline bool isNull(void) const
{
return (mExtent == EXTENT_NULL);
}
		
		bool isFinite(void) const
{
return (mExtent == EXTENT_FINITE);
}
		
		inline void setInfinite()
{
mExtent = EXTENT_INFINITE;
}
		
		bool isInfinite(void) const
{
return (mExtent == EXTENT_INFINITE);
}
		
inline bool intersects(const AxisAlignedBox& b2) const
{
			if (this->isNull() || b2.isNull())
return false;
			
if (this->isInfinite() || b2.isInfinite())
return true;
			
if (mMaximum.x < b2.mMinimum.x)
return false;
if (mMaximum.y < b2.mMinimum.y)
return false;
if (mMaximum.z < b2.mMinimum.z)
return false;
			if (mMinimum.x > b2.mMaximum.x)
return false;
if (mMinimum.y > b2.mMaximum.y)
return false;
if (mMinimum.z > b2.mMaximum.z)
return false;
			
return true;
		}
		
inline AxisAlignedBox intersection(const AxisAlignedBox& b2) const
{
if (this->isNull() || b2.isNull())
{
return AxisAlignedBox();
}
else if (this->isInfinite())
{
return b2;
}
else if (b2.isInfinite())
{
return *this;
}
			Vector3 intMin = mMinimum;
Vector3 intMax = mMaximum;
            intMin.makeCeil(b2.getMinimum());
intMax.makeFloor(b2.getMaximum());
            
if (intMin.x < intMax.x &&
intMin.y < intMax.y &&
intMin.z < intMax.z)
{
return AxisAlignedBox(intMin, intMax);
}
            return AxisAlignedBox();
}
		
Real volume(void) const
{
switch (mExtent)
{
case EXTENT_NULL:
return 0.0f;
			case EXTENT_FINITE:
{
Vector3 diff = mMaximum - mMinimum;
return diff.x * diff.y * diff.z;
}
			case EXTENT_INFINITE:
return Math::POS_INFINITY;
			default: 
((void)0);
return 0.0f;
}
}
		
inline void scale(const Vector3& s)
{
			if (mExtent != EXTENT_FINITE)
return;
			
Vector3 min = mMinimum * s;
Vector3 max = mMaximum * s;
setExtents(min, max);
}
		
bool intersects(const Sphere& s) const
{
return Math::intersects(s, *this); 
}
		bool intersects(const Plane& p) const
{
return Math::intersects(p, *this);
}
		bool intersects(const Vector3& v) const
{
switch (mExtent)
{
case EXTENT_NULL:
return false;
			case EXTENT_FINITE:
return(v.x >= mMinimum.x  &&  v.x <= mMaximum.x  && 
v.y >= mMinimum.y  &&  v.y <= mMaximum.y  && 
v.z >= mMinimum.z  &&  v.z <= mMaximum.z);
			case EXTENT_INFINITE:
return true;
			default: 
((void)0);
return false;
}
}
		Vector3 getCenter(void) const
{
((void)0);
			return Vector3(
(mMaximum.x + mMinimum.x) * 0.5,
(mMaximum.y + mMinimum.y) * 0.5,
(mMaximum.z + mMinimum.z) * 0.5);
}
		Vector3 getSize(void) const
{
switch (mExtent)
{
case EXTENT_NULL:
return Vector3::ZERO;
			case EXTENT_FINITE:
return mMaximum - mMinimum;
			case EXTENT_INFINITE:
return Vector3(
Math::POS_INFINITY,
Math::POS_INFINITY,
Math::POS_INFINITY);
			default: 
((void)0);
return Vector3::ZERO;
}
}
		Vector3 getHalfSize(void) const
{
switch (mExtent)
{
case EXTENT_NULL:
return Vector3::ZERO;
			case EXTENT_FINITE:
return (mMaximum - mMinimum) * 0.5;
			case EXTENT_INFINITE:
return Vector3(
Math::POS_INFINITY,
Math::POS_INFINITY,
Math::POS_INFINITY);
			default: 
((void)0);
return Vector3::ZERO;
}
}
        
        bool contains(const Vector3& v) const
{
if (isNull())
return false;
if (isInfinite())
return true;
            return mMinimum.x <= v.x && v.x <= mMaximum.x &&
mMinimum.y <= v.y && v.y <= mMaximum.y &&
mMinimum.z <= v.z && v.z <= mMaximum.z;
}
        
        bool contains(const AxisAlignedBox& other) const
{
if (other.isNull() || this->isInfinite())
return true;
            if (this->isNull() || other.isInfinite())
return false;
            return this->mMinimum.x <= other.mMinimum.x &&
this->mMinimum.y <= other.mMinimum.y &&
this->mMinimum.z <= other.mMinimum.z &&
other.mMaximum.x <= this->mMaximum.x &&
other.mMaximum.y <= this->mMaximum.y &&
other.mMaximum.z <= this->mMaximum.z;
}
        
        bool operator== (const AxisAlignedBox& rhs) const
{
if (this->mExtent != rhs.mExtent)
return false;
            if (!this->isFinite())
return true;
            return this->mMinimum == rhs.mMinimum &&
this->mMaximum == rhs.mMaximum;
}
        
        bool operator!= (const AxisAlignedBox& rhs) const
{
return !(*this == rhs);
}
	};
} 
namespace Ogre {
    
    class Bitwise {
public:
        static __forceinline unsigned int mostSignificantBitSet(unsigned int value)
{
unsigned int result = 0;
while (value != 0) {
++result;
value >>= 1;
}
return result-1;
}
        static __forceinline uint32 firstPO2From(uint32 n)
{
--n;            
n |= n >> 16;
n |= n >> 8;
n |= n >> 4;
n |= n >> 2;
n |= n >> 1;
++n;
return n;
}
        template<typename T>
static __forceinline bool isPO2(T n)
{
return (n & (n-1)) == 0;
}
		template<typename T>
static __forceinline unsigned int getBitShift(T mask)
{
if (mask == 0)
return 0;
			unsigned int result = 0;
while ((mask & 1) == 0) {
++result;
mask >>= 1;
}
return result;
}
        
		template<typename SrcT, typename DestT>
static inline DestT convertBitPattern(SrcT srcValue, SrcT srcBitMask, DestT destBitMask)
{
			srcValue = srcValue & srcBitMask;
			
const unsigned int srcBitShift = getBitShift(srcBitMask);
srcValue >>= srcBitShift;
			
const SrcT srcMax = srcBitMask >> srcBitShift;
			
const unsigned int destBitShift = getBitShift(destBitMask);
const DestT destMax = destBitMask >> destBitShift;
			
DestT destValue = (srcValue * destMax) / srcMax;
return (destValue << destBitShift);
}
        
        static inline unsigned int fixedToFixed(uint32 value, unsigned int n, unsigned int p) 
{
if(n > p) 
{
                value >>= n-p;
} 
else if(n < p)
{
                
if(value == 0)
value = 0;
else if(value == (static_cast<unsigned int>(1)<<n)-1)
value = (1<<p)-1;
else    value = value*(1<<p)/((1<<n)-1);
}
return value;    
}
        
        static inline unsigned int floatToFixed(const float value, const unsigned int bits)
{
if(value <= 0.0f) return 0;
else if (value >= 1.0f) return (1<<bits)-1;
else return (unsigned int)(value * (1<<bits));     
}
        
        static inline float fixedToFloat(unsigned value, unsigned int bits)
{
return (float)value/(float)((1<<bits)-1);
}
        
        static inline void intWrite(void *dest, const int n, const unsigned int value)
{
switch(n) {
case 1:
((uint8*)dest)[0] = (uint8)value;
break;
case 2:
((uint16*)dest)[0] = (uint16)value;
break;
case 3:
                    ((uint8*)dest)[2] = (uint8)((value >> 16) & 0xFF);
((uint8*)dest)[1] = (uint8)((value >> 8) & 0xFF);
((uint8*)dest)[0] = (uint8)(value & 0xFF);
                    break;
case 4:
((uint32*)dest)[0] = (uint32)value;                
break;                
}        
}
        static inline unsigned int intRead(const void *src, int n) {
switch(n) {
case 1:
return ((uint8*)src)[0];
case 2:
return ((uint16*)src)[0];
case 3:
                    return ((uint32)((uint8*)src)[0])|
((uint32)((uint8*)src)[1]<<8)|
((uint32)((uint8*)src)[2]<<16);
                case 4:
return ((uint32*)src)[0];
} 
return 0; 
}
        
        static inline uint16 floatToHalf(float i)
{
union { float f; uint32 i; } v;
v.f = i;
return floatToHalfI(v.i);
}
        static inline uint16 floatToHalfI(uint32 i)
{
register int s =  (i >> 16) & 0x00008000;
register int e = ((i >> 23) & 0x000000ff) - (127 - 15);
register int m =   i        & 0x007fffff;
            if (e <= 0)
{
if (e < -10)
{
return 0;
}
m = (m | 0x00800000) >> (1 - e);
                return s | (m >> 13);
}
else if (e == 0xff - (127 - 15))
{
if (m == 0) 
{
return s | 0x7c00;
} 
else    
{
m >>= 13;
return s | 0x7c00 | m | (m == 0);
}
}
else
{
if (e > 30) 
{
return s | 0x7c00;
}
                return s | (e << 10) | (m >> 13);
}
}
        
        static inline float halfToFloat(uint16 y)
{
union { float f; uint32 i; } v;
v.i = halfToFloatI(y);
return v.f;
}
        static inline uint32 halfToFloatI(uint16 y)
{
register int s = (y >> 15) & 0x00000001;
register int e = (y >> 10) & 0x0000001f;
register int m =  y        & 0x000003ff;
            if (e == 0)
{
if (m == 0) 
{
return s << 31;
}
else 
{
while (!(m & 0x00000400))
{
m <<= 1;
e -=  1;
}
                    e += 1;
m &= ~0x00000400;
}
}
else if (e == 31)
{
if (m == 0) 
{
return (s << 31) | 0x7f800000;
}
else 
{
return (s << 31) | 0x7f800000 | (m << 13);
}
}
            e = e + (127 - 15);
m = m << 13;
            return (s << 31) | (e << 23) | m;
}
    };
}
namespace Ogre {
    
    template <class T>
class VectorIterator
{
private:
typename T::iterator mCurrent;
typename T::iterator mEnd;
        VectorIterator() {};
public:
typedef typename T::value_type ValueType;
        
        VectorIterator(typename T::iterator start, typename T::iterator end)
: mCurrent(start), mEnd(end)
{
}
        
        explicit VectorIterator(T& c)
: mCurrent(c.begin()), mEnd(c.end())
{
}
        
bool hasMoreElements(void) const
{
return mCurrent != mEnd;
}
        
typename T::value_type getNext(void)
{
return *mCurrent++;
}
        typename T::value_type peekNext(void)
{
return *mCurrent;
}
        typename T::pointer peekNextPtr(void)
{
return &(*mCurrent);
}
        void moveNext(void)
{
++mCurrent;
}
    };
    
    template <class T>
class MapIterator
{
private:
typename T::iterator mCurrent;
typename T::iterator mEnd;
        MapIterator() {};
public:
typedef typename T::mapped_type MappedType;
typedef typename T::key_type KeyType;
        
        MapIterator(typename T::iterator start, typename T::iterator end)
: mCurrent(start), mEnd(end)
{
}
        
        explicit MapIterator(T& c)
: mCurrent(c.begin()), mEnd(c.end())
{
}
        
bool hasMoreElements(void) const
{
return mCurrent != mEnd;
}
        
typename T::mapped_type getNext(void)
{
return (mCurrent++)->second;
}
        typename T::mapped_type peekNextValue(void)
{
return mCurrent->second;
}
        typename T::key_type peekNextKey(void)
{
return mCurrent->first;
}
 	    MapIterator<T> & operator=( MapIterator<T> &rhs )
{
mCurrent = rhs.mCurrent;
mEnd = rhs.mEnd;
return *this;
}
        typename T::mapped_type* peekNextValuePtr(void)
{
return &(mCurrent->second);
}
        void moveNext(void)
{
++mCurrent;
}
    };
    template <class T>
class ConstVectorIterator
{
private:
mutable typename T::const_iterator mCurrent;
typename T::const_iterator mEnd;
        ConstVectorIterator() {};
public:
typedef typename T::value_type ValueType;
        
        ConstVectorIterator(typename T::const_iterator start, typename T::const_iterator end)
: mCurrent(start), mEnd(end)
{
}
        
        explicit ConstVectorIterator(const T& c)
: mCurrent(c.begin()), mEnd(c.end())
{
}
        
bool hasMoreElements(void) const
{
return mCurrent != mEnd;
}
        
typename T::value_type getNext(void)
{
return *mCurrent++;
}
        typename T::value_type peekNext(void) const
{
return *mCurrent;
}
        typename T::const_pointer peekNextPtr(void) const
{
return &(*mCurrent);
}
        void moveNext(void) const
{
++mCurrent;
}
    };
    
    template <class T>
class ConstMapIterator
{
private:
mutable typename T::const_iterator mCurrent;
typename T::const_iterator mEnd;
        ConstMapIterator() {};
public:
typedef typename T::mapped_type MappedType;
typedef typename T::key_type KeyType;
        
        ConstMapIterator(typename T::const_iterator start, typename T::const_iterator end)
: mCurrent(start), mEnd(end)
{
}
        
        explicit ConstMapIterator(const T& c)
: mCurrent(c.begin()), mEnd(c.end())
{
}
        
bool hasMoreElements(void) const
{
return mCurrent != mEnd;
}
        
typename T::mapped_type getNext(void)
{
return (mCurrent++)->second;
}
        typename T::mapped_type peekNextValue(void) const
{
return mCurrent->second;
}
        typename T::key_type peekNextKey(void) const
{
return mCurrent->first;
}
        ConstMapIterator<T> & operator=( ConstMapIterator<T> &rhs )
{
mCurrent = rhs.mCurrent;
mEnd = rhs.mEnd;
return *this;
}
        const typename T::mapped_type* peekNextValuePtr(void) const
{
return &(mCurrent->second);
}
        void moveNext(void) const
{
++mCurrent;
}
    };
}
namespace Ogre {
    
    enum RenderQueueGroupID
{
        RENDER_QUEUE_BACKGROUND = 0,
        RENDER_QUEUE_SKIES_EARLY = 5,
RENDER_QUEUE_1 = 10,
RENDER_QUEUE_2 = 20,
RENDER_QUEUE_WORLD_GEOMETRY_1 = 25,
RENDER_QUEUE_3 = 30,
RENDER_QUEUE_4 = 40,
        RENDER_QUEUE_MAIN = 50,
RENDER_QUEUE_6 = 60,
RENDER_QUEUE_7 = 70,
RENDER_QUEUE_WORLD_GEOMETRY_2 = 75,
RENDER_QUEUE_8 = 80,
RENDER_QUEUE_9 = 90,
        RENDER_QUEUE_SKIES_LATE = 95,
        RENDER_QUEUE_OVERLAY = 100, 
		RENDER_QUEUE_MAX = 105
};
    
    
    class __declspec( dllexport ) RenderQueue
{
public:
typedef std::map< uint8, RenderQueueGroup* > RenderQueueGroupMap;
        typedef MapIterator<RenderQueueGroupMap> QueueGroupIterator;
		class __declspec( dllexport ) RenderableListener
{
public:
RenderableListener() {}
virtual ~RenderableListener() {}
			
			virtual bool renderableQueued(Renderable* rend, uint8 groupID, 
ushort priority, Technique** ppTech) = 0;
};
protected:
RenderQueueGroupMap mGroups;
        uint8 mDefaultQueueGroup;
        ushort mDefaultRenderablePriority;
        bool mSplitPassesByLightingType;
bool mSplitNoShadowPasses;
bool mShadowCastersCannotBeReceivers;
		RenderableListener* mRenderableListener;
public:
RenderQueue();
virtual ~RenderQueue();
        
        void clear(bool destroyPassMaps = false);
		
		RenderQueueGroup* getQueueGroup(uint8 qid);
        
        void addRenderable(Renderable* pRend, uint8 groupID, ushort priority);
        
        void addRenderable(Renderable* pRend, uint8 groupId);
        
        void addRenderable(Renderable* pRend);
        
        uint8 getDefaultQueueGroup(void) const;
        
        void setDefaultRenderablePriority(ushort priority);
        
        ushort getDefaultRenderablePriority(void) const;
        
        void setDefaultQueueGroup(uint8 grp);
        
QueueGroupIterator _getQueueGroupIterator(void);
        void setSplitPassesByLightingType(bool split);
        void setSplitNoShadowPasses(bool split);
		void setShadowCastersCannotBeReceivers(bool ind);
		
		void setRenderableListener(RenderableListener* listener)
{ mRenderableListener = listener; }
		RenderableListener* getRenderableListener(void) const
{ return mRenderableListener; }
    };
}
namespace Ogre {
    
    class __declspec( dllexport ) Sphere
{
protected:
Real mRadius;
Vector3 mCenter;
public:
        Sphere() : mRadius(1.0), mCenter(Vector3::ZERO) {}
        Sphere(const Vector3& center, Real radius)
: mRadius(radius), mCenter(center) {}
        
Real getRadius(void) const { return mRadius; }
        
void setRadius(Real radius) { mRadius = radius; }
        
const Vector3& getCenter(void) const { return mCenter; }
        
void setCenter(const Vector3& center) { mCenter = center; }
		
bool intersects(const Sphere& s) const
{
return (s.mCenter - mCenter).squaredLength() <=
Math::Sqr(s.mRadius + mRadius);
}
		bool intersects(const AxisAlignedBox& box) const
{
return Math::intersects(*this, box);
}
		bool intersects(const Plane& plane) const
{
return Math::intersects(*this, plane);
}
		bool intersects(const Vector3& v) const
{
return ((v - mCenter).squaredLength() <= Math::Sqr(mRadius));
}
    };
}
namespace Ogre {
    
    enum CompareFunction
{
CMPF_ALWAYS_FAIL,
CMPF_ALWAYS_PASS,
CMPF_LESS,
CMPF_LESS_EQUAL,
CMPF_EQUAL,
CMPF_NOT_EQUAL,
CMPF_GREATER_EQUAL,
CMPF_GREATER
};
    
    enum TextureFilterOptions
{
        TFO_NONE,
        TFO_BILINEAR,
        TFO_TRILINEAR,
		TFO_ANISOTROPIC
};
    enum FilterType
{
        FT_MIN,
        FT_MAG,
        FT_MIP
};
    enum FilterOptions
{
        FO_NONE,
        FO_POINT,
        FO_LINEAR,
        FO_ANISOTROPIC
};
    
enum ShadeOptions
{
SO_FLAT,
SO_GOURAUD,
SO_PHONG
};
    
enum FogMode
{
        FOG_NONE,
        FOG_EXP,
        FOG_EXP2,
        FOG_LINEAR
};
    
    enum CullingMode
{
        CULL_NONE = 1,
        CULL_CLOCKWISE = 2,
        CULL_ANTICLOCKWISE = 3
};
    
    enum ManualCullingMode
{
        MANUAL_CULL_NONE = 1,
        MANUAL_CULL_BACK = 2,
        MANUAL_CULL_FRONT = 3
};
    
enum WaveformType
{
        WFT_SINE,
        WFT_TRIANGLE,
        WFT_SQUARE,
        WFT_SAWTOOTH,
        WFT_INVERSE_SAWTOOTH,
		
WFT_PWM
};
    
enum PolygonMode
{
        PM_POINTS = 1,
        PM_WIREFRAME = 2,
        PM_SOLID = 3
};
    
enum ShadowTechnique
{
        SHADOWTYPE_NONE = 0x00,
		SHADOWDETAILTYPE_ADDITIVE = 0x01,
		SHADOWDETAILTYPE_MODULATIVE = 0x02,
		SHADOWDETAILTYPE_INTEGRATED = 0x04,
		SHADOWDETAILTYPE_STENCIL = 0x10,
		SHADOWDETAILTYPE_TEXTURE = 0x20,
        
        SHADOWTYPE_STENCIL_MODULATIVE = 0x12,
        SHADOWTYPE_STENCIL_ADDITIVE = 0x11,
        SHADOWTYPE_TEXTURE_MODULATIVE = 0x22,
        
        SHADOWTYPE_TEXTURE_ADDITIVE = 0x21,
		
		SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED = 0x25,
		SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED = 0x26
};
    
typedef int TrackVertexColourType;
enum TrackVertexColourEnum {
TVC_NONE        = 0x0,
TVC_AMBIENT     = 0x1,        
TVC_DIFFUSE     = 0x2,
TVC_SPECULAR    = 0x4,
TVC_EMISSIVE    = 0x8
};
    
enum SortMode
{
        SM_DIRECTION,
        SM_DISTANCE
};
    
enum FrameBufferType {
FBT_COLOUR  = 0x1,
FBT_DEPTH   = 0x2,
FBT_STENCIL = 0x4
};
	
class Light;
typedef std::vector<Light*> LightList;
    typedef std::map<String, bool> UnaryOptionList;
typedef std::map<String, String> BinaryOptionList;
	
typedef std::map<String, String> NameValuePairList;
    
typedef std::map<String, String> AliasTextureNamePairList;
        template< typename T > struct TRect
{
T left, top, right, bottom;
TRect() {}
TRect( T const & l, T const & t, T const & r, T const & b )
: left( l ), top( t ), right( r ), bottom( b )
{
}
TRect( TRect const & o )
: left( o.left ), top( o.top ), right( o.right ), bottom( o.bottom )
{
}
TRect & operator=( TRect const & o )
{
left = o.left;
top = o.top;
right = o.right;
bottom = o.bottom;
return *this;
}
T width() const
{
return right - left;
}
T height() const
{
return bottom - top;
}
};
        
        typedef TRect<float> FloatRect;
        
        typedef TRect< long > Rect;
        
        struct Box
{
size_t left, top, right, bottom, front, back;
            Box()
{
}
            Box( size_t l, size_t t, size_t r, size_t b ):
left(l),
top(t),   
right(r),
bottom(b),
front(0),
back(1)
{
((void)0);
}
            Box( size_t l, size_t t, size_t ff, size_t r, size_t b, size_t bb ):
left(l),
top(t),   
right(r),
bottom(b),
front(ff),
back(bb)
{
((void)0);
}
            
bool contains(const Box &def) const
{
return (def.left >= left && def.top >= top && def.front >= front &&
def.right <= right && def.bottom <= bottom && def.back <= back);
}
            
size_t getWidth() const { return right-left; }
            size_t getHeight() const { return bottom-top; }
            size_t getDepth() const { return back-front; }
};
    
	
    int __declspec( dllexport ) findCommandLineOpts(int numargs, char** argv, UnaryOptionList& unaryOptList, 
BinaryOptionList& binOptList);
}
namespace Ogre {
    
    class __declspec( dllexport ) HardwareBuffer 
{
	    public:
		    enum Usage 
{
                HBU_STATIC = 1,
			    HBU_DYNAMIC = 2,
			    HBU_WRITE_ONLY = 4,
                HBU_DISCARDABLE = 8,
				HBU_STATIC_WRITE_ONLY = 5, 
				HBU_DYNAMIC_WRITE_ONLY = 6,
                HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE = 14
		    };
		    enum LockOptions
{
                HBL_NORMAL,
			    HBL_DISCARD,
 
HBL_READ_ONLY,
                HBL_NO_OVERWRITE
		    };
protected:
size_t mSizeInBytes;
Usage mUsage;
bool mIsLocked;
size_t mLockStart;
size_t mLockSize;
bool mSystemMemory;
bool mUseShadowBuffer;
HardwareBuffer* mpShadowBuffer;
bool mShadowUpdated;
bool mSuppressHardwareUpdate;
            
virtual void* lockImpl(size_t offset, size_t length, LockOptions options) = 0;
		    virtual void unlockImpl(void) = 0;
    public:
            HardwareBuffer(Usage usage, bool systemMemory, bool useShadowBuffer) 
: mUsage(usage), mIsLocked(false), mSystemMemory(systemMemory), 
mUseShadowBuffer(useShadowBuffer), mpShadowBuffer(0), mShadowUpdated(false), 
mSuppressHardwareUpdate(false) 
{
                if (useShadowBuffer && usage == HBU_DYNAMIC)
{
mUsage = HBU_DYNAMIC_WRITE_ONLY;
}
else if (useShadowBuffer && usage == HBU_STATIC)
{
mUsage = HBU_STATIC_WRITE_ONLY;
}
}
virtual ~HardwareBuffer() {}
		    virtual void* lock(size_t offset, size_t length, LockOptions options)
{
((void)0);
void* ret;
if (mUseShadowBuffer)
{
if (options != HBL_READ_ONLY)
{
						
mShadowUpdated = true;
}
                    ret = mpShadowBuffer->lock(offset, length, options);
}
else
{
                    ret = lockImpl(offset, length, options);
mIsLocked = true;
}
mLockStart = offset;
mLockSize = length;
return ret;
}
            
            void* lock(LockOptions options)
{
return this->lock(0, mSizeInBytes, options);
}
		    virtual void unlock(void)
{
((void)0);
				
if (mUseShadowBuffer && mpShadowBuffer->isLocked())
{
mpShadowBuffer->unlock();
                    _updateFromShadow();
}
else
{
                    unlockImpl();
mIsLocked = false;
}
            }
            
            virtual void readData(size_t offset, size_t length, void* pDest) = 0;
            virtual void writeData(size_t offset, size_t length, const void* pSource,
bool discardWholeBuffer = false) = 0;
			
			virtual void copyData(HardwareBuffer& srcBuffer, size_t srcOffset, 
size_t dstOffset, size_t length, bool discardWholeBuffer = false)
{
const void *srcData = srcBuffer.lock(
srcOffset, length, HBL_READ_ONLY);
this->writeData(dstOffset, length, srcData, discardWholeBuffer);
srcBuffer.unlock();
}
            
virtual void _updateFromShadow(void)
{
if (mUseShadowBuffer && mShadowUpdated && !mSuppressHardwareUpdate)
{
                    const void *srcData = mpShadowBuffer->lockImpl(
mLockStart, mLockSize, HBL_READ_ONLY);
					LockOptions lockOpt;
if (mLockStart == 0 && mLockSize == mSizeInBytes)
lockOpt = HBL_DISCARD;
else
lockOpt = HBL_NORMAL;
                    void *destData = this->lockImpl(
mLockStart, mLockSize, lockOpt);
                    memcpy(destData, srcData, mLockSize);
this->unlockImpl();
mpShadowBuffer->unlockImpl();
mShadowUpdated = false;
}
}
            
size_t getSizeInBytes(void) const { return mSizeInBytes; }
            Usage getUsage(void) const { return mUsage; }
			bool isSystemMemory(void) const { return mSystemMemory; }
			bool hasShadowBuffer(void) const { return mUseShadowBuffer; }
            bool isLocked(void) const { 
return mIsLocked || (mUseShadowBuffer && mpShadowBuffer->isLocked()); 
}
            void suppressHardwareUpdate(bool suppress) {
mSuppressHardwareUpdate = suppress;
if (!suppress)
_updateFromShadow();
}
    		
};
}
namespace Ogre {
    typedef uint32 RGBA;
typedef uint32 ARGB;
typedef uint32 ABGR;
typedef uint32 BGRA;
    
    class __declspec( dllexport ) ColourValue
{
public:
static const ColourValue ZERO;
static const ColourValue Black;
static const ColourValue White;
static const ColourValue Red;
static const ColourValue Green;
static const ColourValue Blue;
	    explicit ColourValue( float red = 1.0f,
float green = 1.0f,
float blue = 1.0f,
float alpha = 1.0f ) : r(red), g(green), b(blue), a(alpha)
{ }
	    bool operator==(const ColourValue& rhs) const;
bool operator!=(const ColourValue& rhs) const;
        float r,g,b,a;
	    
	    RGBA getAsRGBA(void) const;
	    
	    ARGB getAsARGB(void) const;
		
		BGRA getAsBGRA(void) const;
		
ABGR getAsABGR(void) const;
	    
        void setAsRGBA(const RGBA val);
	    
        void setAsARGB(const ARGB val);
		
		void setAsBGRA(const BGRA val);
	    
        void setAsABGR(const ABGR val);
        
        void saturate(void)
{
if (r < 0)
r = 0;
else if (r > 1)
r = 1;
            if (g < 0)
g = 0;
else if (g > 1)
g = 1;
            if (b < 0)
b = 0;
else if (b > 1)
b = 1;
            if (a < 0)
a = 0;
else if (a > 1)
a = 1;
}
        
        ColourValue saturateCopy(void) const
{
ColourValue ret = *this;
ret.saturate();
return ret;
}
		
inline float operator [] ( const size_t i ) const
{
((void)0);
			return *(&r+i);
}
		
inline float& operator [] ( const size_t i )
{
((void)0);
			return *(&r+i);
}
		
inline float* ptr()
{
return &r;
}
		inline const float* ptr() const
{
return &r;
}
		
        inline ColourValue operator + ( const ColourValue& rkVector ) const
{
ColourValue kSum;
            kSum.r = r + rkVector.r;
kSum.g = g + rkVector.g;
kSum.b = b + rkVector.b;
kSum.a = a + rkVector.a;
            return kSum;
}
        inline ColourValue operator - ( const ColourValue& rkVector ) const
{
ColourValue kDiff;
            kDiff.r = r - rkVector.r;
kDiff.g = g - rkVector.g;
kDiff.b = b - rkVector.b;
kDiff.a = a - rkVector.a;
            return kDiff;
}
        inline ColourValue operator * (const float fScalar ) const
{
ColourValue kProd;
            kProd.r = fScalar*r;
kProd.g = fScalar*g;
kProd.b = fScalar*b;
kProd.a = fScalar*a;
            return kProd;
}
        inline ColourValue operator * ( const ColourValue& rhs) const
{
ColourValue kProd;
            kProd.r = rhs.r * r;
kProd.g = rhs.g * g;
kProd.b = rhs.b * b;
kProd.a = rhs.a * a;
            return kProd;
}
        inline ColourValue operator / ( const ColourValue& rhs) const
{
ColourValue kProd;
            kProd.r = rhs.r / r;
kProd.g = rhs.g / g;
kProd.b = rhs.b / b;
kProd.a = rhs.a / a;
            return kProd;
}
        inline ColourValue operator / (const float fScalar ) const
{
((void)0);
            ColourValue kDiv;
            float fInv = 1.0 / fScalar;
kDiv.r = r * fInv;
kDiv.g = g * fInv;
kDiv.b = b * fInv;
kDiv.a = a * fInv;
            return kDiv;
}
        inline friend ColourValue operator * (const float fScalar, const ColourValue& rkVector )
{
ColourValue kProd;
            kProd.r = fScalar * rkVector.r;
kProd.g = fScalar * rkVector.g;
kProd.b = fScalar * rkVector.b;
kProd.a = fScalar * rkVector.a;
            return kProd;
}
        
inline ColourValue& operator += ( const ColourValue& rkVector )
{
r += rkVector.r;
g += rkVector.g;
b += rkVector.b;
a += rkVector.a;
            return *this;
}
        inline ColourValue& operator -= ( const ColourValue& rkVector )
{
r -= rkVector.r;
g -= rkVector.g;
b -= rkVector.b;
a -= rkVector.a;
            return *this;
}
        inline ColourValue& operator *= (const float fScalar )
{
r *= fScalar;
g *= fScalar;
b *= fScalar;
a *= fScalar;
return *this;
}
        inline ColourValue& operator /= (const float fScalar )
{
((void)0);
            float fInv = 1.0 / fScalar;
            r *= fInv;
g *= fInv;
b *= fInv;
a *= fInv;
            return *this;
}
		
		void setHSB(Real hue, Real saturation, Real brightness);
		
		inline __declspec( dllexport ) friend std::ostream& operator <<
( std::ostream& o, const ColourValue& c )
{
o << "ColourValue(" << c.r << ", " << c.g << ", " << c.b << ", " << c.a << ")";
return o;
}
    };
} 
namespace Ogre {
    class __declspec( dllexport ) HardwareVertexBuffer : public HardwareBuffer
{
protected:
		    size_t mNumVertices;
size_t mVertexSize;
	    public:
		    HardwareVertexBuffer(size_t vertexSize, size_t numVertices,
HardwareBuffer::Usage usage, bool useSystemMemory, bool useShadowBuffer);
~HardwareVertexBuffer();
            size_t getVertexSize(void) const { return mVertexSize; }
            size_t getNumVertices(void) const { return mNumVertices; }
		    
    };
    
class __declspec( dllexport ) HardwareVertexBufferSharedPtr : public SharedPtr<HardwareVertexBuffer>
{
public:
HardwareVertexBufferSharedPtr() : SharedPtr<HardwareVertexBuffer>() {}
explicit HardwareVertexBufferSharedPtr(HardwareVertexBuffer* buf);
    };
    
enum VertexElementSemantic {
		VES_POSITION = 1,
		VES_BLEND_WEIGHTS = 2,
        VES_BLEND_INDICES = 3,
		VES_NORMAL = 4,
		VES_DIFFUSE = 5,
		VES_SPECULAR = 6,
		VES_TEXTURE_COORDINATES = 7,
        VES_BINORMAL = 8,
        VES_TANGENT = 9
	};
    
enum VertexElementType
{
VET_FLOAT1 = 0,
VET_FLOAT2 = 1,
VET_FLOAT3 = 2,
VET_FLOAT4 = 3,
		VET_COLOUR = 4,
VET_SHORT1 = 5,
VET_SHORT2 = 6,
VET_SHORT3 = 7,
VET_SHORT4 = 8,
VET_UBYTE4 = 9,
        VET_COLOUR_ARGB = 10,
        VET_COLOUR_ABGR = 11
};
    
    class __declspec( dllexport ) VertexElement
{
protected:
        unsigned short mSource;
        size_t mOffset;
        VertexElementType mType;
        VertexElementSemantic mSemantic;
        unsigned short mIndex;
public:
        VertexElement(unsigned short source, size_t offset, VertexElementType theType,
VertexElementSemantic semantic, unsigned short index = 0);
        unsigned short getSource(void) const { return mSource; }
        size_t getOffset(void) const { return mOffset; }
        VertexElementType getType(void) const { return mType; }
        VertexElementSemantic getSemantic(void) const { return mSemantic; }
        unsigned short getIndex(void) const { return mIndex; }
		size_t getSize(void) const;
		static size_t getTypeSize(VertexElementType etype);
		static unsigned short getTypeCount(VertexElementType etype);
		static VertexElementType multiplyTypeCount(VertexElementType baseType, unsigned short count);
		static VertexElementType getBaseType(VertexElementType multiType);
		
		static void convertColourValue(VertexElementType srcType,
VertexElementType dstType, uint32* ptr);
		
		static uint32 convertColourValue(const ColourValue& src,
VertexElementType dst);
		
static VertexElementType getBestColourVertexElementType(void);
        inline bool operator== (const VertexElement& rhs) const
{
if (mType != rhs.mType ||
mIndex != rhs.mIndex ||
mOffset != rhs.mOffset ||
mSemantic != rhs.mSemantic ||
mSource != rhs.mSource)
return false;
else
return true;
        }
        inline void baseVertexPointerToElement(void* pBase, void** pElem) const
{
            
*pElem = static_cast<void*>(
static_cast<unsigned char*>(pBase) + mOffset);
}
        inline void baseVertexPointerToElement(void* pBase, float** pElem) const
{
            
            *pElem = static_cast<float*>(
static_cast<void*>(
static_cast<unsigned char*>(pBase) + mOffset));
}
        
        inline void baseVertexPointerToElement(void* pBase, RGBA** pElem) const
{
*pElem = static_cast<RGBA*>(
static_cast<void*>(
static_cast<unsigned char*>(pBase) + mOffset));
}
        inline void baseVertexPointerToElement(void* pBase, unsigned char** pElem) const
{
*pElem = static_cast<unsigned char*>(pBase) + mOffset;
}
        
        inline void baseVertexPointerToElement(void* pBase, unsigned short** pElem) const
{
*pElem = static_cast<unsigned short*>(pBase) + mOffset;
}
    };
    class __declspec( dllexport ) VertexDeclaration
{
public:
        typedef std::list<VertexElement> VertexElementList;
        static bool vertexElementLess(const VertexElement& e1, const VertexElement& e2);
protected:
VertexElementList mElementList;
public:
        VertexDeclaration();
virtual ~VertexDeclaration();
        
size_t getElementCount(void) { return mElementList.size(); }
        const VertexElementList& getElements(void) const;
        const VertexElement* getElement(unsigned short index);
        
        void sort(void);
        
        void closeGapsInSource(void);
        
        VertexDeclaration* getAutoOrganisedDeclaration(bool skeletalAnimation,
bool vertexAnimation);
        
unsigned short getMaxSource(void) const;
        
        virtual const VertexElement& addElement(unsigned short source, size_t offset, VertexElementType theType,
VertexElementSemantic semantic, unsigned short index = 0);
        virtual const VertexElement& insertElement(unsigned short atPosition,
unsigned short source, size_t offset, VertexElementType theType,
VertexElementSemantic semantic, unsigned short index = 0);
        
virtual void removeElement(unsigned short elem_index);
        
        virtual void removeElement(VertexElementSemantic semantic, unsigned short index = 0);
		
virtual void removeAllElements(void);
        
        virtual void modifyElement(unsigned short elem_index, unsigned short source, size_t offset, VertexElementType theType,
VertexElementSemantic semantic, unsigned short index = 0);
		
		virtual const VertexElement* findElementBySemantic(VertexElementSemantic sem, unsigned short index = 0);
		
		virtual VertexElementList findElementsBySource(unsigned short source);
		
virtual size_t getVertexSize(unsigned short source);
        
virtual VertexDeclaration* clone(void);
        inline bool operator== (const VertexDeclaration& rhs) const
{
if (mElementList.size() != rhs.mElementList.size())
return false;
            VertexElementList::const_iterator i, iend, rhsi, rhsiend;
iend = mElementList.end();
rhsiend = rhs.mElementList.end();
rhsi = rhs.mElementList.begin();
for (i = mElementList.begin(); i != iend && rhsi != rhsiend; ++i, ++rhsi)
{
if ( !(*i == *rhsi) )
return false;
}
            return true;
}
inline bool operator!= (const VertexDeclaration& rhs) const
{
return !(*this == rhs);
}
    };
	
	class __declspec( dllexport ) VertexBufferBinding
{
public:
		typedef std::map<unsigned short, HardwareVertexBufferSharedPtr> VertexBufferBindingMap;
protected:
VertexBufferBindingMap mBindingMap;
mutable unsigned short mHighIndex;
public:
		VertexBufferBinding();
virtual ~VertexBufferBinding();
		virtual void setBinding(unsigned short index, const HardwareVertexBufferSharedPtr& buffer);
		virtual void unsetBinding(unsigned short index);
        
virtual void unsetAllBindings(void);
		
virtual const VertexBufferBindingMap& getBindings(void) const;
		
virtual const HardwareVertexBufferSharedPtr& getBuffer(unsigned short index) const;
		virtual bool isBufferBound(unsigned short index) const;
        virtual size_t getBufferCount(void) const { return mBindingMap.size(); }
		
		virtual unsigned short getNextIndex(void) const { return mHighIndex++; }
        
        virtual unsigned short getLastBoundIndex(void) const;
        typedef std::map<ushort, ushort> BindingIndexMap;
        
        virtual bool hasGaps(void) const;
        
        virtual void closeGaps(BindingIndexMap& bindingIndexMap);
	};
}
namespace Ogre {
    
class __declspec( dllexport ) HardwareIndexBuffer : public HardwareBuffer
{
public:
enum IndexType {
IT_16BIT,
IT_32BIT
};
	    protected:
IndexType mIndexType;
size_t mNumIndexes;
size_t mIndexSize;
	    public:
		    HardwareIndexBuffer(IndexType idxType, size_t numIndexes, HardwareBuffer::Usage usage,
bool useSystemMemory, bool useShadowBuffer);
~HardwareIndexBuffer();
            IndexType getType(void) const { return mIndexType; }
            size_t getNumIndexes(void) const { return mNumIndexes; }
            size_t getIndexSize(void) const { return mIndexSize; }
		    
};
    
class __declspec( dllexport ) HardwareIndexBufferSharedPtr : public SharedPtr<HardwareIndexBuffer>
{
public:
HardwareIndexBufferSharedPtr() : SharedPtr<HardwareIndexBuffer>() {}
explicit HardwareIndexBufferSharedPtr(HardwareIndexBuffer* buf);
};
}
namespace Ogre {
	
typedef std::vector<HardwareBuffer::Usage> BufferUsageList;
	
class __declspec( dllexport ) VertexData
{
private:
        VertexData(const VertexData& rhs); 
        VertexData& operator=(const VertexData& rhs); 
public:
VertexData();
~VertexData();
		
		VertexDeclaration* vertexDeclaration;
		VertexBufferBinding* vertexBufferBinding;
		size_t vertexStart;
		size_t vertexCount;
		
struct HardwareAnimationData
{
const VertexElement* targetVertexElement;
Real parametric;
};
typedef std::vector<HardwareAnimationData> HardwareAnimationDataList;
		HardwareAnimationDataList hwAnimationDataList;
		size_t hwAnimDataItemsUsed;
		
		VertexData* clone(bool copyData = true) const;
        
        void prepareForShadowVolume(void);
        
        HardwareVertexBufferSharedPtr hardwareShadowVolWBuffer;
		
		void reorganiseBuffers(VertexDeclaration* newDeclaration, const BufferUsageList& bufferUsage);
		
		void reorganiseBuffers(VertexDeclaration* newDeclaration);
        
        void closeGapsInBindings(void);
        
        void removeUnusedBuffers(void);
		
		void convertPackedColour(VertexElementType srcType, VertexElementType destType);
		
		void allocateHardwareAnimationElements(ushort count);
	};
	
class __declspec( dllexport ) IndexData 
{
protected:
        IndexData(const IndexData& rhs); 
        IndexData& operator=(const IndexData& rhs); 
public:
IndexData();
~IndexData();
		HardwareIndexBufferSharedPtr indexBuffer;
		
size_t indexStart;
		
size_t indexCount;
		
		IndexData* clone(bool copyData = true) const;
		
		void optimiseVertexCacheTriList(void);
	};
	
	class __declspec( dllexport ) VertexCacheProfiler
{
public:
enum CacheType {
FIFO, LRU
};
			VertexCacheProfiler(unsigned int cachesize = 16, CacheType cachetype = FIFO )
: size ( cachesize ), type ( cachetype ), tail (0), buffersize (0), hit (0), miss (0)
{
cache = new uint32[size];
};
			~VertexCacheProfiler()
{
delete[] cache;
}
			void profile(const HardwareIndexBufferSharedPtr& indexBuffer);
void reset() { hit = 0; miss = 0; tail = 0; buffersize = 0; };
void flush() { tail = 0; buffersize = 0; };
			unsigned int getHits() { return hit; };
unsigned int getMisses() { return miss; };
unsigned int getSize() { return size; };
private:
unsigned int size;
uint32 *cache;
CacheType type;
			unsigned int tail, buffersize;
unsigned int hit, miss;
			bool inCache(unsigned int index);
};
}
namespace Ogre {
	
class  RenderOperation {
public:
		enum OperationType {
            OT_POINT_LIST = 1,
            OT_LINE_LIST = 2,
            OT_LINE_STRIP = 3,
            OT_TRIANGLE_LIST = 4,
            OT_TRIANGLE_STRIP = 5,
            OT_TRIANGLE_FAN = 6
};
		
VertexData *vertexData;
		
OperationType operationType;
		
		bool useIndexes;
		
IndexData *indexData;
		const Renderable* srcRenderable;
        RenderOperation() :
vertexData(0), operationType(OT_TRIANGLE_LIST), useIndexes(true),
indexData(0) {}
	};
}
namespace Ogre {
    
enum ParameterType
{
PT_BOOL,
PT_REAL,
PT_INT,
PT_UNSIGNED_INT,
PT_SHORT,
PT_UNSIGNED_SHORT,
PT_LONG,
PT_UNSIGNED_LONG,
PT_STRING,
PT_VECTOR3,
PT_MATRIX3,
PT_MATRIX4,
PT_QUATERNION,
PT_COLOURVALUE
};
    
class __declspec( dllexport ) ParameterDef
{
public:
String name;
String description;
ParameterType paramType;
ParameterDef(const String& newName, const String& newDescription, ParameterType newType)
: name(newName), description(newDescription), paramType(newType) {}
};
typedef std::vector<ParameterDef> ParameterList;
    
class __declspec( dllexport ) ParamCommand
{
public:
virtual String doGet(const void* target) const = 0;
virtual void doSet(void* target, const String& val) = 0;
        virtual ~ParamCommand() { }
};
typedef std::map<String, ParamCommand* > ParamCommandMap;
    
class __declspec( dllexport ) ParamDictionary
{
friend class StringInterface;
protected:
        ParameterList mParamDefs;
        
ParamCommandMap mParamCommands;
        
ParamCommand* getParamCommand(const String& name)
{
ParamCommandMap::iterator i = mParamCommands.find(name);
if (i != mParamCommands.end())
{
return i->second;
}
else
{
return 0;
}
}
		const ParamCommand* getParamCommand(const String& name) const
{
ParamCommandMap::const_iterator i = mParamCommands.find(name);
if (i != mParamCommands.end())
{
return i->second;
}
else
{
return 0;
}
}
public:
ParamDictionary()  {}
        void addParameter(const ParameterDef& paramDef, ParamCommand* paramCmd)
{
mParamDefs.push_back(paramDef);
mParamCommands[paramDef.name] = paramCmd;
}
        const ParameterList& getParameters(void) const
{
return mParamDefs;
}
    };
typedef std::map<String, ParamDictionary> ParamDictionaryMap;
    
    class __declspec( dllexport ) StringInterface 
{
protected:
        
static ParamDictionaryMap msDictionary;
        
String mParamDictName;
        
        bool createParamDictionary(const String& className)
{
mParamDictName = className;
if (msDictionary.find(className) == msDictionary.end())
{
msDictionary[className] = ParamDictionary();
return true;
}
return false;
        }
    public:
        
virtual ~StringInterface() {}
        
        ParamDictionary* getParamDictionary(void)
{
ParamDictionaryMap::iterator i = msDictionary.find(mParamDictName);
if (i != msDictionary.end())
{
return &(i->second);
}
else
{
return 0;
}
}
		const ParamDictionary* getParamDictionary(void) const
{
ParamDictionaryMap::const_iterator i = msDictionary.find(mParamDictName);
if (i != msDictionary.end())
{
return &(i->second);
}
else
{
return 0;
}
}
        
        const ParameterList& getParameters(void) const;
        
        virtual bool setParameter(const String& name, const String& value);
        virtual void setParameterList(const NameValuePairList& paramList);
        virtual String getParameter(const String& name) const
{
            const ParamDictionary* dict = getParamDictionary();
            if (dict)
{
                const ParamCommand* cmd = dict->getParamCommand(name);
                if (cmd)
{
return cmd->doGet(this);
}
}
            
return "";
}
        virtual void copyParametersTo(StringInterface* dest) const
{
            const ParamDictionary* dict = getParamDictionary();
            if (dict)
{
                ParameterList::const_iterator i;
                for (i = dict->mParamDefs.begin(); 
i != dict->mParamDefs.end(); ++i)
{
dest->setParameter(i->name, getParameter(i->name));
}
}
        }
        
        static void cleanupDictionary () ;
    };
}
namespace Ogre {
    typedef unsigned long ResourceHandle;
	
class ManualResourceLoader;
	
	class __declspec( dllexport ) Resource : public StringInterface
{
public:
		class Listener
{
public:
Listener() {}
virtual ~Listener() {}
			
			virtual void backgroundLoadingComplete(Resource*) {}
		};
		
enum LoadingState
{
			LOADSTATE_UNLOADED,
			LOADSTATE_LOADING,
			LOADSTATE_LOADED,
			LOADSTATE_UNLOADING
};
protected:
		ResourceManager* mCreator;
        String mName;
		String mGroup;
        ResourceHandle mHandle;
        volatile LoadingState mLoadingState;
		volatile bool mIsBackgroundLoaded;
		
        size_t mSize;
		bool mIsManual;
		String mOrigin;
		ManualResourceLoader* mLoader;
		typedef std::list<Listener*> ListenerList;
ListenerList mListenerList;
		
		Resource() 
: mCreator(0), mHandle(0), mLoadingState(LOADSTATE_UNLOADED), 
mIsBackgroundLoaded(false),	mSize(0), mIsManual(0), mLoader(0)
{ 
}
		
		virtual void preLoadImpl(void) {}
		virtual void postLoadImpl(void) {}
		
		virtual void preUnloadImpl(void) {}
		virtual void postUnloadImpl(void) {}
		
		virtual void loadImpl(void) = 0;
		virtual void unloadImpl(void) = 0;
		virtual size_t calculateSize(void) const = 0;
		
virtual void queueFireBackgroundLoadingComplete(void);
    public:
		Resource(ResourceManager* creator, const String& name, ResourceHandle handle,
const String& group, bool isManual = false, ManualResourceLoader* loader = 0);
        
        virtual ~Resource();
        
        virtual void load(bool backgroundThread = false);
		
		virtual void reload(void);
        
        bool isReloadable(void) const
{
return !mIsManual || mLoader;
}
        
		bool isManuallyLoaded(void) const
{
return mIsManual;
}
		
		virtual void unload(void);
        
        size_t getSize(void) const
{ 
return mSize; 
}
        
        virtual void touch(void);
        
        const String& getName(void) const 
{ 
return mName; 
}
        ResourceHandle getHandle(void) const
{
return mHandle;
}
        
        bool isLoaded(void) const 
{ 
            return (mLoadingState == LOADSTATE_LOADED); 
}
		
		LoadingState isLoading() const
{
return mLoadingState;
}
		
		LoadingState getLoadingState() const
{
return mLoadingState;
}
		
		bool isBackgroundLoaded(void) const { return mIsBackgroundLoaded; }
		
		void setBackgroundLoaded(bool bl) { mIsBackgroundLoaded = bl; }
		
		void escalateLoading();
		
		void addListener(Listener* lis);
		
		void removeListener(Listener* lis);
		
const String& getGroup(void) { return mGroup; }
		
		void changeGroupOwnership(const String& newGroup);
		
ResourceManager* getCreator(void) { return mCreator; }
		const String& getOrigin(void) const { return mOrigin; }
		void _notifyOrigin(const String& origin) { mOrigin = origin; }
		
		virtual void _fireBackgroundLoadingComplete(void);
    };
	
	typedef SharedPtr<Resource> ResourcePtr;
	
	class __declspec( dllexport ) ManualResourceLoader
{
public:
ManualResourceLoader() {}
virtual ~ManualResourceLoader() {}
		
		virtual void loadResource(Resource* resource) = 0;
};
}
namespace Ogre {
    
    enum LayerBlendType
{
LBT_COLOUR,
LBT_ALPHA
};
    
    enum LayerBlendOperation {
        LBO_REPLACE,
        LBO_ADD,
        LBO_MODULATE,
        LBO_ALPHA_BLEND
    };
    
    enum LayerBlendOperationEx {
        LBX_SOURCE1,
        LBX_SOURCE2,
        LBX_MODULATE,
        LBX_MODULATE_X2,
        LBX_MODULATE_X4,
        LBX_ADD,
        LBX_ADD_SIGNED,
        LBX_ADD_SMOOTH,
        LBX_SUBTRACT,
        LBX_BLEND_DIFFUSE_ALPHA,
        LBX_BLEND_TEXTURE_ALPHA,
        LBX_BLEND_CURRENT_ALPHA,
        LBX_BLEND_MANUAL,
        LBX_DOTPRODUCT,
        LBX_BLEND_DIFFUSE_COLOUR
};
    
    enum LayerBlendSource
{
        LBS_CURRENT,
        LBS_TEXTURE,
        LBS_DIFFUSE,
        LBS_SPECULAR,
        LBS_MANUAL
};
    class __declspec( dllexport ) LayerBlendModeEx
{
public:
        LayerBlendType blendType;
        LayerBlendOperationEx operation;
        LayerBlendSource source1;
        LayerBlendSource source2;
        
ColourValue colourArg1;
        ColourValue colourArg2;
        Real alphaArg1;
        Real alphaArg2;
        Real factor;
        bool operator==(const LayerBlendModeEx& rhs) const
{
if (blendType != rhs.blendType) return false;
            if (blendType == LBT_COLOUR)
{
                if (operation == rhs.operation &&
source1 == rhs.source1 &&
source2 == rhs.source2 &&
colourArg1 == rhs.colourArg1 &&
colourArg2 == rhs.colourArg2 &&
factor == rhs.factor)
{
return true;
}
}
else 
{
if (operation == rhs.operation &&
source1 == rhs.source1 &&
source2 == rhs.source2 &&
alphaArg1 == rhs.alphaArg1 &&
alphaArg2 == rhs.alphaArg2 &&
factor == rhs.factor)
{
return true;
}
}
return false;
}
        bool operator!=(const LayerBlendModeEx& rhs) const
{
return !(*this == rhs);
}
    };
    
    enum SceneBlendType
{
        SBT_TRANSPARENT_ALPHA,
        SBT_TRANSPARENT_COLOUR,
        SBT_ADD,
		SBT_MODULATE,
        SBT_REPLACE
    };
    
    enum SceneBlendFactor
{
SBF_ONE,
SBF_ZERO,
SBF_DEST_COLOUR,
SBF_SOURCE_COLOUR,
SBF_ONE_MINUS_DEST_COLOUR,
SBF_ONE_MINUS_SOURCE_COLOUR,
SBF_DEST_ALPHA,
SBF_SOURCE_ALPHA,
SBF_ONE_MINUS_DEST_ALPHA,
SBF_ONE_MINUS_SOURCE_ALPHA
    };
}
namespace Ogre {
	
class MaterialPtr;
	
    class __declspec( dllexport ) Material : public Resource
{
friend class SceneManager;
friend class MaterialManager;
    public:
        typedef std::vector<Real> LodDistanceList;
typedef ConstVectorIterator<LodDistanceList> LodDistanceIterator;
protected:
        
        void applyDefaults(void);
        typedef std::vector<Technique*> Techniques;
        Techniques mTechniques;
        Techniques mSupportedTechniques;
typedef std::map<unsigned short, Technique*> LodTechniques;
typedef std::map<unsigned short, LodTechniques*> BestTechniquesBySchemeList;
        BestTechniquesBySchemeList mBestTechniquesBySchemeList;
        LodDistanceList mLodDistances;
bool mReceiveShadows;
bool mTransparencyCastsShadows;
        bool mCompilationRequired;
		String mUnsupportedReasons;
		
void insertSupportedTechnique(Technique* t);
		
		void clearBestTechniqueList(void);
		
		void loadImpl(void);
		
		void unloadImpl(void);
		size_t calculateSize(void) const { return 0; } 
public:
        
		Material(ResourceManager* creator, const String& name, ResourceHandle handle,
const String& group, bool isManual = false, ManualResourceLoader* loader = 0);
        ~Material();
        Material& operator=( const Material& rhs );
        
        bool isTransparent(void) const;
        
        void setReceiveShadows(bool enabled) { mReceiveShadows = enabled; }
        bool getReceiveShadows(void) const { return mReceiveShadows; }
		
		void setTransparencyCastsShadows(bool enabled) { mTransparencyCastsShadows = enabled; }
		bool getTransparencyCastsShadows(void) const { return mTransparencyCastsShadows; }
        
        Technique* createTechnique(void);
        Technique* getTechnique(unsigned short index);
        Technique* getTechnique(const String& name);
        unsigned short getNumTechniques(void) const;
        void removeTechnique(unsigned short index);		
        void removeAllTechniques(void);
typedef VectorIterator<Techniques> TechniqueIterator;
        TechniqueIterator getTechniqueIterator(void);
        TechniqueIterator getSupportedTechniqueIterator(void);
		
Technique* getSupportedTechnique(unsigned short index);
        unsigned short getNumSupportedTechniques(void) const;
		const String& getUnsupportedTechniquesExplanation() const { return mUnsupportedReasons; }
        
        unsigned short getNumLodLevels(unsigned short schemeIndex) const;
        unsigned short getNumLodLevels(const String& schemeName) const;
        
        Technique* getBestTechnique(unsigned short lodIndex = 0);
        
        MaterialPtr clone(const String& newName, bool changeGroup = false, 
const String& newGroup = StringUtil::BLANK) const;
        
        void copyDetailsTo(MaterialPtr& mat) const;
        
        void compile(bool autoManageTextureUnits = true);
        
        
        
        void setPointSize(Real ps);
        
        void setAmbient(Real red, Real green, Real blue);
        
        void setAmbient(const ColourValue& ambient);
        
        void setDiffuse(Real red, Real green, Real blue, Real alpha);
        
        void setDiffuse(const ColourValue& diffuse);
        
        void setSpecular(Real red, Real green, Real blue, Real alpha);
        
        void setSpecular(const ColourValue& specular);
        
        void setShininess(Real val);
        
        void setSelfIllumination(Real red, Real green, Real blue);
        
        void setSelfIllumination(const ColourValue& selfIllum);
		
        void setDepthCheckEnabled(bool enabled);
        
        void setDepthWriteEnabled(bool enabled);
        
        void setDepthFunction( CompareFunction func );
		
		void setColourWriteEnabled(bool enabled);
        
        void setCullingMode( CullingMode mode );
        
        void setManualCullingMode( ManualCullingMode mode );
        
        void setLightingEnabled(bool enabled);
        
        void setShadingMode( ShadeOptions mode );
        
        void setFog(
bool overrideScene,
FogMode mode = FOG_NONE,
const ColourValue& colour = ColourValue::White,
Real expDensity = 0.001, Real linearStart = 0.0, Real linearEnd = 1.0 );
        
        void setDepthBias(float constantBias, float slopeScaleBias);
        
        void setTextureFiltering(TextureFilterOptions filterType);
        void setTextureAnisotropy(int maxAniso);
        
        void setSceneBlending( const SceneBlendType sbt );
        
        void setSceneBlending( const SceneBlendFactor sourceFactor, const SceneBlendFactor destFactor);
        
void _notifyNeedsRecompile(void);
        
        void setLodLevels(const LodDistanceList& lodDistances);
        LodDistanceIterator getLodDistanceIterator(void) const;
        
unsigned short getLodIndex(Real d) const;
        unsigned short getLodIndexSquaredDepth(Real squaredDepth) const;
        
        void touch(void) 
{ 
if (mCompilationRequired) 
compile();
            Resource::touch();
}
        
        bool applyTextureAliases(const AliasTextureNamePairList& aliasList, const bool apply = true) const;
	    
	    bool getCompilationRequired() const
{
return mCompilationRequired;
}
    };
	
	class __declspec( dllexport ) MaterialPtr : public SharedPtr<Material> 
{
public:
MaterialPtr() : SharedPtr<Material>() {}
explicit MaterialPtr(Material* rep) : SharedPtr<Material>(rep) {}
MaterialPtr(const MaterialPtr& r) : SharedPtr<Material>(r) {} 
MaterialPtr(const ResourcePtr& r) : SharedPtr<Material>()
{
            if(true)
{
			    
pRep = static_cast<Material*>(r.getPointer());
pUseCount = r.useCountPointer();
if (pUseCount)
{
++(*pUseCount);
}
}
}
		
MaterialPtr& operator=(const ResourcePtr& r)
{
if (pRep == static_cast<Material*>(r.getPointer()))
return *this;
release();
            if(true)
{
			    
pRep = static_cast<Material*>(r.getPointer());
pUseCount = r.useCountPointer();
if (pUseCount)
{
++(*pUseCount);
}
}
else
{
				((void)0);
setNull();
}
return *this;
}
};
} 
namespace Ogre {
	
enum GpuProgramType
{
GPT_VERTEX_PROGRAM,
GPT_FRAGMENT_PROGRAM
};
	
	enum GpuConstantType
{
GCT_FLOAT1,
GCT_FLOAT2,
GCT_FLOAT3,
GCT_FLOAT4,
GCT_SAMPLER1D,
GCT_SAMPLER2D,
GCT_SAMPLER3D,
GCT_SAMPLERCUBE,
GCT_SAMPLER1DSHADOW,
GCT_SAMPLER2DSHADOW,
GCT_MATRIX_2X2,
GCT_MATRIX_2X3,
GCT_MATRIX_2X4,
GCT_MATRIX_3X2,
GCT_MATRIX_3X3,
GCT_MATRIX_3X4,
GCT_MATRIX_4X2,
GCT_MATRIX_4X3,
GCT_MATRIX_4X4,
GCT_INT1,
GCT_INT2,
GCT_INT3,
GCT_INT4,
GCT_UNKNOWN
};
	
	struct __declspec( dllexport ) GpuConstantDefinition
{
		GpuConstantType constType;
		size_t physicalIndex;
		size_t elementSize;
		size_t arraySize;
		bool isFloat() const
{
switch(constType)
{
case GCT_INT1:
case GCT_INT2:
case GCT_INT3:
case GCT_INT4:
case GCT_SAMPLER1D:
case GCT_SAMPLER2D:
case GCT_SAMPLER3D:
case GCT_SAMPLERCUBE:
case GCT_SAMPLER1DSHADOW:
case GCT_SAMPLER2DSHADOW:
return false;
default:
return true;
};
		}
		bool isSampler() const
{
switch(constType)
{
case GCT_SAMPLER1D:
case GCT_SAMPLER2D:
case GCT_SAMPLER3D:
case GCT_SAMPLERCUBE:
case GCT_SAMPLER1DSHADOW:
case GCT_SAMPLER2DSHADOW:
return true;
default:
return false;
};
		}
		GpuConstantDefinition()
: constType(GCT_UNKNOWN)
, physicalIndex((std::numeric_limits<size_t>::max)())
, elementSize(0)
, arraySize(1) {}
};
typedef std::map<String, GpuConstantDefinition> GpuConstantDefinitionMap;
typedef ConstMapIterator<GpuConstantDefinitionMap> GpuConstantDefinitionIterator;
	
struct __declspec( dllexport ) GpuNamedConstants
{
		size_t floatBufferSize;
		size_t intBufferSize;
		GpuConstantDefinitionMap map;
		
		void generateConstantDefinitionArrayEntries(const String& paramName, 
const GpuConstantDefinition& baseDef);
	};
	
	struct __declspec( dllexport ) GpuLogicalIndexUse
{
		size_t physicalIndex;
		size_t currentSize;
		GpuLogicalIndexUse(size_t bufIdx, size_t curSz) 
: physicalIndex(bufIdx), currentSize(curSz) {}
};
typedef std::map<size_t, GpuLogicalIndexUse> GpuLogicalIndexUseMap;
	struct __declspec( dllexport ) GpuLogicalBufferStruct
{
		
GpuLogicalIndexUseMap map;
		size_t bufferSize;
GpuLogicalBufferStruct() : bufferSize(0) {}
};
    
    class __declspec( dllexport ) GpuProgramParameters
{
public:
        enum AutoConstantType
{
            ACT_WORLD_MATRIX,
            ACT_INVERSE_WORLD_MATRIX,
 			ACT_TRANSPOSE_WORLD_MATRIX,
            ACT_INVERSE_TRANSPOSE_WORLD_MATRIX,
            
ACT_WORLD_MATRIX_ARRAY_3x4,
            ACT_WORLD_MATRIX_ARRAY,
            
ACT_VIEW_MATRIX,
			ACT_INVERSE_VIEW_MATRIX,
			ACT_TRANSPOSE_VIEW_MATRIX,
			ACT_INVERSE_TRANSPOSE_VIEW_MATRIX,
            
ACT_PROJECTION_MATRIX,
			ACT_INVERSE_PROJECTION_MATRIX,
			ACT_TRANSPOSE_PROJECTION_MATRIX,
			ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX,
            
ACT_VIEWPROJ_MATRIX,
			ACT_INVERSE_VIEWPROJ_MATRIX,
			ACT_TRANSPOSE_VIEWPROJ_MATRIX,
			ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX,
            
ACT_WORLDVIEW_MATRIX,
            ACT_INVERSE_WORLDVIEW_MATRIX,
 			ACT_TRANSPOSE_WORLDVIEW_MATRIX,
            ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX,
            
ACT_WORLDVIEWPROJ_MATRIX,
			ACT_INVERSE_WORLDVIEWPROJ_MATRIX,
			ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX,
			ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX,
            
            ACT_RENDER_TARGET_FLIPPING,
            
ACT_FOG_COLOUR,
            ACT_FOG_PARAMS,
            
ACT_SURFACE_AMBIENT_COLOUR,
            ACT_SURFACE_DIFFUSE_COLOUR,
            ACT_SURFACE_SPECULAR_COLOUR,
            ACT_SURFACE_EMISSIVE_COLOUR,
            ACT_SURFACE_SHININESS,
			
ACT_AMBIENT_LIGHT_COLOUR, 
            
ACT_LIGHT_DIFFUSE_COLOUR,
            ACT_LIGHT_SPECULAR_COLOUR,
            ACT_LIGHT_ATTENUATION,
 
ACT_SPOTLIGHT_PARAMS,
            ACT_LIGHT_POSITION,
            ACT_LIGHT_POSITION_OBJECT_SPACE,
            ACT_LIGHT_POSITION_VIEW_SPACE,
            ACT_LIGHT_DIRECTION,
            ACT_LIGHT_DIRECTION_OBJECT_SPACE,
			ACT_LIGHT_DIRECTION_VIEW_SPACE,
			ACT_LIGHT_DISTANCE_OBJECT_SPACE,
			ACT_LIGHT_POWER_SCALE,
			ACT_LIGHT_DIFFUSE_COLOUR_ARRAY,
			ACT_LIGHT_SPECULAR_COLOUR_ARRAY,
			ACT_LIGHT_ATTENUATION_ARRAY,
			ACT_LIGHT_POSITION_ARRAY,
			ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY,
			ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY,
			ACT_LIGHT_DIRECTION_ARRAY,
			ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY,
			ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY,
			ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY,
			ACT_LIGHT_POWER_SCALE_ARRAY,
 
ACT_SPOTLIGHT_PARAMS_ARRAY,
            
            ACT_DERIVED_AMBIENT_LIGHT_COLOUR,
            ACT_DERIVED_SCENE_COLOUR,
            
            ACT_DERIVED_LIGHT_DIFFUSE_COLOUR,
            ACT_DERIVED_LIGHT_SPECULAR_COLOUR,
			
ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY,
            ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY,
			
			ACT_SHADOW_EXTRUSION_DISTANCE,
            ACT_CAMERA_POSITION,
            ACT_CAMERA_POSITION_OBJECT_SPACE,
            ACT_TEXTURE_VIEWPROJ_MATRIX,
            ACT_CUSTOM,
            ACT_TIME,
			ACT_TIME_0_X,
			ACT_COSTIME_0_X,
			ACT_SINTIME_0_X,
			ACT_TANTIME_0_X,
			ACT_TIME_0_X_PACKED,
			ACT_TIME_0_1,
			ACT_COSTIME_0_1,
			ACT_SINTIME_0_1,
			ACT_TANTIME_0_1,
			ACT_TIME_0_1_PACKED,
			ACT_TIME_0_2PI,
			ACT_COSTIME_0_2PI,
			ACT_SINTIME_0_2PI,
			ACT_TANTIME_0_2PI,
			ACT_TIME_0_2PI_PACKED,
            ACT_FRAME_TIME,
			ACT_FPS,
			
			ACT_VIEWPORT_WIDTH,
			ACT_VIEWPORT_HEIGHT,
			ACT_INVERSE_VIEWPORT_WIDTH,
			ACT_INVERSE_VIEWPORT_HEIGHT,
            ACT_VIEWPORT_SIZE,
			
			ACT_VIEW_DIRECTION,
			ACT_VIEW_SIDE_VECTOR,
			ACT_VIEW_UP_VECTOR,
			ACT_FOV,
			ACT_NEAR_CLIP_DISTANCE,
			ACT_FAR_CLIP_DISTANCE,
            
            ACT_PASS_NUMBER,
            
            ACT_PASS_ITERATION_NUMBER,
			
			ACT_ANIMATION_PARAMETRIC,
			
			ACT_TEXEL_OFFSETS,
			
			ACT_SCENE_DEPTH_RANGE,
			
			ACT_SHADOW_SCENE_DEPTH_RANGE,
            
            ACT_TEXTURE_SIZE,
            ACT_INVERSE_TEXTURE_SIZE,
            ACT_PACKED_TEXTURE_SIZE,
        };
        
        enum ACDataType {
            ACDT_NONE,
            ACDT_INT,
            ACDT_REAL
};
        
        enum ElementType {
ET_INT,
ET_REAL
};
        
		struct AutoConstantDefinition
{
AutoConstantType acType;
String name;
size_t elementCount;
            ElementType elementType;
            ACDataType dataType;
			AutoConstantDefinition(AutoConstantType _acType, const String& _name, 
size_t _elementCount, ElementType _elementType, 
ACDataType _dataType)
:acType(_acType), name(_name), elementCount(_elementCount), 
elementType(_elementType), dataType(_dataType)
{
			}
};
        
class AutoConstantEntry
{
public:
            AutoConstantType paramType;
            size_t physicalIndex;
			size_t elementCount;
			union{
size_t data;
Real fData;
};
            AutoConstantEntry(AutoConstantType theType, size_t theIndex, size_t theData, 
size_t theElemCount = 4)
: paramType(theType), physicalIndex(theIndex), elementCount(theElemCount), data(theData) {}
			AutoConstantEntry(AutoConstantType theType, size_t theIndex, Real theData, 
size_t theElemCount = 4)
: paramType(theType), physicalIndex(theIndex), elementCount(theElemCount), fData(theData) {}
        };
		typedef std::vector<AutoConstantEntry> AutoConstantList;
		
		typedef std::vector<float> FloatConstantList;
		typedef std::vector<int> IntConstantList;
	protected:
static AutoConstantDefinition AutoConstantDictionary[];
        FloatConstantList mFloatConstants;
        IntConstantList mIntConstants;
		GpuLogicalBufferStruct* mFloatLogicalToPhysical;
		GpuLogicalBufferStruct* mIntLogicalToPhysical;
		const GpuNamedConstants* mNamedConstants;
        AutoConstantList mAutoConstants;
        bool mTransposeMatrices;
		bool mIgnoreMissingParams;
        size_t mActivePassIterationIndex;
    public:
GpuProgramParameters();
~GpuProgramParameters() {}
        
GpuProgramParameters(const GpuProgramParameters& oth);
        GpuProgramParameters& operator=(const GpuProgramParameters& oth);
		
void _setNamedConstants(const GpuNamedConstants* constantmap);
		
void _setLogicalIndexes(GpuLogicalBufferStruct* floatIndexMap, 
GpuLogicalBufferStruct* intIndexMap);
		
bool hasNamedParameters() const { return mNamedConstants != 0;}
		bool hasLogicalIndexedParameters() const { return mFloatLogicalToPhysical != 0;}
		
		void setConstant(size_t index, const Vector4& vec);
		void setConstant(size_t index, Real val);
		void setConstant(size_t index, const Vector3& vec);
		void setConstant(size_t index, const Matrix4& m);
        void setConstant(size_t index, const Matrix4* m, size_t numEntries);
		void setConstant(size_t index, const float *val, size_t count);
		void setConstant(size_t index, const double *val, size_t count);
        void setConstant(size_t index, const ColourValue& colour);
		
		void setConstant(size_t index, const int *val, size_t count);
		
		void _writeRawConstants(size_t physicalIndex, const float* val, size_t count);
		void _writeRawConstants(size_t physicalIndex, const double* val, size_t count);
		void _writeRawConstants(size_t physicalIndex, const int* val, size_t count);
		void _readRawConstants(size_t physicalIndex, size_t count, float* dest);
		void _readRawConstants(size_t physicalIndex, size_t count, int* dest);
		
		void _writeRawConstant(size_t physicalIndex, const Vector4& vec, 
size_t count = 4);
		void _writeRawConstant(size_t physicalIndex, Real val);
		void _writeRawConstant(size_t physicalIndex, int val);
		void _writeRawConstant(size_t physicalIndex, const Vector3& vec);
		void _writeRawConstant(size_t physicalIndex, const Matrix4& m);
        void _writeRawConstant(size_t physicalIndex, const Matrix4* m, size_t numEntries);
        void _writeRawConstant(size_t physicalIndex, const ColourValue& colour, 
size_t count = 4);
        
        GpuConstantDefinitionIterator getConstantDefinitionIterator(void) const;
		
		const GpuConstantDefinition& getConstantDefinition(const String& name) const;
		
		const GpuNamedConstants& getConstantDefinitions() const;
		
		const GpuLogicalBufferStruct* getFloatLogicalBufferStruct() const { return mFloatLogicalToPhysical; }
		
		size_t getFloatLogicalIndexForPhysicalIndex(size_t physicalIndex);
		size_t getIntLogicalIndexForPhysicalIndex(size_t physicalIndex);
		
		const GpuLogicalBufferStruct* getIntLogicalBufferStruct() const { return mIntLogicalToPhysical; }
		const FloatConstantList& getFloatConstantList() const { return mFloatConstants; }
		float* getFloatPointer(size_t pos) { return &mFloatConstants[pos]; }
		const float* getFloatPointer(size_t pos) const { return &mFloatConstants[pos]; }
		const IntConstantList& getIntConstantList() const { return mIntConstants; }
		int* getIntPointer(size_t pos) { return &mIntConstants[pos]; }
		const int* getIntPointer(size_t pos) const { return &mIntConstants[pos]; }
		const AutoConstantList& getAutoConstantList() const { return mAutoConstants; }
        
        void setAutoConstant(size_t index, AutoConstantType acType, size_t extraInfo = 0);
void setAutoConstantReal(size_t index, AutoConstantType acType, Real rData);
		
		void _setRawAutoConstant(size_t physicalIndex, AutoConstantType acType, size_t extraInfo, 
size_t elementSize = 4);
		void _setRawAutoConstantReal(size_t physicalIndex, AutoConstantType acType, Real rData, 
size_t elementSize = 4);
		
void clearAutoConstant(size_t index);
        
  
void setConstantFromTime(size_t index, Real factor);
        
void clearAutoConstants(void);
typedef ConstVectorIterator<AutoConstantList> AutoConstantIterator;
        AutoConstantIterator getAutoConstantIterator(void) const;
        size_t getAutoConstantCount(void) const { return mAutoConstants.size(); }
		AutoConstantEntry* getAutoConstantEntry(const size_t index);
        bool hasAutoConstants(void) const { return !(mAutoConstants.empty()); }
		const AutoConstantEntry* findFloatAutoConstantEntry(size_t logicalIndex);
		const AutoConstantEntry* findIntAutoConstantEntry(size_t logicalIndex);
		const AutoConstantEntry* findAutoConstantEntry(const String& paramName);
		const AutoConstantEntry* _findRawAutoConstantEntryFloat(size_t physicalIndex);
		const AutoConstantEntry* _findRawAutoConstantEntryInt(size_t physicalIndex);
        
void _updateAutoParamsNoLights(const AutoParamDataSource& source);
        void _updateAutoParamsLightsOnly(const AutoParamDataSource& source);
		
		void setIgnoreMissingParams(bool state) { mIgnoreMissingParams = state; }
		
		void setNamedConstant(const String& name, Real val);
		void setNamedConstant(const String& name, int val);
		void setNamedConstant(const String& name, const Vector4& vec);
		void setNamedConstant(const String& name, const Vector3& vec);
		void setNamedConstant(const String& name, const Matrix4& m);
        void setNamedConstant(const String& name, const Matrix4* m, size_t numEntries);
		void setNamedConstant(const String& name, const float *val, size_t count, 
size_t multiple = 4);
		void setNamedConstant(const String& name, const double *val, size_t count, 
size_t multiple = 4);
        void setNamedConstant(const String& name, const ColourValue& colour);
		
		void setNamedConstant(const String& name, const int *val, size_t count, 
size_t multiple = 4);
        
        void setNamedAutoConstant(const String& name, AutoConstantType acType, size_t extraInfo = 0);
void setNamedAutoConstantReal(const String& name, AutoConstantType acType, Real rData);
        
  
void setNamedConstantFromTime(const String& name, Real factor);
		
void clearNamedAutoConstant(const String& name);
        
        const GpuConstantDefinition* _findNamedConstantDefinition(
const String& name, bool throwExceptionIfMissing = false) const;
		size_t _getFloatConstantPhysicalIndex(size_t logicalIndex, size_t requestedSize);
		size_t _getIntConstantPhysicalIndex(size_t logicalIndex, size_t requestedSize);
        
        void setTransposeMatrices(bool val) { mTransposeMatrices = val; } 
        bool getTransposeMatrices(void) const { return mTransposeMatrices; } 
		
		void copyConstantsFrom(const GpuProgramParameters& source);
        
        static const AutoConstantDefinition* getAutoConstantDefinition(const String& name);
        static const AutoConstantDefinition* getAutoConstantDefinition(const size_t idx);
        static size_t getNumAutoConstantDefinitions(void);
        
        void incPassIterationNumber(void);
		bool hasPassIterationNumber() const 
{ return mActivePassIterationIndex != (std::numeric_limits<size_t>::max)(); }
		size_t getPassIterationNumberIndex() const 
{ return mActivePassIterationIndex; }
    };
    
typedef SharedPtr<GpuProgramParameters> GpuProgramParametersSharedPtr;
    
class GpuProgramPtr;
	
	class __declspec( dllexport ) GpuProgram : public Resource
{
protected:
		class __declspec( dllexport ) CmdType : public ParamCommand
{
public:
String doGet(const void* target) const;
void doSet(void* target, const String& val);
};
class __declspec( dllexport ) CmdSyntax : public ParamCommand
{
public:
String doGet(const void* target) const;
void doSet(void* target, const String& val);
};
class __declspec( dllexport ) CmdSkeletal : public ParamCommand
{
public:
String doGet(const void* target) const;
void doSet(void* target, const String& val);
};
class __declspec( dllexport ) CmdMorph : public ParamCommand
{
public:
String doGet(const void* target) const;
void doSet(void* target, const String& val);
};
class __declspec( dllexport ) CmdPose : public ParamCommand
{
public:
String doGet(const void* target) const;
void doSet(void* target, const String& val);
};
class __declspec( dllexport ) CmdVTF : public ParamCommand
{
public:
String doGet(const void* target) const;
void doSet(void* target, const String& val);
};
		static CmdType msTypeCmd;
static CmdSyntax msSyntaxCmd;
static CmdSkeletal msSkeletalCmd;
static CmdMorph msMorphCmd;
static CmdPose msPoseCmd;
static CmdVTF msVTFCmd;
		
GpuProgramType mType;
		String mFilename;
        String mSource;
        bool mLoadFromFile;
        String mSyntaxCode;
        bool mSkeletalAnimation;
		bool mMorphAnimation;
		ushort mPoseAnimation;
		bool mVertexTextureFetch;
		GpuProgramParametersSharedPtr mDefaultParams;
		bool mPassSurfaceAndLightStates;
		bool mCompileError;
		mutable GpuLogicalBufferStruct mFloatLogicalToPhysical;
		mutable GpuLogicalBufferStruct mIntLogicalToPhysical;
		
		void setupBaseParamDictionary(void);
        
        bool isRequiredCapabilitiesSupported(void) const;
		
size_t calculateSize(void) const { return 0; } 
		
void loadImpl(void);
public:
		GpuProgram(ResourceManager* creator, const String& name, ResourceHandle handle,
const String& group, bool isManual = false, ManualResourceLoader* loader = 0);
		virtual ~GpuProgram() {}
        
        virtual void setSourceFile(const String& filename);
		
        virtual void setSource(const String& source);
        
virtual const String& getSyntaxCode(void) const { return mSyntaxCode; }
		
virtual void setSyntaxCode(const String& syntax);
		
virtual const String& getSourceFile(void) const { return mFilename; }
        virtual const String& getSource(void) const { return mSource; }
		virtual void setType(GpuProgramType t);
        virtual GpuProgramType getType(void) const { return mType; }
        
        virtual GpuProgram* _getBindingDelegate(void) { return this; }
        
virtual bool isSupported(void) const;
        
        virtual GpuProgramParametersSharedPtr createParameters(void);
        
        virtual void setSkeletalAnimationIncluded(bool included) 
{ mSkeletalAnimation = included; }
        
        virtual bool isSkeletalAnimationIncluded(void) const { return mSkeletalAnimation; }
        
        virtual void setMorphAnimationIncluded(bool included) 
{ mMorphAnimation = included; }
        
        virtual void setPoseAnimationIncluded(ushort poseCount) 
{ mPoseAnimation = poseCount; }
		
        virtual bool isMorphAnimationIncluded(void) const { return mMorphAnimation; }
		
        virtual bool isPoseAnimationIncluded(void) const { return mPoseAnimation > 0; }
        virtual ushort getNumberOfPosesIncluded(void) const { return mPoseAnimation; }
		virtual void setVertexTextureFetchRequired(bool r) { mVertexTextureFetch = r; }
		virtual bool isVertexTextureFetchRequired(void) const { return mVertexTextureFetch; }
		
		virtual GpuProgramParametersSharedPtr getDefaultParameters(void);
        
        virtual bool hasDefaultParameters(void) const { return !mDefaultParams.isNull(); }
		
		virtual void setSurfaceAndPassLightStates(bool state)
{ mPassSurfaceAndLightStates = state; }
		
		virtual bool getPassSurfaceAndLightStates(void) const { return mPassSurfaceAndLightStates; }
        
        virtual const String& getLanguage(void) const;
		
		virtual bool hasCompileError(void) const { return mCompileError; }
		
		virtual void resetCompileError(void) { mCompileError = false; }
protected:
        virtual void loadFromSource(void) = 0;
	};
	
	class __declspec( dllexport ) GpuProgramPtr : public SharedPtr<GpuProgram> 
{
public:
GpuProgramPtr() : SharedPtr<GpuProgram>() {}
explicit GpuProgramPtr(GpuProgram* rep) : SharedPtr<GpuProgram>(rep) {}
GpuProgramPtr(const GpuProgramPtr& r) : SharedPtr<GpuProgram>(r) {} 
GpuProgramPtr(const ResourcePtr& r) : SharedPtr<GpuProgram>()
{
            if(true)
{
			    
pRep = static_cast<GpuProgram*>(r.getPointer());
pUseCount = r.useCountPointer();
if (pUseCount)
{
++(*pUseCount);
}
}
}
		
GpuProgramPtr& operator=(const ResourcePtr& r)
{
if (pRep == static_cast<GpuProgram*>(r.getPointer()))
return *this;
release();
            if(true)
{
			    
pRep = static_cast<GpuProgram*>(r.getPointer());
pUseCount = r.useCountPointer();
if (pUseCount)
{
++(*pUseCount);
}
}
else
{
				((void)0);
setNull();
}
return *this;
}
        GpuProgramPtr& operator=(const HighLevelGpuProgramPtr& r);
};
}
namespace Ogre {
	class __declspec( dllexport ) Exception : public std::exception
{
protected:
long line;
int number;
String typeName;
String description;
String source;
String file;
mutable String fullDesc;
public:
        enum ExceptionCodes {
ERR_CANNOT_WRITE_TO_FILE,
ERR_INVALID_STATE,
ERR_INVALIDPARAMS,
ERR_RENDERINGAPI_ERROR,
ERR_DUPLICATE_ITEM,
ERR_ITEM_NOT_FOUND,
ERR_FILE_NOT_FOUND,
ERR_INTERNAL_ERROR,
ERR_RT_ASSERTION_FAILED, 
ERR_NOT_IMPLEMENTED
};
        
        Exception( int number, const String& description, const String& source );
        
        Exception( int number, const String& description, const String& source, const char* type, const char* file, long line );
        
        Exception(const Exception& rhs);
		
~Exception() throw() {}
        
        void operator = (const Exception& rhs);
        
        virtual const String& getFullDescription(void) const;
        
        virtual int getNumber(void) const throw();
        
        virtual const String &getSource() const { return source; }
        
        virtual const String &getFile() const { return file; }
        
        virtual long getLine() const { return line; }
		
		virtual const String &getDescription(void) const { return description; }
		
const char* what() const throw() { return getFullDescription().c_str(); }
    };
	
	template <int num>
struct ExceptionCodeType
{
enum { number = num };
};
	
	class __declspec( dllexport ) UnimplementedException : public Exception 
{
public:
UnimplementedException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "UnimplementedException", file, line) {}
};
class __declspec( dllexport ) FileNotFoundException : public Exception
{
public:
FileNotFoundException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "FileNotFoundException", file, line) {}
};
class __declspec( dllexport ) IOException : public Exception
{
public:
IOException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "IOException", file, line) {}
};
class __declspec( dllexport ) InvalidStateException : public Exception
{
public:
InvalidStateException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "InvalidStateException", file, line) {}
};
class __declspec( dllexport ) InvalidParametersException : public Exception
{
public:
InvalidParametersException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "InvalidParametersException", file, line) {}
};
class __declspec( dllexport ) ItemIdentityException : public Exception
{
public:
ItemIdentityException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "ItemIdentityException", file, line) {}
};
class __declspec( dllexport ) InternalErrorException : public Exception
{
public:
InternalErrorException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "InternalErrorException", file, line) {}
};
class __declspec( dllexport ) RenderingAPIException : public Exception
{
public:
RenderingAPIException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "RenderingAPIException", file, line) {}
};
class __declspec( dllexport ) RuntimeAssertionException : public Exception
{
public:
RuntimeAssertionException(int number, const String& description, const String& source, const char* file, long line)
: Exception(number, description, source, "RuntimeAssertionException", file, line) {}
};
	
	class ExceptionFactory
{
private:
		ExceptionFactory() {}
public:
static UnimplementedException create(
ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return UnimplementedException(code.number, desc, src, file, line);
}
static FileNotFoundException create(
ExceptionCodeType<Exception::ERR_FILE_NOT_FOUND> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return FileNotFoundException(code.number, desc, src, file, line);
}
static IOException create(
ExceptionCodeType<Exception::ERR_CANNOT_WRITE_TO_FILE> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return IOException(code.number, desc, src, file, line);
}
static InvalidStateException create(
ExceptionCodeType<Exception::ERR_INVALID_STATE> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return InvalidStateException(code.number, desc, src, file, line);
}
static InvalidParametersException create(
ExceptionCodeType<Exception::ERR_INVALIDPARAMS> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return InvalidParametersException(code.number, desc, src, file, line);
}
static ItemIdentityException create(
ExceptionCodeType<Exception::ERR_ITEM_NOT_FOUND> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return ItemIdentityException(code.number, desc, src, file, line);
}
static ItemIdentityException create(
ExceptionCodeType<Exception::ERR_DUPLICATE_ITEM> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return ItemIdentityException(code.number, desc, src, file, line);
}
static InternalErrorException create(
ExceptionCodeType<Exception::ERR_INTERNAL_ERROR> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return InternalErrorException(code.number, desc, src, file, line);
}
static RenderingAPIException create(
ExceptionCodeType<Exception::ERR_RENDERINGAPI_ERROR> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return RenderingAPIException(code.number, desc, src, file, line);
}
static RuntimeAssertionException create(
ExceptionCodeType<Exception::ERR_RT_ASSERTION_FAILED> code, 
const String& desc, 
const String& src, const char* file, long line)
{
return RuntimeAssertionException(code.number, desc, src, file, line);
}
	};
	
} 
namespace Ogre {
    
    class __declspec( dllexport ) Renderable
{
public:
Renderable() : mPolygonModeOverrideable(true), mUseIdentityProjection(false), mUseIdentityView(false) {}
        virtual ~Renderable() { }
        virtual const MaterialPtr& getMaterial(void) const = 0;
        virtual Technique* getTechnique(void) const { return getMaterial()->getBestTechnique(); }
        virtual void getRenderOperation(RenderOperation& op) = 0;
        virtual void getWorldTransforms(Matrix4* xform) const = 0;
        virtual const Quaternion& getWorldOrientation(void) const = 0;
        virtual const Vector3& getWorldPosition(void) const = 0;
        
        virtual unsigned short getNumWorldTransforms(void) const { return 1; }
        
        void setUseIdentityProjection(bool useIdentityProjection)
{
mUseIdentityProjection = useIdentityProjection;
}
        
        bool getUseIdentityProjection(void) const { return mUseIdentityProjection; }
        
        void setUseIdentityView(bool useIdentityView)
{
mUseIdentityView = useIdentityView;
}
        
        bool getUseIdentityView(void) const { return mUseIdentityView; }
		
		virtual Real getSquaredViewDepth(const Camera* cam) const = 0;
        
virtual bool getNormaliseNormals(void) const { return false; }
        
        virtual const LightList& getLights(void) const = 0;
        virtual const PlaneList& getClipPlanes() const { return msDummyPlaneList; };
        
        virtual bool getCastsShadows(void) const { return false; }
        
        void setCustomParameter(size_t index, const Vector4& value) 
{
mCustomParameters[index] = value;
}
        
        const Vector4& getCustomParameter(size_t index) const
{
CustomParameterMap::const_iterator i = mCustomParameters.find(index);
if (i != mCustomParameters.end())
{
return i->second;
}
else
{
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_ITEM_NOT_FOUND>(), "Parameter at the given index was not found.", "Renderable::getCustomParameter", "d:\\projects\\ogrenew\\ogremain\\include\\OgreRenderable.h", 224 );;
}
}
        
        virtual void _updateCustomGpuParameter(
const GpuProgramParameters::AutoConstantEntry& constantEntry,
GpuProgramParameters* params) const
{
CustomParameterMap::const_iterator i = mCustomParameters.find(constantEntry.data);
if (i != mCustomParameters.end())
{
params->_writeRawConstant(constantEntry.physicalIndex, i->second, 
constantEntry.elementCount);
}
}
		
		virtual void setPolygonModeOverrideable(bool override)
{
mPolygonModeOverrideable = override;
}
		
		virtual bool getPolygonModeOverrideable(void) const
{
return mPolygonModeOverrideable;
}
    protected:
static const PlaneList msDummyPlaneList;
typedef std::map<size_t, Vector4> CustomParameterMap;
CustomParameterMap mCustomParameters;
bool mPolygonModeOverrideable;
bool mUseIdentityProjection;
bool mUseIdentityView;
};
}
namespace Ogre {
    
    class __declspec( dllexport ) ShadowRenderable : public Renderable
{
protected:
MaterialPtr mMaterial;
RenderOperation mRenderOp;
ShadowRenderable* mLightCap; 
public:
ShadowRenderable() : mMaterial(), mLightCap(0) {}
virtual ~ShadowRenderable() { delete mLightCap; }
        void setMaterial(const MaterialPtr& mat) { mMaterial = mat; }
        const MaterialPtr& getMaterial(void) const { return mMaterial; }
        void getRenderOperation(RenderOperation& op) { op = mRenderOp; }
        RenderOperation* getRenderOperationForUpdate(void) {return &mRenderOp;}
        void getWorldTransforms(Matrix4* xform) const = 0;
        const Quaternion& getWorldOrientation(void) const = 0;
        const Vector3& getWorldPosition(void) const = 0;
        Real getSquaredViewDepth(const Camera*) const{ return 0; }
        const LightList& getLights(void) const;
        bool isLightCapSeparate(void) const { return mLightCap != 0; }
        
ShadowRenderable* getLightCapRenderable(void) { return mLightCap; }
        virtual bool isVisible(void) const { return true; }
    };
    
enum ShadowRenderableFlags
{
        SRF_INCLUDE_LIGHT_CAP = 0x00000001,
        SRF_INCLUDE_DARK_CAP  = 0x00000002,
        SRF_EXTRUDE_TO_INFINITY  = 0x00000004
};
    
    class __declspec( dllexport ) ShadowCaster
{
public:
virtual ~ShadowCaster() { }
        virtual bool getCastShadows(void) const = 0;
        
virtual EdgeData* getEdgeList(void) = 0;
		virtual bool hasEdgeList(void) = 0;
        
virtual const AxisAlignedBox& getWorldBoundingBox(bool derive = false) const = 0;
        virtual const AxisAlignedBox& getLightCapBounds(void) const = 0;
        virtual const AxisAlignedBox& getDarkCapBounds(const Light& light, Real dirLightExtrusionDist) const = 0;
        typedef std::vector<ShadowRenderable*> ShadowRenderableList;
typedef VectorIterator<ShadowRenderableList> ShadowRenderableListIterator;
        
        virtual ShadowRenderableListIterator getShadowVolumeRenderableIterator(
ShadowTechnique shadowTechnique, const Light* light, 
HardwareIndexBufferSharedPtr* indexBuffer, 
bool extrudeVertices, Real extrusionDistance, unsigned long flags = 0 ) = 0;
        
        static void extrudeVertices(const HardwareVertexBufferSharedPtr& vertexBuffer, 
size_t originalVertexCount, const Vector4& lightPos, Real extrudeDist);
        virtual Real getPointExtrusionDistance(const Light* l) const = 0;
protected:
        Real getExtrusionDistance(const Vector3& objectPos, const Light* light) const;
        virtual void updateEdgeListLightFacing(EdgeData* edgeData, 
const Vector4& lightPos);
        
        virtual void generateShadowVolume(EdgeData* edgeData, 
const HardwareIndexBufferSharedPtr& indexBuffer, const Light* light,
ShadowRenderableList& shadowRenderables, unsigned long flags);
        virtual void extrudeBounds(AxisAlignedBox& box, const Vector4& lightPos, 
Real extrudeDist) const;
    };
}
namespace Ogre {
    
    template< typename T > class FactoryObj
{
public:
virtual ~FactoryObj() {};
        
        virtual const String& getType() const = 0;
        
        virtual T* createInstance( const String& name ) = 0;    
        virtual void destroyInstance( T* ) = 0;    
};
} 
namespace Ogre
{
    
    class __declspec( dllexport ) Vector2
{
public:
Real x, y;
    public:
inline Vector2()
{
}
        inline Vector2(const Real fX, const Real fY )
: x( fX ), y( fY )
{
}
        inline explicit Vector2( const Real scaler )
: x( scaler), y( scaler )
{
}
        inline explicit Vector2( const Real afCoordinate[2] )
: x( afCoordinate[0] ),
y( afCoordinate[1] )
{
}
        inline explicit Vector2( const int afCoordinate[2] )
{
x = (Real)afCoordinate[0];
y = (Real)afCoordinate[1];
}
        inline explicit Vector2( Real* const r )
: x( r[0] ), y( r[1] )
{
}
        inline Vector2( const Vector2& rkVector )
: x( rkVector.x ), y( rkVector.y )
{
}
		inline Real operator [] ( const size_t i ) const
{
((void)0);
            return *(&x+i);
}
		inline Real& operator [] ( const size_t i )
{
((void)0);
            return *(&x+i);
}
		
inline Real* ptr()
{
return &x;
}
		inline const Real* ptr() const
{
return &x;
}
        
        inline Vector2& operator = ( const Vector2& rkVector )
{
x = rkVector.x;
y = rkVector.y;
            return *this;
}
		inline Vector2& operator = ( const Real fScalar)
{
x = fScalar;
y = fScalar;
			return *this;
}
        inline bool operator == ( const Vector2& rkVector ) const
{
return ( x == rkVector.x && y == rkVector.y );
}
        inline bool operator != ( const Vector2& rkVector ) const
{
return ( x != rkVector.x || y != rkVector.y  );
}
        
inline Vector2 operator + ( const Vector2& rkVector ) const
{
return Vector2(
x + rkVector.x,
y + rkVector.y);
}
        inline Vector2 operator - ( const Vector2& rkVector ) const
{
return Vector2(
x - rkVector.x,
y - rkVector.y);
}
        inline Vector2 operator * ( const Real fScalar ) const
{
return Vector2(
x * fScalar,
y * fScalar);
}
        inline Vector2 operator * ( const Vector2& rhs) const
{
return Vector2(
x * rhs.x,
y * rhs.y);
}
        inline Vector2 operator / ( const Real fScalar ) const
{
((void)0);
            Real fInv = 1.0 / fScalar;
            return Vector2(
x * fInv,
y * fInv);
}
        inline Vector2 operator / ( const Vector2& rhs) const
{
return Vector2(
x / rhs.x,
y / rhs.y);
}
        inline const Vector2& operator + () const
{
return *this;
}
        inline Vector2 operator - () const
{
return Vector2(-x, -y);
}
        
inline friend Vector2 operator * ( const Real fScalar, const Vector2& rkVector )
{
return Vector2(
fScalar * rkVector.x,
fScalar * rkVector.y);
}
        inline friend Vector2 operator / ( const Real fScalar, const Vector2& rkVector )
{
return Vector2(
fScalar / rkVector.x,
fScalar / rkVector.y);
}
        inline friend Vector2 operator + (const Vector2& lhs, const Real rhs)
{
return Vector2(
lhs.x + rhs,
lhs.y + rhs);
}
        inline friend Vector2 operator + (const Real lhs, const Vector2& rhs)
{
return Vector2(
lhs + rhs.x,
lhs + rhs.y);
}
        inline friend Vector2 operator - (const Vector2& lhs, const Real rhs)
{
return Vector2(
lhs.x - rhs,
lhs.y - rhs);
}
        inline friend Vector2 operator - (const Real lhs, const Vector2& rhs)
{
return Vector2(
lhs - rhs.x,
lhs - rhs.y);
}
        inline Vector2& operator += ( const Vector2& rkVector )
{
x += rkVector.x;
y += rkVector.y;
            return *this;
}
        inline Vector2& operator += ( const Real fScaler )
{
x += fScaler;
y += fScaler;
            return *this;
}
        inline Vector2& operator -= ( const Vector2& rkVector )
{
x -= rkVector.x;
y -= rkVector.y;
            return *this;
}
        inline Vector2& operator -= ( const Real fScaler )
{
x -= fScaler;
y -= fScaler;
            return *this;
}
        inline Vector2& operator *= ( const Real fScalar )
{
x *= fScalar;
y *= fScalar;
            return *this;
}
        inline Vector2& operator *= ( const Vector2& rkVector )
{
x *= rkVector.x;
y *= rkVector.y;
            return *this;
}
        inline Vector2& operator /= ( const Real fScalar )
{
((void)0);
            Real fInv = 1.0 / fScalar;
            x *= fInv;
y *= fInv;
            return *this;
}
        inline Vector2& operator /= ( const Vector2& rkVector )
{
x /= rkVector.x;
y /= rkVector.y;
            return *this;
}
        
        inline Real length () const
{
return Math::Sqrt( x * x + y * y );
}
        
        inline Real squaredLength () const
{
return x * x + y * y;
}
        
        inline Real dotProduct(const Vector2& vec) const
{
return x * vec.x + y * vec.y;
}
        
        inline Real normalise()
{
Real fLength = Math::Sqrt( x * x + y * y);
            
if ( fLength > 1e-08 )
{
Real fInvLength = 1.0 / fLength;
x *= fInvLength;
y *= fInvLength;
}
            return fLength;
}
        
        inline Vector2 midPoint( const Vector2& vec ) const
{
return Vector2(
( x + vec.x ) * 0.5,
( y + vec.y ) * 0.5 );
}
        
        inline bool operator < ( const Vector2& rhs ) const
{
if( x < rhs.x && y < rhs.y )
return true;
return false;
}
        
        inline bool operator > ( const Vector2& rhs ) const
{
if( x > rhs.x && y > rhs.y )
return true;
return false;
}
        
        inline void makeFloor( const Vector2& cmp )
{
if( cmp.x < x ) x = cmp.x;
if( cmp.y < y ) y = cmp.y;
}
        
        inline void makeCeil( const Vector2& cmp )
{
if( cmp.x > x ) x = cmp.x;
if( cmp.y > y ) y = cmp.y;
}
        
        inline Vector2 perpendicular(void) const
{
return Vector2 (-y, x);
}
        inline Real crossProduct( const Vector2& rkVector ) const
{
return x * rkVector.y - y * rkVector.x;
}
        inline Vector2 randomDeviant(
Real angle) const
{
            angle *=  Math::UnitRandom() * Math::TWO_PI;
Real cosa = cos(angle);
Real sina = sin(angle);
return  Vector2(cosa * x - sina * y,
sina * x + cosa * y);
}
        
inline bool isZeroLength(void) const
{
Real sqlen = (x * x) + (y * y);
return (sqlen < (1e-06 * 1e-06));
        }
        
        inline Vector2 normalisedCopy(void) const
{
Vector2 ret = *this;
ret.normalise();
return ret;
}
        
        inline Vector2 reflect(const Vector2& normal) const
{
return Vector2( *this - ( 2 * this->dotProduct(normal) * normal ) );
}
        
static const Vector2 ZERO;
static const Vector2 UNIT_X;
static const Vector2 UNIT_Y;
static const Vector2 NEGATIVE_UNIT_X;
static const Vector2 NEGATIVE_UNIT_Y;
static const Vector2 UNIT_SCALE;
        
        inline __declspec( dllexport ) friend std::ostream& operator <<
( std::ostream& o, const Vector2& v )
{
o << "Vector2(" << v.x << ", " << v.y <<  ")";
return o;
}
    };
}
namespace Ogre
{
    class Any
{
public: 
        Any()
: mContent(0)
{
}
        template<typename ValueType>
explicit Any(const ValueType & value)
: mContent(new holder<ValueType>(value))
{
}
        Any(const Any & other)
: mContent(other.mContent ? other.mContent->clone() : 0)
{
}
        virtual ~Any()
{
delete mContent;
}
    public: 
        Any& swap(Any & rhs)
{
std::swap(mContent, rhs.mContent);
return *this;
}
        template<typename ValueType>
Any& operator=(const ValueType & rhs)
{
Any(rhs).swap(*this);
return *this;
}
        Any & operator=(const Any & rhs)
{
Any(rhs).swap(*this);
return *this;
}
    public: 
        bool isEmpty() const
{
return !mContent;
}
        const std::type_info& getType() const
{
return mContent ? mContent->getType() : typeid(void);
}
		inline friend std::ostream& operator <<
( std::ostream& o, const Any& v )
{
if (v.mContent)
v.mContent->writeToStream(o);
return o;
}
    protected: 
        class placeholder
{
public: 
            virtual ~placeholder()
{
}
        public: 
            virtual const std::type_info& getType() const = 0;
            virtual placeholder * clone() const = 0;
			virtual void writeToStream(std::ostream& o) = 0;
        };
        template<typename ValueType>
class holder : public placeholder
{
public: 
            holder(const ValueType & value)
: held(value)
{
}
        public: 
            virtual const std::type_info & getType() const
{
return typeid(ValueType);
}
            virtual placeholder * clone() const
{
return new holder(held);
}
			virtual void writeToStream(std::ostream& o)
{
o << held;
}
        public: 
            ValueType held;
        };
    protected: 
placeholder * mContent;
        template<typename ValueType>
friend ValueType * any_cast(Any *);
    public: 
	    template<typename ValueType>
ValueType operator()() const
{
if (!mContent) 
{
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_INVALIDPARAMS>(), "Bad cast from uninitialised Any", "Any::operator()", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAny.h", 190 );;
}
else if(getType() == typeid(ValueType))
{
return static_cast<Any::holder<ValueType> *>(mContent)->held;
}
else
{
StringUtil::StrStreamType str;
str << "Bad cast from type '" << getType().name() << "' "
<< "to '" << typeid(ValueType).name() << "'";
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_INVALIDPARAMS>(), str.str(), "Any::operator()", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAny.h", 203 );;
}
}
		
    };
	
	class AnyNumeric : public Any
{
public:
AnyNumeric()
: Any()
{
}
		template<typename ValueType>
AnyNumeric(const ValueType & value)
		{
mContent = new numholder<ValueType>(value);
}
		AnyNumeric(const AnyNumeric & other)
: Any()
{
mContent = other.mContent ? other.mContent->clone() : 0; 
}
protected:
class numplaceholder : public Any::placeholder
{
public: 
			~numplaceholder()
{
}
virtual placeholder* add(placeholder* rhs) = 0;
virtual placeholder* subtract(placeholder* rhs) = 0;
virtual placeholder* multiply(placeholder* rhs) = 0;
virtual placeholder* multiply(Real factor) = 0;
virtual placeholder* divide(placeholder* rhs) = 0;
};
		template<typename ValueType>
class numholder : public numplaceholder
{
public: 
			numholder(const ValueType & value)
: held(value)
{
}
		public: 
			virtual const std::type_info & getType() const
{
return typeid(ValueType);
}
			virtual placeholder * clone() const
{
return new numholder(held);
}
			virtual placeholder* add(placeholder* rhs)
{
return new numholder(held + static_cast<numholder*>(rhs)->held);
}
virtual placeholder* subtract(placeholder* rhs)
{
return new numholder(held - static_cast<numholder*>(rhs)->held);
}
virtual placeholder* multiply(placeholder* rhs)
{
return new numholder(held * static_cast<numholder*>(rhs)->held);
}
virtual placeholder* multiply(Real factor)
{
return new numholder(held * factor);
}
virtual placeholder* divide(placeholder* rhs)
{
return new numholder(held / static_cast<numholder*>(rhs)->held);
}
virtual void writeToStream(std::ostream& o)
{
o << held;
}
		public: 
			ValueType held;
		};
		
AnyNumeric(placeholder* pholder)
{
mContent = pholder;
}
	public:
AnyNumeric & operator=(const AnyNumeric & rhs)
{
AnyNumeric(rhs).swap(*this);
return *this;
}
AnyNumeric operator+(const AnyNumeric& rhs) const
{
return AnyNumeric(
static_cast<numplaceholder*>(mContent)->add(rhs.mContent));
}
AnyNumeric operator-(const AnyNumeric& rhs) const
{
return AnyNumeric(
static_cast<numplaceholder*>(mContent)->subtract(rhs.mContent));
}
AnyNumeric operator*(const AnyNumeric& rhs) const
{
return AnyNumeric(
static_cast<numplaceholder*>(mContent)->multiply(rhs.mContent));
}
AnyNumeric operator*(Real factor) const
{
return AnyNumeric(
static_cast<numplaceholder*>(mContent)->multiply(factor));
}
AnyNumeric operator/(const AnyNumeric& rhs) const
{
return AnyNumeric(
static_cast<numplaceholder*>(mContent)->divide(rhs.mContent));
}
AnyNumeric& operator+=(const AnyNumeric& rhs)
{
*this = AnyNumeric(
static_cast<numplaceholder*>(mContent)->add(rhs.mContent));
return *this;
}
AnyNumeric& operator-=(const AnyNumeric& rhs)
{
*this = AnyNumeric(
static_cast<numplaceholder*>(mContent)->subtract(rhs.mContent));
return *this;
}
AnyNumeric& operator*=(const AnyNumeric& rhs)
{
*this = AnyNumeric(
static_cast<numplaceholder*>(mContent)->multiply(rhs.mContent));
return *this;
}
AnyNumeric& operator/=(const AnyNumeric& rhs)
{
*this = AnyNumeric(
static_cast<numplaceholder*>(mContent)->divide(rhs.mContent));
return *this;
}
	};
    template<typename ValueType>
ValueType * any_cast(Any * operand)
{
return operand && operand->getType() == typeid(ValueType)
? &static_cast<Any::holder<ValueType> *>(operand->mContent)->held
: 0;
}
    template<typename ValueType>
const ValueType * any_cast(const Any * operand)
{
return any_cast<ValueType>(const_cast<Any *>(operand));
}
    template<typename ValueType>
ValueType any_cast(const Any & operand)
{
const ValueType * result = any_cast<ValueType>(&operand);
if(!result)
{
StringUtil::StrStreamType str;
str << "Bad cast from type '" << operand.getType().name() << "' "
<< "to '" << typeid(ValueType).name() << "'";
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_INVALIDPARAMS>(), str.str(), "Ogre::any_cast", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAny.h", 396 );;
}
return *result;
}
}
namespace Ogre {
	
	class __declspec( dllexport ) AnimableValue
{
public:
		enum ValueType
{
INT,
REAL,
VECTOR2,
VECTOR3,
VECTOR4,
QUATERNION,
COLOUR
};
protected:
		ValueType mType;
		
union
{
int mBaseValueInt;
Real mBaseValueReal[4];
};
		
virtual void setAsBaseValue(int val) { mBaseValueInt = val; }
		virtual void setAsBaseValue(Real val) { mBaseValueReal[0] = val; }
		virtual void setAsBaseValue(const Vector2& val) 
{ memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*2); }
		virtual void setAsBaseValue(const Vector3& val) 
{ memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*3); }
		virtual void setAsBaseValue(const Vector4& val) 
{ memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*4); }
		virtual void setAsBaseValue(const Quaternion& val) 
{ memcpy(mBaseValueReal, val.ptr(), sizeof(Real)*4); }
		virtual void setAsBaseValue(const Any& val);
		virtual void setAsBaseValue(const ColourValue& val)
{ 
mBaseValueReal[0] = val.r;
mBaseValueReal[1] = val.g;
mBaseValueReal[2] = val.b;
mBaseValueReal[3] = val.a;
}
	public:
AnimableValue(ValueType t) : mType(t) {}
virtual ~AnimableValue() {}
		
ValueType getType(void) const { return mType; }
		
virtual void setCurrentStateAsBaseValue(void) = 0;
		
virtual void setValue(int) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 130 );;
}
		virtual void setValue(Real) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 134 );;
}
		virtual void setValue(const Vector2&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 138 );;
}
		virtual void setValue(const Vector3&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 142 );;
}
		virtual void setValue(const Vector4&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 146 );;
}
		virtual void setValue(const Quaternion&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 150 );;
}
		virtual void setValue(const ColourValue&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 154 );;
}
		virtual void setValue(const Any& val);
		
virtual void resetToBaseValue(void);
		
virtual void applyDeltaValue(int) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 164 );;
}
		virtual void applyDeltaValue(Real) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 168 );;
}
		virtual void applyDeltaValue(const Vector2&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 172 );;
}
		virtual void applyDeltaValue(const Vector3&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 176 );;
}
		virtual void applyDeltaValue(const Vector4&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 180 );;
}
		virtual void applyDeltaValue(const Quaternion&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 184 );;
}
		virtual void applyDeltaValue(const ColourValue&) {
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_NOT_IMPLEMENTED>(), "", "", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 188 );;
}
		virtual void applyDeltaValue(const Any& val);
	};
	typedef SharedPtr<AnimableValue> AnimableValuePtr;
	
	class __declspec( dllexport ) AnimableObject
{
protected:
typedef std::map<String, StringVector> AnimableDictionaryMap;
		static AnimableDictionaryMap msAnimableDictionary;
		virtual const String& getAnimableDictionaryName(void) const 
{ return StringUtil::BLANK; }
        void createAnimableDictionary(void) const
{
if (msAnimableDictionary.find(getAnimableDictionaryName()) 
== msAnimableDictionary.end())
{
StringVector vec;
initialiseAnimableDictionary(vec);
msAnimableDictionary[getAnimableDictionaryName()] = vec;
}
        }
		
StringVector& _getAnimableValueNames(void)
{
AnimableDictionaryMap::iterator i = 
msAnimableDictionary.find(getAnimableDictionaryName());
if (i != msAnimableDictionary.end())
{
return i->second;
}
else
{
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_ITEM_NOT_FOUND>(), "Animable value list not found for " + getAnimableDictionaryName(), "AnimableObject::getAnimableValueNames", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 244 );;
}
		}
		
		virtual void initialiseAnimableDictionary(StringVector&) const {}
	public:
AnimableObject() {}
virtual ~AnimableObject() {}
		
const StringVector& getAnimableValueNames(void) const
{
createAnimableDictionary();
			AnimableDictionaryMap::iterator i = 
msAnimableDictionary.find(getAnimableDictionaryName());
if (i != msAnimableDictionary.end())
{
return i->second;
}
else
{
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_ITEM_NOT_FOUND>(), "Animable value list not found for " + getAnimableDictionaryName(), "AnimableObject::getAnimableValueNames", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 274 );;
}
		}
		
		virtual AnimableValuePtr createAnimableValue(const String& valueName)
{
throw Ogre::ExceptionFactory::create( Ogre::ExceptionCodeType<Exception::ERR_ITEM_NOT_FOUND>(), "No animable value named '" + valueName + "' present.", "AnimableObject::createAnimableValue", "d:\\projects\\ogrenew\\ogremain\\include\\OgreAnimable.h", 289 );;
}
	};
}
namespace Ogre {
    
    class __declspec( dllexport ) UserDefinedObject
{
public:
        UserDefinedObject();
virtual ~UserDefinedObject() {}
        
        virtual long getTypeID(void) const;
        
        virtual const String& getTypeName(void) const;
    };
        
}
namespace Ogre {
	
class MovableObjectFactory;
    
    class __declspec( dllexport ) MovableObject : public ShadowCaster, public AnimableObject
{
public:
        class __declspec( dllexport ) Listener
{
public:
Listener(void) {}
virtual ~Listener() {}
            virtual void objectDestroyed(MovableObject*) {}
            virtual void objectAttached(MovableObject*) {}
            virtual void objectDetached(MovableObject*) {}
            virtual void objectMoved(MovableObject*) {}
            virtual bool objectRendering(const MovableObject*, const Camera*) { return true; }
            virtual const LightList* objectQueryLights(const MovableObject*) { return 0; }
};
    protected:
		String mName;
		MovableObjectFactory* mCreator;
		SceneManager* mManager;
        Node* mParentNode;
bool mParentIsTagPoint;
        bool mVisible;
		Real mUpperDistance;
Real mSquaredUpperDistance;
		bool mBeyondFarDistance;
		Any mUserAny;
        uint8 mRenderQueueID;
		bool mRenderQueueIDSet;
        uint32 mQueryFlags;
        uint32 mVisibilityFlags;
        mutable AxisAlignedBox mWorldAABB;
		mutable Sphere mWorldBoundingSphere;
        mutable AxisAlignedBox mWorldDarkCapBounds;
        bool mCastShadows;
        
bool mRenderingDisabled;
        Listener* mListener;
        
mutable LightList mLightList;
        mutable ulong mLightListUpdated;
		
		static uint32 msDefaultQueryFlags;
		static uint32 msDefaultVisibilityFlags;
    public:
        MovableObject();
		
MovableObject(const String& name);
        virtual ~MovableObject();
		
virtual void _notifyCreator(MovableObjectFactory* fact) { mCreator = fact; }
		virtual MovableObjectFactory*  _getCreator(void) const { return mCreator; }
		virtual void _notifyManager(SceneManager* man) { mManager = man; }
		virtual SceneManager* _getManager(void) const { return mManager; }
        
virtual const String& getName(void) const { return mName; }
        
virtual const String& getMovableType(void) const = 0;
        
        virtual Node* getParentNode(void) const;
        
        virtual SceneNode* getParentSceneNode(void) const;
        
        virtual void _notifyAttached(Node* parent, bool isTagPoint = false);
        
virtual bool isAttached(void) const;
        
        virtual bool isInScene(void) const;
        
        virtual void _notifyMoved(void);
		
        virtual void _notifyCurrentCamera(Camera* cam);
        
        virtual const AxisAlignedBox& getBoundingBox(void) const = 0;
		
		virtual Real getBoundingRadius(void) const = 0;
        
virtual const AxisAlignedBox& getWorldBoundingBox(bool derive = false) const;
        virtual const Sphere& getWorldBoundingSphere(bool derive = false) const;
        virtual void _updateRenderQueue(RenderQueue* queue) = 0;
        
        virtual void setVisible(bool visible);
        
        virtual bool getVisible(void) const;
        
        virtual bool isVisible(void) const;
		
		virtual void setRenderingDistance(Real dist) { 
mUpperDistance = dist; 
mSquaredUpperDistance = mUpperDistance * mUpperDistance;
}
		
virtual Real getRenderingDistance(void) const { return mUpperDistance; }
        
        virtual void setUserObject(UserDefinedObject* obj) { mUserAny = Any(obj); }
        virtual UserDefinedObject* getUserObject(void) 
{ 
return mUserAny.isEmpty() ? 0 : any_cast<UserDefinedObject*>(mUserAny); 
}
		
		virtual void setUserAny(const Any& anything) { mUserAny = anything; }
		
		virtual const Any& getUserAny(void) const { return mUserAny; }
        
        virtual void setRenderQueueGroup(uint8 queueID);
        
virtual uint8 getRenderQueueGroup(void) const;
		
virtual const Matrix4& _getParentNodeFullTransform(void) const;
        
        virtual void setQueryFlags(uint32 flags) { mQueryFlags = flags; }
        
        virtual void addQueryFlags(uint32 flags) { mQueryFlags |= flags; }
        
        virtual void removeQueryFlags(unsigned long flags) { mQueryFlags &= ~flags; }
        
virtual uint32 getQueryFlags(void) const { return mQueryFlags; }
		
		static void setDefaultQueryFlags(uint32 flags) { msDefaultQueryFlags = flags; }
		
		static uint32 getDefaultQueryFlags() { return msDefaultQueryFlags; }
		
        virtual void setVisibilityFlags(uint32 flags) { mVisibilityFlags = flags; }
        
        virtual void addVisibilityFlags(uint32 flags) { mVisibilityFlags |= flags; }
        
        virtual void removeVisibilityFlags(uint32 flags) { mVisibilityFlags &= ~flags; }
        
virtual uint32 getVisibilityFlags(void) const { return mVisibilityFlags; }
		
		static void setDefaultVisibilityFlags(uint32 flags) { msDefaultVisibilityFlags = flags; }
		
		static uint32 getDefaultVisibilityFlags() { return msDefaultVisibilityFlags; }
        
        virtual void setListener(Listener* listener) { mListener = listener; }
        
        virtual Listener* getListener(void) const { return mListener; }
        
        virtual const LightList& queryLights(void) const;
		
EdgeData* getEdgeList(void) { return 0; }
		bool hasEdgeList(void) { return false; }
        ShadowRenderableListIterator getShadowVolumeRenderableIterator(
ShadowTechnique shadowTechnique, const Light* light, 
HardwareIndexBufferSharedPtr* indexBuffer, 
bool extrudeVertices, Real extrusionDist, unsigned long flags = 0);
        
const AxisAlignedBox& getLightCapBounds(void) const;
        const AxisAlignedBox& getDarkCapBounds(const Light& light, Real dirLightExtrusionDist) const;
        void setCastShadows(bool enabled) { mCastShadows = enabled; }
        bool getCastShadows(void) const { return mCastShadows; }
        Real getPointExtrusionDistance(const Light* l) const;
		virtual uint32 getTypeFlags(void) const;
    };
	
	class __declspec( dllexport ) MovableObjectFactory 
{
protected:
		unsigned long mTypeFlag;
		
virtual MovableObject* createInstanceImpl(
const String& name, const NameValuePairList* params = 0) = 0;
public:
MovableObjectFactory() : mTypeFlag(0xFFFFFFFF) {}
virtual ~MovableObjectFactory() {}
		virtual const String& getType(void) const = 0;
		
		virtual MovableObject* createInstance(
const String& name, SceneManager* manager, 
const NameValuePairList* params = 0);
		virtual void destroyInstance(MovableObject* obj) = 0;
		
		virtual bool requestTypeFlags(void) const { return false; }
		void _notifyTypeFlags(unsigned long flag) { mTypeFlag = flag; }
		
		unsigned long getTypeFlags(void) const { return mTypeFlag; }
	};
}
namespace Ogre {
    
    class __declspec( dllexport ) MovablePlane : public Plane, public MovableObject
{
protected:
mutable Plane mDerivedPlane;
mutable Vector3 mLastTranslate;
mutable Quaternion mLastRotate;
AxisAlignedBox mNullBB;
mutable bool mDirty;
static String msMovableType;
public:
        MovablePlane(const String& name);
MovablePlane (const Plane& rhs);
        MovablePlane (const Vector3& rkNormal, Real fConstant);
MovablePlane (const Vector3& rkNormal, const Vector3& rkPoint);
MovablePlane (const Vector3& rkPoint0, const Vector3& rkPoint1,
const Vector3& rkPoint2);
~MovablePlane() {}
        void _notifyCurrentCamera(Camera*) {  }
        const AxisAlignedBox& getBoundingBox(void) const { return mNullBB; }
        Real getBoundingRadius(void) const { return Math::POS_INFINITY; }
        void _updateRenderQueue(RenderQueue*) { }
        const String& getMovableType(void) const;
        const Plane& _getDerivedPlane(void) const;
    };
}
namespace Ogre
{
    enum ProjectionType
{
PT_ORTHOGRAPHIC,
PT_PERSPECTIVE
};
    
    enum FrustumPlane
{
FRUSTUM_PLANE_NEAR   = 0,
FRUSTUM_PLANE_FAR    = 1,
FRUSTUM_PLANE_LEFT   = 2,
FRUSTUM_PLANE_RIGHT  = 3,
FRUSTUM_PLANE_TOP    = 4,
FRUSTUM_PLANE_BOTTOM = 5
};
    
    class __declspec( dllexport ) Frustum : public MovableObject, public Renderable
{
protected:
        ProjectionType mProjType;
        
Radian mFOVy;
        Real mFarDist;
        Real mNearDist;
        Real mAspect;
        Vector2 mFrustumOffset;
        Real mFocalLength;
        
mutable Plane mFrustumPlanes[6];
        
mutable Quaternion mLastParentOrientation;
mutable Vector3 mLastParentPosition;
        
mutable Matrix4 mProjMatrixRS;
        mutable Matrix4 mProjMatrixRSDepth;
        mutable Matrix4 mProjMatrix;
        mutable Matrix4 mViewMatrix;
        mutable bool mRecalcFrustum;
        mutable bool mRecalcView;
        mutable bool mRecalcFrustumPlanes;
        mutable bool mRecalcWorldSpaceCorners;
        mutable bool mRecalcVertexData;
		bool mCustomViewMatrix;
		bool mCustomProjMatrix;
		
        virtual void calcProjectionParameters(Real& left, Real& right, Real& bottom, Real& top) const;
        virtual void updateFrustum(void) const;
        virtual void updateView(void) const;
		virtual void updateFrustumImpl(void) const;
		virtual void updateViewImpl(void) const;
virtual void updateFrustumPlanes(void) const;
		virtual void updateFrustumPlanesImpl(void) const;
virtual void updateWorldSpaceCorners(void) const;
		virtual void updateWorldSpaceCornersImpl(void) const;
virtual void updateVertexData(void) const;
virtual bool isViewOutOfDate(void) const;
virtual bool isFrustumOutOfDate(void) const;
        virtual void invalidateFrustum(void) const;
        virtual void invalidateView(void) const;
        
static String msMovableType;
        mutable AxisAlignedBox mBoundingBox;
mutable VertexData mVertexData;
        MaterialPtr mMaterial;
mutable Vector3 mWorldSpaceCorners[8];
        
bool mReflect;
        mutable Matrix4 mReflectMatrix;
		mutable Plane mReflectPlane;
		const MovablePlane* mLinkedReflectPlane;
		mutable Plane mLastLinkedReflectionPlane;
        
bool mObliqueDepthProjection;
		mutable Plane mObliqueProjPlane;
		const MovablePlane* mLinkedObliqueProjPlane;
		mutable Plane mLastLinkedObliqueProjPlane;
		
        virtual const Vector3& getPositionForViewUpdate(void) const;
        virtual const Quaternion& getOrientationForViewUpdate(void) const;
    public:
        Frustum();
virtual ~Frustum();
        virtual void setFOVy(const Radian& fovy);
        
        virtual const Radian& getFOVy(void) const;
        
        virtual void setNearClipDistance(Real nearDist);
        
        virtual Real getNearClipDistance(void) const;
        
        virtual void setFarClipDistance(Real farDist);
        
        virtual Real getFarClipDistance(void) const;
        
        virtual void setAspectRatio(Real ratio);
        
        virtual Real getAspectRatio(void) const;
        
        virtual void setFrustumOffset(const Vector2& offset);
        
        virtual void setFrustumOffset(Real horizontal = 0.0, Real vertical = 0.0);
        
        virtual const Vector2& getFrustumOffset() const;
        
        virtual void setFocalLength(Real focalLength = 1.0);
        
        virtual Real getFocalLength() const;
        
        virtual const Matrix4& getProjectionMatrixRS(void) const;
        virtual const Matrix4& getProjectionMatrixWithRSDepth(void) const;
        virtual const Matrix4& getProjectionMatrix(void) const;
        
        virtual const Matrix4& getViewMatrix(void) const;
		
		virtual void setCustomViewMatrix(bool enable, 
const Matrix4& viewMatrix = Matrix4::IDENTITY);
		virtual bool isCustomViewMatrixEnabled(void) const 
{ return mCustomViewMatrix; }
		
		virtual void setCustomProjectionMatrix(bool enable, 
const Matrix4& projectionMatrix = Matrix4::IDENTITY);
		virtual bool isCustomProjectionMatrixEnabled(void) const
{ return mCustomProjMatrix; }
		
        virtual const Plane* getFrustumPlanes(void) const;
        
        virtual const Plane& getFrustumPlane( unsigned short plane ) const;
        
        virtual bool isVisible(const AxisAlignedBox& bound, FrustumPlane* culledBy = 0) const;
        
        virtual bool isVisible(const Sphere& bound, FrustumPlane* culledBy = 0) const;
        
        virtual bool isVisible(const Vector3& vert, FrustumPlane* culledBy = 0) const;
        
const AxisAlignedBox& getBoundingBox(void) const;
        
Real getBoundingRadius(void) const;
		
void _updateRenderQueue(RenderQueue* queue);
        
const String& getMovableType(void) const;
        
void _notifyCurrentCamera(Camera* cam);
        
const MaterialPtr& getMaterial(void) const;
        
void getRenderOperation(RenderOperation& op);
        
void getWorldTransforms(Matrix4* xform) const;
        
const Quaternion& getWorldOrientation(void) const;
        
const Vector3& getWorldPosition(void) const;
        
Real getSquaredViewDepth(const Camera* cam) const;
        
const LightList& getLights(void) const;
        
        virtual const Vector3* getWorldSpaceCorners(void) const;
        
        virtual void setProjectionType(ProjectionType pt);
        
        virtual ProjectionType getProjectionType(void) const;
        
        virtual void enableReflection(const Plane& p);
        virtual void enableReflection(const MovablePlane* p);
        
virtual void disableReflection(void);
        
virtual bool isReflected(void) const { return mReflect; }
        virtual const Matrix4& getReflectionMatrix(void) const { return mReflectMatrix; }
        virtual const Plane& getReflectionPlane(void) const { return mReflectPlane; }
        
        virtual bool projectSphere(const Sphere& sphere, 
Real* left, Real* top, Real* right, Real* bottom) const;
		
		virtual void enableCustomNearClipPlane(const MovablePlane* plane);
		virtual void enableCustomNearClipPlane(const Plane& plane);
		virtual void disableCustomNearClipPlane(void);
		virtual bool isCustomNearClipPlaneEnabled(void) const 
{ return mObliqueDepthProjection; }
        
static const Real INFINITE_FAR_PLANE_ADJUST;
};
}
namespace Ogre {
    
    class __declspec( dllexport ) PlaneBoundedVolume
{
public:
typedef std::vector<Plane> PlaneList;
        PlaneList planes;
Plane::Side outside;
        PlaneBoundedVolume() :outside(Plane::NEGATIVE_SIDE) {}
        PlaneBoundedVolume(Plane::Side theOutside) 
: outside(theOutside) {}
        
        inline bool intersects(const AxisAlignedBox& box) const
{
if (box.isNull()) return false;
if (box.isInfinite()) return true;
            
Vector3 centre = box.getCenter();
            Vector3 halfSize = box.getHalfSize();
            PlaneList::const_iterator i, iend;
iend = planes.end();
for (i = planes.begin(); i != iend; ++i)
{
const Plane& plane = *i;
                Plane::Side side = plane.getSide(centre, halfSize);
if (side == outside)
{
                    return false;
}
}
            
return true;
        }
        inline bool intersects(const Sphere& sphere) const
{
PlaneList::const_iterator i, iend;
iend = planes.end();
for (i = planes.begin(); i != iend; ++i)
{
const Plane& plane = *i;
                
Real d = plane.getDistance(sphere.getCenter());
                if (outside == Plane::NEGATIVE_SIDE) d = -d;
                if ( (d - sphere.getRadius()) > 0)
return false;
}
            return true;
        }
        
        inline std::pair<bool, Real> intersects(const Ray& ray)
{
return Math::intersects(ray, planes, outside == Plane::POSITIVE_SIDE);
}
    };
    typedef std::vector<PlaneBoundedVolume> PlaneBoundedVolumeList;
}
namespace Ogre {
    
class __declspec( dllexport ) Ray
{
protected:
Vector3 mOrigin;
Vector3 mDirection;
public:
Ray():mOrigin(Vector3::ZERO), mDirection(Vector3::UNIT_Z) {}
Ray(const Vector3& origin, const Vector3& direction)
:mOrigin(origin), mDirection(direction) {}
        
void setOrigin(const Vector3& origin) {mOrigin = origin;} 
        const Vector3& getOrigin(void) const {return mOrigin;} 
        
void setDirection(const Vector3& dir) {mDirection = dir;} 
        const Vector3& getDirection(void) const {return mDirection;} 
		
Vector3 getPoint(Real t) const { 
return Vector3(mOrigin + (mDirection * t));
}
		
Vector3 operator*(Real t) const { 
return getPoint(t);
};
		
		std::pair<bool, Real> intersects(const Plane& p) const
{
return Math::intersects(*this, p);
}
        std::pair<bool, Real> intersects(const PlaneBoundedVolume& p) const
{
return Math::intersects(*this, p.planes, p.outside == Plane::POSITIVE_SIDE);
}
		std::pair<bool, Real> intersects(const Sphere& s) const
{
return Math::intersects(*this, s);
}
		std::pair<bool, Real> intersects(const AxisAlignedBox& box) const
{
return Math::intersects(*this, box);
}
    };
}
namespace Ogre {
    
    class __declspec( dllexport ) Camera : public Frustum
{
protected:
        String mName;
        SceneManager *mSceneMgr;
        
Quaternion mOrientation;
        
Vector3 mPosition;
        
mutable Quaternion mDerivedOrientation;
mutable Vector3 mDerivedPosition;
        
mutable Quaternion mRealOrientation;
mutable Vector3 mRealPosition;
        
bool mYawFixed;
        Vector3 mYawFixedAxis;
        
PolygonMode mSceneDetail;
        
unsigned int mVisFacesLastRender;
        
unsigned int mVisBatchesLastRender;
        
static String msMovableType;
        
SceneNode* mAutoTrackTarget;
        Vector3 mAutoTrackOffset;
		
Real mSceneLodFactor;
		Real mSceneLodFactorInv;
        
        Real mWLeft, mWTop, mWRight, mWBottom;
        bool mWindowSet;
        mutable std::vector<Plane> mWindowClipPlanes;
        mutable bool mRecalcWindow;
        Viewport* mLastViewport;
        bool mAutoAspectRatio;
		Frustum *mCullFrustum;
		bool mUseRenderingDistance;
        
bool isViewOutOfDate(void) const;
        void invalidateFrustum(void) const;
        void invalidateView(void) const;
        
        virtual void setWindowImpl(void) const;
        const Vector3& getPositionForViewUpdate(void) const;
        const Quaternion& getOrientationForViewUpdate(void) const;
		
virtual std::vector<Vector4> getRayForwardIntersect(const Vector3& anchor, const Vector3 *dir, Real planeOffset) const;
    public:
        Camera( const String& name, SceneManager* sm);
        
        virtual ~Camera();
        
        SceneManager* getSceneManager(void) const;
        
        virtual const String& getName(void) const;
        
        void setPolygonMode(PolygonMode sd);
        
        PolygonMode getPolygonMode(void) const;
        
        void setPosition(Real x, Real y, Real z);
        
        void setPosition(const Vector3& vec);
        
        const Vector3& getPosition(void) const;
        
        void move(const Vector3& vec);
        
        void moveRelative(const Vector3& vec);
        
        void setDirection(Real x, Real y, Real z);
        
        void setDirection(const Vector3& vec);
        
        Vector3 getDirection(void) const;
        
        Vector3 getUp(void) const;
        
        Vector3 getRight(void) const;
        
        void lookAt( const Vector3& targetPoint );
        void lookAt(Real x, Real y, Real z);
        
        void roll(const Radian& angle);
        
        void yaw(const Radian& angle);
        
        void pitch(const Radian& angle);
        
        void rotate(const Vector3& axis, const Radian& angle);
        
        void rotate(const Quaternion& q);
        
        void setFixedYawAxis( bool useFixed, const Vector3& fixedAxis = Vector3::UNIT_Y );
        
        const Quaternion& getOrientation(void) const;
        
        void setOrientation(const Quaternion& q);
        
        void _renderScene(Viewport *vp, bool includeOverlays);
        
        __declspec( dllexport ) friend std::ostream& operator<<(std::ostream& o, const Camera& c);
        
        void _notifyRenderedFaces(unsigned int numfaces);
        
        void _notifyRenderedBatches(unsigned int numbatches);
        
        unsigned int _getNumRenderedFaces(void) const;
        
        unsigned int _getNumRenderedBatches(void) const;
        
        const Quaternion& getDerivedOrientation(void) const;
        const Vector3& getDerivedPosition(void) const;
        Vector3 getDerivedDirection(void) const;
        Vector3 getDerivedUp(void) const;
        Vector3 getDerivedRight(void) const;
        
        const Quaternion& getRealOrientation(void) const;
        const Vector3& getRealPosition(void) const;
        Vector3 getRealDirection(void) const;
        Vector3 getRealUp(void) const;
        Vector3 getRealRight(void) const;
        
const String& getMovableType(void) const;
        
        void setAutoTracking(bool enabled, SceneNode* target = 0, 
const Vector3& offset = Vector3::ZERO);
		
		void setLodBias(Real factor = 1.0);
		
		Real getLodBias(void) const;
        
        Ray getCameraToViewportRay(Real screenx, Real screeny) const;
		
Real _getLodBiasInverse(void) const;
        
void _autoTrack(void);
        
        virtual void setWindow (Real Left, Real Top, Real Right, Real Bottom);
        virtual void resetWindow (void);
        virtual bool isWindowSet(void) const { return mWindowSet; }
        const std::vector<Plane>& getWindowPlanes(void) const;
        
Real getBoundingRadius(void) const;
        SceneNode* getAutoTrackTarget(void) const { return mAutoTrackTarget; }
		const Vector3& getAutoTrackOffset(void) const { return mAutoTrackOffset; }
        
        Viewport* getViewport(void) const {return mLastViewport;}
        void _notifyViewport(Viewport* viewport) {mLastViewport = viewport;}
        
    
void setAutoAspectRatio(bool autoratio);
        
        bool getAutoAspectRatio(void) const;
		
		void setCullingFrustum(Frustum* frustum) { mCullFrustum = frustum; }
		Frustum* getCullingFrustum(void) { return mCullFrustum; }
		
		virtual void forwardIntersect(const Plane& worldPlane, std::vector<Vector4>* intersect3d) const;
		
bool isVisible(const AxisAlignedBox& bound, FrustumPlane* culledBy = 0) const;
		bool isVisible(const Sphere& bound, FrustumPlane* culledBy = 0) const;
		bool isVisible(const Vector3& vert, FrustumPlane* culledBy = 0) const;
		const Vector3* getWorldSpaceCorners(void) const;
		const Plane& getFrustumPlane( unsigned short plane ) const;
		bool projectSphere(const Sphere& sphere, 
Real* left, Real* top, Real* right, Real* bottom) const;
		Real getNearClipDistance(void) const;
		Real getFarClipDistance(void) const;
		const Matrix4& getViewMatrix(void) const;
		const Matrix4& getViewMatrix(bool ownFrustumOnly) const;
		virtual void setUseRenderingDistance(bool use) { mUseRenderingDistance = use; }
		virtual bool getUseRenderingDistance(void) const { return mUseRenderingDistance; }
     };
} 
namespace Ogre {
    
    class __declspec( dllexport ) ArchiveFactory : public FactoryObj< Archive >
{
public:
    };
} 
namespace Ogre {
    
    class __declspec( dllexport ) FileSystemArchive : public Archive 
{
protected:
        void findFiles(const String& pattern, bool recursive, bool dirs,
StringVector* simpleList, FileInfoList* detailList);
    public:
FileSystemArchive(const String& name, const String& archType );
~FileSystemArchive();
        
bool isCaseSensitive(void) const;
        
void load();
        void unload();
        
DataStreamPtr open(const String& filename) const;
        
StringVectorPtr list(bool recursive = true, bool dirs = false);
        
FileInfoListPtr listFileInfo(bool recursive = true, bool dirs = false);
        
StringVectorPtr find(const String& pattern, bool recursive = true,
bool dirs = false);
        
FileInfoListPtr findFileInfo(const String& pattern, bool recursive = true,
bool dirs = false);
        
bool exists(const String& filename);
    };
    
class  FileSystemArchiveFactory : public ArchiveFactory
{
public:
virtual ~FileSystemArchiveFactory() {}
        const String& getType(void) const;
        Archive *createInstance( const String& name ) 
{
return new FileSystemArchive(name, "FileSystem");
}
        void destroyInstance( Archive* arch) { delete arch; }
};
}
namespace Ogre {
    
    
    enum LoggingLevel
{
LL_LOW = 1,
LL_NORMAL = 2,
LL_BOREME = 3
};
    
    enum LogMessageLevel
{
LML_TRIVIAL = 1,
LML_NORMAL = 2,
LML_CRITICAL = 3
};
    
class LogListener
{
public:
virtual ~LogListener() {};
        
        virtual void messageLogged( const String& message, LogMessageLevel lml, bool maskDebug, const String &logName ) = 0;
};
    
    class __declspec( dllexport ) Log
{
protected:
std::ofstream	mfpLog;
LoggingLevel	mLogLevel;
bool			mDebugOut;
bool			mSuppressFile;
String			mLogName;
        typedef std::vector<LogListener*> mtLogListener;
mtLogListener mListeners;
    public:
        
        Log( const String& name, bool debugOutput = true, bool suppressFileOutput = false);
        
        ~Log();
		
const String& getName() const { return mLogName; }
		bool isDebugOutputEnabled() const { return mDebugOut; }
		bool isFileOutputSuppressed() const { return mSuppressFile; }
        
        void logMessage( const String& message, LogMessageLevel lml = LML_NORMAL, bool maskDebug = false );
        
        void setDebugOutputEnabled(bool debugOutput);
        void setLogDetail(LoggingLevel ll);
		LoggingLevel getLogDetail() const { return mLogLevel; }
        void addListener(LogListener* listener);
        
        void removeListener(LogListener* listener);
};
}
namespace Ogre {
    
    class __declspec( dllexport ) Node : public Renderable
{
public:
        enum TransformSpace
{
            TS_LOCAL,
            TS_PARENT,
            TS_WORLD
};
typedef ::stdext::hash_map<String, Node*> ChildNodeMap;
typedef MapIterator<ChildNodeMap> ChildNodeIterator;
typedef ConstMapIterator<ChildNodeMap> ConstChildNodeIterator;
		
		class __declspec( dllexport ) Listener
{
public:
Listener() {}
virtual ~Listener() {}
			virtual void nodeUpdated(const Node*) {}
			virtual void nodeDestroyed(const Node*) {};
			virtual void nodeAttached(const Node*) {};
			virtual void nodeDetached(const Node*) {};
};
    protected:
        Node* mParent;
        ChildNodeMap mChildren;
		typedef std::set<Node*> ChildUpdateSet;
        mutable ChildUpdateSet mChildrenToUpdate;
        mutable bool mNeedParentUpdate;
		mutable bool mNeedChildUpdate;
	    mutable bool mParentNotified ;
        mutable bool mQueuedForUpdate;
        
String mName;
        
static unsigned long msNextGeneratedNameExt;
        
Quaternion mOrientation;
        
Vector3 mPosition;
        
Vector3 mScale;
        
bool mInheritOrientation;
        
bool mInheritScale;
		
mutable MaterialPtr mpMaterial;
        
virtual void setParent(Node* parent);
        
        mutable Quaternion mDerivedOrientation;
        
        mutable Vector3 mDerivedPosition;
        
        mutable Vector3 mDerivedScale;
        
        virtual void _updateFromParent(void) const;
		
		virtual void updateFromParentImpl(void) const;
        
virtual Node* createChildImpl(void) = 0;
        
virtual Node* createChildImpl(const String& name) = 0;
        
Vector3 mInitialPosition;
        Quaternion mInitialOrientation;
        Vector3 mInitialScale;
        
mutable Matrix4 mCachedTransform;
mutable bool mCachedTransformOutOfDate;
		
Listener* mListener;
		typedef std::vector<Node*> QueuedUpdates;
static QueuedUpdates msQueuedUpdates;
    public:
        Node();
        Node(const String& name);
        virtual ~Node();  
        
const String& getName(void) const;
        
        virtual Node* getParent(void) const;
        
        virtual const Quaternion & getOrientation() const;
        
        virtual void setOrientation( const Quaternion& q );
        
        virtual void setOrientation( Real w, Real x, Real y, Real z);
        
        virtual void resetOrientation(void);
        
        virtual void setPosition(const Vector3& pos);
        
        virtual void setPosition(Real x, Real y, Real z);
        
        virtual const Vector3 & getPosition(void) const;
        
        virtual void setScale(const Vector3& scale);
        
        virtual void setScale(Real x, Real y, Real z);
        
        virtual const Vector3 & getScale(void) const;
        
        virtual void setInheritOrientation(bool inherit);
        
        virtual bool getInheritOrientation(void) const;
        
        virtual void setInheritScale(bool inherit);
        
        virtual bool getInheritScale(void) const;
        
        virtual void scale(const Vector3& scale);
        
        virtual void scale(Real x, Real y, Real z);
        
        virtual void translate(const Vector3& d, TransformSpace relativeTo = TS_PARENT);
        virtual void translate(Real x, Real y, Real z, TransformSpace relativeTo = TS_PARENT);
        virtual void translate(const Matrix3& axes, const Vector3& move, TransformSpace relativeTo = TS_PARENT);
        virtual void translate(const Matrix3& axes, Real x, Real y, Real z, TransformSpace relativeTo = TS_PARENT);
        
        virtual void roll(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);
        
        virtual void pitch(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);
        
        virtual void yaw(const Radian& angle, TransformSpace relativeTo = TS_LOCAL);
        
        virtual void rotate(const Vector3& axis, const Radian& angle, TransformSpace relativeTo = TS_LOCAL);
        
        virtual void rotate(const Quaternion& q, TransformSpace relativeTo = TS_LOCAL);
        
        virtual Matrix3 getLocalAxes(void) const;
        
        virtual Node* createChild(
const Vector3& translate = Vector3::ZERO, 
const Quaternion& rotate = Quaternion::IDENTITY );
        
        virtual Node* createChild(const String& name, const Vector3& translate = Vector3::ZERO, const Quaternion& rotate = Quaternion::IDENTITY);
        
        virtual void addChild(Node* child);
        
        virtual unsigned short numChildren(void) const;
        
        virtual Node* getChild(unsigned short index) const;    
        
        virtual Node* getChild(const String& name) const;
        
        virtual ChildNodeIterator getChildIterator(void);
        
		virtual ConstChildNodeIterator getChildIterator(void) const;
        
        virtual Node* removeChild(unsigned short index);
        virtual Node* removeChild(Node* child);
        
        virtual Node* removeChild(const String& name);
        virtual void removeAllChildren(void);
        
        virtual const Quaternion & _getDerivedOrientation(void) const;
        
        virtual const Vector3 & _getDerivedPosition(void) const;
        
        virtual const Vector3 & _getDerivedScale(void) const;
        
        virtual const Matrix4& _getFullTransform(void) const;
        
        virtual void _update(bool updateChildren, bool parentHasChanged);
        
		virtual void setListener(Listener* listener) { mListener = listener; }
		
		virtual Listener* getListener(void) const { return mListener; }
		
        const MaterialPtr& getMaterial(void) const;
        void getRenderOperation(RenderOperation& op);
        void getWorldTransforms(Matrix4* xform) const;
        const Quaternion& getWorldOrientation(void) const;
        const Vector3& getWorldPosition(void) const;
        
        virtual void setInitialState(void);
        
virtual void resetToInitialState(void);
        
        virtual const Vector3& getInitialPosition(void) const;
        
virtual const Quaternion& getInitialOrientation(void) const;
        
virtual const Vector3& getInitialScale(void) const;
        
Real getSquaredViewDepth(const Camera* cam) const;
        
        virtual void needUpdate(bool forceParentUpdate = false);
        virtual void requestUpdate(Node* child, bool forceParentUpdate = false);
        virtual void cancelUpdate(Node* child);
		
		static void queueNeedUpdate(Node* n);
		static void processQueuedUpdates(void);
        
const LightList& getLights(void) const;
    };
} 
namespace Ogre {
    
    class __declspec( dllexport ) Serializer
{
public:
Serializer();
virtual ~Serializer();
		
enum Endian
{
			ENDIAN_NATIVE,
			ENDIAN_BIG,
			ENDIAN_LITTLE
};
    protected:
        uint32 mCurrentstreamLen;
FILE* mpfFile;
String mVersion;
bool mFlipEndian; 
        
virtual void writeFileHeader(void);
virtual void writeChunkHeader(uint16 id, size_t size);
        void writeFloats(const float* const pfloat, size_t count);
void writeFloats(const double* const pfloat, size_t count);
void writeShorts(const uint16* const pShort, size_t count);
void writeInts(const uint32* const pInt, size_t count); 
void writeBools(const bool* const pLong, size_t count);
void writeObject(const Vector3& vec);
void writeObject(const Quaternion& q);
        void writeString(const String& string);
void writeData(const void* const buf, size_t size, size_t count);
        virtual void readFileHeader(DataStreamPtr& stream);
virtual unsigned short readChunk(DataStreamPtr& stream);
        void readBools(DataStreamPtr& stream, bool* pDest, size_t count);
void readFloats(DataStreamPtr& stream, float* pDest, size_t count);
void readFloats(DataStreamPtr& stream, double* pDest, size_t count);
void readShorts(DataStreamPtr& stream, uint16* pDest, size_t count);
void readInts(DataStreamPtr& stream, uint32* pDest, size_t count);
void readObject(DataStreamPtr& stream, Vector3& pDest);
void readObject(DataStreamPtr& stream, Quaternion& pDest);
        String readString(DataStreamPtr& stream);
String readString(DataStreamPtr& stream, size_t numChars);
        virtual void flipToLittleEndian(void* pData, size_t size, size_t count = 1);
virtual void flipFromLittleEndian(void* pData, size_t size, size_t count = 1);
        virtual void flipEndian(void * pData, size_t size, size_t count);
virtual void flipEndian(void * pData, size_t size);
		
virtual void determineEndianness(DataStreamPtr& stream);
		virtual void determineEndianness(Endian requestedEndian);
};
}
namespace Ogre {
    class __declspec( dllexport ) SimpleRenderable : public MovableObject, public Renderable
{
protected:
RenderOperation mRenderOp;
        Matrix4 m_matWorldTransform;
AxisAlignedBox mBox;
        String m_strMatName;
MaterialPtr m_pMaterial;
        
SceneManager *m_pParentSceneManager;
        
Camera *m_pCamera;
        
static uint ms_uGenNameCount;
    public:
SimpleRenderable();
        void setMaterial( const String& matName );
virtual const MaterialPtr& getMaterial(void) const;
        virtual void setRenderOperation( const RenderOperation& rend );
virtual void getRenderOperation(RenderOperation& op);
        void setWorldTransform( const Matrix4& xform );
virtual void getWorldTransforms( Matrix4* xform ) const;
        const Quaternion& getWorldOrientation(void) const;
        const Vector3& getWorldPosition(void) const;
        virtual void _notifyCurrentCamera(Camera* cam);
        void setBoundingBox( const AxisAlignedBox& box );
virtual const AxisAlignedBox& getBoundingBox(void) const;
        virtual void _updateRenderQueue(RenderQueue* queue);
        virtual ~SimpleRenderable();
        
virtual const String& getMovableType(void) const;
        
const LightList& getLights(void) const;
    };
}
namespace Ogre {
    
    class __declspec( dllexport ) SimpleSpline
{
public:
SimpleSpline();
~SimpleSpline();
        
void addPoint(const Vector3& p);
        
const Vector3& getPoint(unsigned short index) const;
        
unsigned short getNumPoints(void) const;
        
void clear(void);
        
        void updatePoint(unsigned short index, const Vector3& value);
        
        Vector3 interpolate(Real t);
        
        Vector3 interpolate(unsigned int fromIndex, Real t);
        
        void setAutoCalculate(bool autoCalc);
        
        void recalcTangents(void);
    protected:
        bool mAutoCalc;
        std::vector<Vector3> mPoints;
std::vector<Vector3> mTangents;
        
Matrix4 mCoeffs;
    };
}
#pragma warning (disable : 4311)
#pragma warning (disable : 4312)
namespace Ogre {
    
    template <typename T> class Singleton
{
protected:
        static T* ms_Singleton;
    public:
Singleton( void )
{
((void)0);
	    ms_Singleton = static_cast< T* >( this );
        }
~Singleton( void )
{  ((void)0);  ms_Singleton = 0;  }
static T& getSingleton( void )
{	((void)0);  return ( *ms_Singleton ); }
static T* getSingletonPtr( void )
{ return ms_Singleton; }
};
}
namespace Ogre {
    
    class __declspec( dllexport ) StringConverter
{
public:
        
static String toString(Real val, unsigned short precision = 6, 
unsigned short width = 0, char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) );
        static String toString(Radian val, unsigned short precision = 6, 
unsigned short width = 0, char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) )
{
return toString(val.valueAngleUnits(), precision, width, fill, flags);
}
        static String toString(Degree val, unsigned short precision = 6, 
unsigned short width = 0, char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) )
{
return toString(val.valueAngleUnits(), precision, width, fill, flags);
}
        static String toString(int val, unsigned short width = 0, 
char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) );
        
static String toString(size_t val, 
unsigned short width = 0, char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) );
        static String toString(unsigned long val, 
unsigned short width = 0, char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) );
        
static String toString(long val, 
unsigned short width = 0, char fill = ' ', 
std::ios::fmtflags flags = std::ios::fmtflags(0) );
        static String toString(bool val, bool yesNo = false);
        static String toString(const Vector2& val);
        static String toString(const Vector3& val);
        static String toString(const Vector4& val);
        static String toString(const Matrix3& val);
        static String toString(const Matrix4& val);
        static String toString(const Quaternion& val);
        static String toString(const ColourValue& val);
        static String toString(const StringVector& val);
        
        static Real parseReal(const String& val);
        static inline Radian parseAngle(const String& val) {
return Angle(parseReal(val));
}
        static int parseInt(const String& val);
        static unsigned int parseUnsignedInt(const String& val);
        static long parseLong(const String& val);
        static unsigned long parseUnsignedLong(const String& val);
        static bool parseBool(const String& val);
        static Vector3 parseVector3(const String& val);
        static Matrix3 parseMatrix3(const String& val);
        static Matrix4 parseMatrix4(const String& val);
        static Quaternion parseQuaternion(const String& val);
        static ColourValue parseColourValue(const String& val);
        
        static StringVector parseStringVector(const String& val);
        static bool isNumber(const String& val);
};
}
namespace Ogre {
    
	class __declspec( dllexport ) WireBoundingBox : public SimpleRenderable
{
protected:
		void getWorldTransforms( Matrix4* xform ) const;
        const Quaternion& getWorldOrientation(void) const;
        const Vector3& getWorldPosition(void) const;
        
		void setupBoundingBoxVertices(const AxisAlignedBox& aab);
        Real mRadius;
	public:
		WireBoundingBox();
~WireBoundingBox();
        
		void setupBoundingBox(const AxisAlignedBox& aabb);
		Real getSquaredViewDepth(const Camera* cam) const;
        Real getBoundingRadius(void) const { return mRadius; }
	};
}
typedef struct zzip_dir		ZZIP_DIR;
typedef struct zzip_file	ZZIP_FILE;
namespace Ogre {
    
    class __declspec( dllexport ) ZipArchive : public Archive 
{
protected:
        ZZIP_DIR* mZzipDir;
        void checkZzipError(int zzipError, const String& operation) const;
        FileInfoList mFileList;
public:
ZipArchive(const String& name, const String& archType );
~ZipArchive();
        bool isCaseSensitive(void) const { return false; }
        
void load();
        void unload();
        
DataStreamPtr open(const String& filename) const;
        
StringVectorPtr list(bool recursive = true, bool dirs = false);
        
FileInfoListPtr listFileInfo(bool recursive = true, bool dirs = false);
        
StringVectorPtr find(const String& pattern, bool recursive = true,
bool dirs = false);
        
FileInfoListPtr findFileInfo(const String& pattern, bool recursive = true,
bool dirs = false);
        
bool exists(const String& filename);
};
    
class  ZipArchiveFactory : public ArchiveFactory
{
public:
virtual ~ZipArchiveFactory() {}
        const String& getType(void) const;
        Archive *createInstance( const String& name ) 
{
return new ZipArchive(name, "Zip");
}
        void destroyInstance( Archive* arch) { delete arch; }
};
    
class  ZipDataStream : public DataStream
{
protected:
ZZIP_FILE* mZzipFile;
public:
        ZipDataStream(ZZIP_FILE* zzipFile, size_t uncompressedSize);
        ZipDataStream(const String& name, ZZIP_FILE* zzipFile, size_t uncompressedSize);
~ZipDataStream();
        size_t read(void* buf, size_t count);
        void skip(long count);
        void seek( size_t pos );
        size_t tell(void) const;
        bool eof(void) const;
        void close(void);
    };
}
namespace Ogre
{
const Vector3 Vector3::ZERO( 0, 0, 0 );
    const Vector3 Vector3::UNIT_X( 1, 0, 0 );
const Vector3 Vector3::UNIT_Y( 0, 1, 0 );
const Vector3 Vector3::UNIT_Z( 0, 0, 1 );
const Vector3 Vector3::NEGATIVE_UNIT_X( -1,  0,  0 );
const Vector3 Vector3::NEGATIVE_UNIT_Y(  0, -1,  0 );
const Vector3 Vector3::NEGATIVE_UNIT_Z(  0,  0, -1 );
const Vector3 Vector3::UNIT_SCALE(1, 1, 1);
}

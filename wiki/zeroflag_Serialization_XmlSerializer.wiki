#summary zeroflag.Serialization.XmlSerializer

= What is a serializer? =
There's a nice [http://en.wikipedia.org/wiki/Serialization wikipedia article] about this, so I can't really be bothered to explain everything allover again.
What I will explain is...

= Why not the .NET [zeroflag_Serialization_XmlSerializer XmlSerializer]? =
Because it sucks. Seriously.
Have you ever tried to serialize any piece of meaningful data with it?
It will break on every simple construct, doesn't support cyclic references, is not very type-safe, has immense amounts of overhead and, did I mention that it will BREAK all the time?

= So what is different in zerolib's [zeroflag_Serialization_XmlSerializer XmlSerializer]? =
== Serialization Abstraction ==
=== What's wrong with the one in .NET? ===
First off, serialization isn't something that has to be done allover again from scratch for every type of data.
You do not need a completely different and incompatible serializer for XML data, and another, completely different and incompatible, serializer for Binary data. Why microsoft has implemented it like this anyway can only be blamed on... well, them being microsoft.

=== What's different in zerolib? ===
zerolib has something I call a "Descriptor". And you can provide more specialized Descriptors as required.

*What do Descriptors do?*
Simple, they describe an object.
They will not output any XML or binary data, they will simply scan the (public) properties on your objects, scan the values behind those properties and recursively scan and describe the Type/Object.

*Why not just use [http://en.wikipedia.org/wiki/Reflection_(computer_science) reflection] instead?*
Well, descriptors DO use reflection, but reflection is (mostly) a collection of static methods. It is not implemented with Object Orientation in mind and it certainly isn't a very nice tool to work with.
Besides, reflection can directly only work on types, but objects do not always _entirely_ follow the type-profile. Just think inheritance.
For example if you have
{{{
class Foo { public Foo Parent; }
class Bar : Foo { public List<Foo> Children; }
}}}
the Parent could actually contain an instance of type Foo, but it could also contain an instance of type Bar.
Basic reflection on the type will only tell you what was *defined* in the *type*, not what the *runtime instance* actually *contains*.

So long story short, zerolib will, if passed an instance, reflect on the *instance* and not the *type*, which is what is actually necessary to serialize an object.

=== So, what's the big deal about these Descriptors? ===
==== They are format independent. ====
You can throw them at any kind of data, and they will describe it. They will *not* produce any output.
Hence you can use the same bunch of descriptors for XML, Binary and whatever else you fancy.

==== They are extensible. ====
Descriptor is a baseclass.

zerolib implements a couple of commonly needed specializations.
e.g. there is a {{{ObjectDescriptor}}}, which will serve as a fallback-default if there's nothing better available...

there also is a {{{ListDescriptor}}}, which is actually not named quite correctly, as it actually can describe most Collection types ({{{ICollection<>}}} and (usually) also {{{ICollection}}}). This ListDescriptor is "smart" enough to be able to fill read-only properties, not serialize irrelevant data about the Collection (like Count), and, usually, succeed serializing Dictionaries (which implement a {{{ICollection<KeyValuePair<Key,Value>>}}})

There are also descriptors for Delegates and Types, which would, if serialized with the ObjectDescriptor, give the Descriptor-System access to the entire AppDomain... and serializing that is just a bit... too much.

The descriptors can be further specialized to describe certain structs that would be problematic otherwise, like {{{System.Drawing.Color}}} or {{{DateTime}}} (both also provided by zerolib).


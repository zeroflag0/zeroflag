#summary zeroflag.Serialization.XmlSerializer

= What is a serializer? =
There's a nice [http://en.wikipedia.org/wiki/Serialization wikipedia article] about this, so I can't really be bothered to explain everything all over again.
What I will explain is...

= Why not use the .NET XmlSerializer? =
Because it sucks. Seriously.
Have you ever tried to serialize any piece of meaningful data with it?
It will break on every simple construct, doesn't support cyclic references, is not very type-safe, has immense amounts of overhead and, did I mention that it will BREAK all the time?

= So what is different in zerolib's [zeroflag_Serialization_XmlSerializer XmlSerializer]? =
== Serialization Abstraction ==
=== What's wrong with the one in .NET? ===
First off, serialization isn't something that has to be done allover again from scratch for every type of data.
You do not need a completely different and incompatible serializer for XML data, and another, completely different and incompatible, serializer for Binary data. Why microsoft has implemented it like this anyway can only be blamed on... well, them being microsoft.

=== What's different in zerolib? ===
zerolib has something I call a "Descriptor". And you can provide more specialized Descriptors as required.

*What do Descriptors do?*
Simple, they describe an object.
They will not output any XML or binary data, they will simply scan the (public) properties on your objects, scan the values behind those properties and recursively scan and describe the Type/Object.

*Why not just use [http://en.wikipedia.org/wiki/Reflection_(computer_science) reflection] instead?*
Well, descriptors DO use reflection, but reflection is (mostly) a collection of static methods. It is not implemented with Object Orientation in mind and it certainly isn't a very nice tool to work with.
Besides, reflection can directly only work on types, but objects do not always _entirely_ follow the type-profile. Just think inheritance.
For example if you have
{{{
class Foo { public Foo Parent; }
class Bar : Foo { public List<Foo> Children; }
}}}
the Parent could actually contain an instance of type Foo, but it could also contain an instance of type Bar.
Basic reflection on the type will only tell you what was *defined* in the *type*, not what the *runtime instance* actually *contains*.

So long story short, zerolib will, if passed an instance, reflect on the *instance* and not the *type*, which is what is actually necessary to serialize an object.

=== So, what's the big deal about these Descriptors? ===
==== They are format independent. ====
You can throw them at any kind of data, and they will describe it. They will *not* produce any output.
Hence you can use the same bunch of descriptors for XML, Binary and whatever else you fancy.

==== They are extensible. ====
Descriptor is a baseclass.

zerolib implements a couple of commonly needed specializations.
e.g. there is a {{{ObjectDescriptor}}}, which will serve as a fallback-default if there's nothing better available...

there also is a {{{ListDescriptor}}}, which is actually not named quite correctly, as it actually can describe most Collection types ({{{ICollection<>}}} and (usually) also {{{ICollection}}}). This ListDescriptor is "smart" enough to be able to fill read-only properties, not serialize irrelevant data about the Collection (like Count), and, usually, succeed serializing Dictionaries (which implement a {{{ICollection<KeyValuePair<Key,Value>>}}})

There are also descriptors for Delegates and Types, which would, if serialized with the ObjectDescriptor, give the Descriptor-System access to the entire AppDomain... and serializing that is just a bit... too much.

The descriptors can be further specialized to describe certain structs that would be problematic otherwise, like {{{System.Drawing.Color}}} or {{{DateTime}}} (both also provided by zerolib).


== Xml Specialization ==
=== How is the Xml Serialization different in zerolib? ===
I'll admit, the XmlSerializer is a mess of code. That's mostly because there are so many things that could possibly go wrong when deserializing an XmlFile... especially when you consider...

==== Hand-Written Xml => ZML ====
This mostly includes case-insensitive property *and* type lookup and partial name resolution. 

A very "forgiving" parser specially built for hand-written Xml files is implemented in the *ZmlSerializer*.

The ZmlSerializer serves also as the base-class for the XmlSerializer, however the Xml version disables quite some "optimizations" that Zml would apply.

This results in the XmlSerializer producing more overhead when serializing, and being less forgiving when deserializng. However, it also means that the XmlSerializer is less likely to fail on ambiguous types and properties, and there will not be any data missing if your properties are pre-initialized.

== Error Handling ==
One of the most annoying properties of the .NET XmlSerializer is that it will throw exceptions, all over the place.

zerolib's serializers will try to catch any Syntax or Serialization error/exception, push them to the reporting system, and then try to continue.

This allows the programmer to either not care about any errors at all, write parsing-errors as "warnings" but still continue, or check the error report and gracefully exit - instead of being left with *NOTHING* if *ANYTHING* goes wrong.